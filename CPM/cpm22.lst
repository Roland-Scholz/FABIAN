     1
     2 			;**************************************************************
     3 			;*
     4 			;*             C P / M   version   2 . 2
     5 			;*
     6 			;*   Reconstructed from memory image on February 27, 1981
     7 			;*
     8 			;*                by Clark A. Calkins
     9 			;*
    10 			;**************************************************************
    11 			;
    12 			;   Set memory limit here. This is the amount of contigeous
    13 			; ram starting from 0000. CP/M will reside at the end of this space.
    14 			;
    15      00 3E	MEM	EQU	62	;for a 62k system (TS802 TEST - WORKS OK).
    16 			;
    17      00 03	IOBYTE	EQU	3	;i/o definition byte.
    18      00 04	TDRIVE	EQU	4	;current drive name and user number.
    19      00 05	ENTRY	EQU	5	;entry point for the cp/m bdos.
    20      00 5C	TFCB	EQU	5CH	;default file control block.
    21      00 80	TBUFF	EQU	80H	;i/o buffer and command line storage.
    22      01 00	TBASE	EQU	100H	;transiant program storage area.
    23 			;
    24 			;   Set control character equates.
    25 			;
    26      00 03	CNTRLC	EQU	3	;control-c
    27      00 05	CNTRLE	EQU	05H	;control-e
    28      00 08	BS	EQU	08H	;backspace
    29      00 09	TAB	EQU	09H	;tab
    30      00 0A	LF	EQU	0AH	;line feed
    31      00 0C	FF	EQU	0CH	;form feed
    32      00 0D	CR	EQU	0DH	;carriage return
    33      00 10	CNTRLP	EQU	10H	;control-p
    34      00 12	CNTRLR	EQU	12H	;control-r
    35      00 13	CNTRLS	EQU	13H	;control-s
    36      00 15	CNTRLU	EQU	15H	;control-u
    37      00 18	CNTRLX	EQU	18H	;control-x
    38      00 1A	CNTRLZ	EQU	1AH	;control-z (end-of-file mark)
    39      00 7F	DEL	EQU	7FH	;rubout
    40 			;
    41 			;   Set origin for CP/M
    42 			;
    43      DC 00		ORG	(MEM-7)*1024
    44 			;
    45 DC00 C3 5C DF	CBASE	JMP	COMMAND	;execute command processor (ccp).
    46 DC03 C3 58 DF		JMP	CLEARBUF	;entry to empty input buffer before starting ccp.
    47
    48 			;
    49 			;   Standard cp/m ccp input buffer. Format is (max length),
    50 			; (actual length), (char #1), (char #2), (char #3), etc.
    51 			;
    52 DC06		INBUFF	DB	127	;length of input buffer.
            7F 
    53 DC07			DB	0	;current length of contents.
            00 
    54 DC08			DB	'Copyright'
            43 6F 70 79 
            72 69 67 68 
            74 
    55 DC11			DB	' 1979 (c) by Digital Research      '
            20 31 39 37 
            39 20 28 63 
            29 20 62 79 
            20 44 69 67 
            69 74 61 6C 
            20 52 65 73 
            65 61 72 63 
            68 20 20 20 
            20 20 20 
    56 DC34			DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 
    57 DC4B			DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 
    58 DC62			DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 
    59 DC79			DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 
    60 DC88		INPOINT	DW	INBUFF+2;input line pointer
            08DC 
    61 DC8A		NAMEPNT	DW	0	;input line pointer used for error message. Points to
            0000 
    62 			;			;start of name in error.
    63 			;
    64 			;   Routine to print (A) on the console. All registers used.
    65 			;
    66 DC8C 5F		PRINT	MOV	E,A	;setup bdos call.
    67 DC8D 0E 02		MVI	C,2
    68 DC8F C3 05 00		JMP	ENTRY
    69 			;
    70 			;   Routine to print (A) on the console and to save (BC).
    71 			;
    72 DC92 C5		PRINTB	PUSH	B
    73 DC93 CD 8C DC		CALL	PRINT
    74 DC96 C1			POP	B
    75 DC97 C9			RET
    76 			;
    77 			;   Routine to send a carriage return, line feed combination
    78 			; to the console.
    79 			;
    80 DC98 3E 0D	CRLF	MVI	A,CR
    81 DC9A CD 92 DC		CALL	PRINTB
    82 DC9D 3E 0A		MVI	A,LF
    83 DC9F C3 92 DC		JMP	PRINTB
    84 			;
    85 			;   Routine to send one space to the console and save (BC).
    86 			;
    87 DCA2 3E 20	SPACE	MVI	A,' '
    88 DCA4 C3 92 DC		JMP	PRINTB
    89 			;
    90 			;   Routine to print character string pointed to be (BC) on the
    91 			; console. It must terminate with a null byte.
    92 			;
    93 DCA7 C5		PLINE	PUSH	B
    94 DCA8 CD 98 DC		CALL	CRLF
    95 DCAB E1			POP	H
    96 DCAC 7E		PLINE2	MOV	A,M
    97 DCAD B7			ORA	A
    98 DCAE C8			RZ
    99 DCAF 23			INX	H
   100 DCB0 E5			PUSH	H
   101 DCB1 CD 8C DC		CALL	PRINT
   102 DCB4 E1			POP	H
   103 DCB5 C3 AC DC		JMP	PLINE2
   104 			;
   105 			;   Routine to reset the disk system.
   106 			;
   107 DCB8 0E 0D	RESDSK	MVI	C,13
   108 DCBA C3 05 00		JMP	ENTRY
   109 			;
   110 			;   Routine to select disk (A).
   111 			;
   112 DCBD 5F		DSKSEL	MOV	E,A
   113 DCBE 0E 0E		MVI	C,14
   114 DCC0 C3 05 00		JMP	ENTRY
   115 			;
   116 			;   Routine to call bdos and save the return code. The zero
   117 			; flag is set on a return of 0ffh.
   118 			;
   119 DCC3 CD 05 00	ENTRY1	CALL	ENTRY
   120 DCC6 32 EE E3		STA	RTNCODE	;save return code.
   121 DCC9 3C			INR	A	;set zero if 0ffh returned.
   122 DCCA C9			RET
   123 			;
   124 			;   Routine to open a file. (DE) must point to the FCB.
   125 			;
   126 DCCB 0E 0F	OPEN	MVI	C,15
   127 DCCD C3 C3 DC		JMP	ENTRY1
   128 			;
   129 			;   Routine to open file at (FCB).
   130 			;
   131 DCD0 AF		OPENFCB	XRA	A	;clear the record number byte at fcb+32
   132 DCD1 32 ED E3		STA	FCB+32
   133 DCD4 11 CD E3		LXI	D,FCB
   134 DCD7 C3 CB DC		JMP	OPEN
   135 			;
   136 			;   Routine to close a file. (DE) points to FCB.
   137 			;
   138 DCDA 0E 10	CLOSE	MVI	C,16
   139 DCDC C3 C3 DC		JMP	ENTRY1
   140 			;
   141 			;   Routine to search for the first file with ambigueous name
   142 			; (DE).
   143 			;
   144 DCDF 0E 11	SRCHFST	MVI	C,17
   145 DCE1 C3 C3 DC		JMP	ENTRY1
   146 			;
   147 			;   Search for the next ambigeous file name.
   148 			;
   149 DCE4 0E 12	SRCHNXT	MVI	C,18
   150 DCE6 C3 C3 DC		JMP	ENTRY1
   151 			;
   152 			;   Search for file at (FCB).
   153 			;
   154 DCE9 11 CD E3	SRCHFCB	LXI	D,FCB
   155 DCEC C3 DF DC		JMP	SRCHFST
   156 			;
   157 			;   Routine to delete a file pointed to by (DE).
   158 			;
   159 DCEF 0E 13	DELETE	MVI	C,19
   160 DCF1 C3 05 00		JMP	ENTRY
   161 			;
   162 			;   Routine to call the bdos and set the zero flag if a zero
   163 			; status is returned.
   164 			;
   165 DCF4 CD 05 00	ENTRY2	CALL	ENTRY
   166 DCF7 B7			ORA	A	;set zero flag if appropriate.
   167 DCF8 C9			RET
   168 			;
   169 			;   Routine to read the next record from a sequential file.
   170 			; (DE) points to the FCB.
   171 			;
   172 DCF9 0E 14	RDREC	MVI	C,20
   173 DCFB C3 F4 DC		JMP	ENTRY2
   174 			;
   175 			;   Routine to read file at (FCB).
   176 			;
   177 DCFE 11 CD E3	READFCB	LXI	D,FCB
   178 DD01 C3 F9 DC		JMP	RDREC
   179 			;
   180 			;   Routine to write the next record of a sequential file.
   181 			; (DE) points to the FCB.
   182 			;
   183 DD04 0E 15	WRTREC	MVI	C,21
   184 DD06 C3 F4 DC		JMP	ENTRY2
   185 			;
   186 			;   Routine to create the file pointed to by (DE).
   187 			;
   188 DD09 0E 16	CREATE	MVI	C,22
   189 DD0B C3 C3 DC		JMP	ENTRY1
   190 			;
   191 			;   Routine to rename the file pointed to by (DE). Note that
   192 			; the new name starts at (DE+16).
   193 			;
   194 DD0E 0E 17	RENAM	MVI	C,23
   195 DD10 C3 05 00		JMP	ENTRY
   196 			;
   197 			;   Get the current user code.
   198 			;
   199 DD13 1E FF	GETUSR	MVI	E,0FFH
   200 			;
   201 			;   Routne to get or set the current user code.
   202 			; If (E) is FF then this is a GET, else it is a SET.
   203 			;
   204 DD15 0E 20	GETSETUC:MVI	C,32
   205 DD17 C3 05 00		JMP	ENTRY
   206 			;
   207 			;   Routine to set the current drive byte at (TDRIVE).
   208 			;
   209 DD1A CD 13 DD	SETCDRV	CALL	GETUSR	;get user number
   210 DD1D 87			ADD	A	;and shift into the upper 4 bits.
   211 DD1E 87			ADD	A
   212 DD1F 87			ADD	A
   213 DD20 87			ADD	A
   214 DD21 21 EF E3		LXI	H,CDRIVE;now add in the current drive number.
   215 DD24 B6			ORA	M
   216 DD25 32 04 00		STA	TDRIVE	;and save.
   217 DD28 C9			RET
   218 			;
   219 			;   Move currently active drive down to (TDRIVE).
   220 			;
   221 DD29 3A EF E3	MOVECD	LDA	CDRIVE
   222 DD2C 32 04 00		STA	TDRIVE
   223 DD2F C9			RET
   224 			;
   225 			;   Routine to convert (A) into upper case ascii. Only letters
   226 			; are affected.
   227 			;
   228 DD30 FE 61	UPPER	CPI	'a'	;check for letters in the range of 'a' to 'z'.
   229 DD32 D8			RC
   230 DD33 FE 7B		CPI	'{'
   231 DD35 D0			RNC
   232 DD36 E6 5F		ANI	5FH	;convert it if found.
   233 DD38 C9			RET
   234 			;
   235 			;   Routine to get a line of input. We must check to see if the
   236 			; user is in (BATCH) mode. If so, then read the input from file
   237 			; ($$$.SUB). At the end, reset to console input.
   238 			;
   239 DD39 3A AB E3	GETINP	LDA	BATCH	;if =0, then use console input.
   240 DD3C B7			ORA	A
   241 DD3D CA 96 DD		JZ	GETINP1
   242 			;
   243 			;   Use the submit file ($$$.sub) which is prepared by a
   244 			; SUBMIT run. It must be on drive (A) and it will be deleted
   245 			; if and error occures (like eof).
   246 			;
   247 DD40 3A EF E3		LDA	CDRIVE	;select drive 0 if need be.
   248 DD43 B7			ORA	A
   249 DD44 3E 00		MVI	A,0	;always use drive A for submit.
   250 DD46 C4 BD DC		CNZ	DSKSEL	;select it if required.
   251 DD49 11 AC E3		LXI	D,BATCHFCB
   252 DD4C CD CB DC		CALL	OPEN	;look for it.
   253 DD4F CA 96 DD		JZ	GETINP1	;if not there, use normal input.
   254 DD52 3A BB E3		LDA	BATCHFCB+15;get last record number+1.
   255 DD55 3D			DCR	A
   256 DD56 32 CC E3		STA	BATCHFCB+32
   257 DD59 11 AC E3		LXI	D,BATCHFCB
   258 DD5C CD F9 DC		CALL	RDREC	;read last record.
   259 DD5F C2 96 DD		JNZ	GETINP1	;quit on end of file.
   260 			;
   261 			;   Move this record into input buffer.
   262 			;
   263 DD62 11 07 DC		LXI	D,INBUFF+1
   264 DD65 21 80 00		LXI	H,TBUFF	;data was read into buffer here.
   265 DD68 06 80		MVI	B,128	;all 128 characters may be used.
   266 DD6A CD 42 E0		CALL	HL2DE	;(HL) to (DE), (B) bytes.
   267 DD6D 21 BA E3		LXI	H,BATCHFCB+14
   268 DD70 36 00		MVI	M,0	;zero out the 's2' byte.
   269 DD72 23			INX	H	;and decrement the record count.
   270 DD73 35			DCR	M
   271 DD74 11 AC E3		LXI	D,BATCHFCB;close the batch file now.
   272 DD77 CD DA DC		CALL	CLOSE
   273 DD7A CA 96 DD		JZ	GETINP1	;quit on an error.
   274 DD7D 3A EF E3		LDA	CDRIVE	;re-select previous drive if need be.
   275 DD80 B7			ORA	A
   276 DD81 C4 BD DC		CNZ	DSKSEL	;don't do needless selects.
   277 			;
   278 			;   Print line just read on console.
   279 			;
   280 DD84 21 08 DC		LXI	H,INBUFF+2
   281 DD87 CD AC DC		CALL	PLINE2
   282 DD8A CD C2 DD		CALL	CHKCON	;check console, quit on a key.
   283 DD8D CA A7 DD		JZ	GETINP2	;jump if no key is pressed.
   284 			;
   285 			;   Terminate the submit job on any keyboard input. Delete this
   286 			; file such that it is not re-started and jump to normal keyboard
   287 			; input section.
   288 			;
   289 DD90 CD DD DD		CALL	DELBATCH;delete the batch file.
   290 DD93 C3 82 DF		JMP	CMMND1	;and restart command input.
   291 			;
   292 			;   Get here for normal keyboard input. Delete the submit file
   293 			; incase there was one.
   294 			;
   295 DD96 CD DD DD	GETINP1	CALL	DELBATCH;delete file ($$$.sub).
   296 DD99 CD 1A DD		CALL	SETCDRV	;reset active disk.
   297 DD9C 0E 0A		MVI	C,10	;get line from console device.
   298 DD9E 11 06 DC		LXI	D,INBUFF
   299 DDA1 CD 05 00		CALL	ENTRY
   300 DDA4 CD 29 DD		CALL	MOVECD	;reset current drive (again).
   301 			;
   302 			;   Convert input line to upper case.
   303 			;
   304 DDA7 21 07 DC	GETINP2	LXI	H,INBUFF+1
   305 DDAA 46			MOV	B,M	;(B)=character counter.
   306 DDAB 23		GETINP3	INX	H
   307 DDAC 78			MOV	A,B	;end of the line?
   308 DDAD B7			ORA	A
   309 DDAE CA BA DD		JZ	GETINP4
   310 DDB1 7E			MOV	A,M	;convert to upper case.
   311 DDB2 CD 30 DD		CALL	UPPER
   312 DDB5 77			MOV	M,A
   313 DDB6 05			DCR	B	;adjust character count.
   314 DDB7 C3 AB DD		JMP	GETINP3
   315 DDBA 77		GETINP4	MOV	M,A	;add trailing null.
   316 DDBB 21 08 DC		LXI	H,INBUFF+2
   317 DDBE 22 88 DC		SHLD	INPOINT	;reset input line pointer.
   318 DDC1 C9			RET
   319 			;
   320 			;   Routine to check the console for a key pressed. The zero
   321 			; flag is set is none, else the character is returned in (A).
   322 			;
   323 DDC2 0E 0B	CHKCON	MVI	C,11	;check console.
   324 DDC4 CD 05 00		CALL	ENTRY
   325 DDC7 B7			ORA	A
   326 DDC8 C8			RZ		;return if nothing.
   327 DDC9 0E 01		MVI	C,1	;else get character.
   328 DDCB CD 05 00		CALL	ENTRY
   329 DDCE B7			ORA	A	;clear zero flag and return.
   330 DDCF C9			RET
   331 			;
   332 			;   Routine to get the currently active drive number.
   333 			;
   334 DDD0 0E 19	GETDSK	MVI	C,25
   335 DDD2 C3 05 00		JMP	ENTRY
   336 			;
   337 			;   Set the stabdard dma address.
   338 			;
   339 DDD5 11 80 00	STDDMA	LXI	D,TBUFF
   340 			;
   341 			;   Routine to set the dma address to (DE).
   342 			;
   343 DDD8 0E 1A	DMASET	MVI	C,26
   344 DDDA C3 05 00		JMP	ENTRY
   345 			;
   346 			;  Delete the batch file created by SUBMIT.
   347 			;
   348 DDDD 21 AB E3	DELBATCH:LXI	H,BATCH	;is batch active?
   349 DDE0 7E			MOV	A,M
   350 DDE1 B7			ORA	A
   351 DDE2 C8			RZ
   352 DDE3 36 00		MVI	M,0	;yes, de-activate it.
   353 DDE5 AF			XRA	A
   354 DDE6 CD BD DC		CALL	DSKSEL	;select drive 0 for sure.
   355 DDE9 11 AC E3		LXI	D,BATCHFCB;and delete this file.
   356 DDEC CD EF DC		CALL	DELETE
   357 DDEF 3A EF E3		LDA	CDRIVE	;reset current drive.
   358 DDF2 C3 BD DC		JMP	DSKSEL
   359 			;
   360 			;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
   361 			; the same or we halt....
   362 			;
   363 DDF5 11 28 DF	VERIFY	LXI	D,PATTRN1;these are the serial number bytes.
   364 DDF8 21 00 E4		LXI	H,PATTRN2;ditto, but how could they be different?
   365 DDFB 06 06		MVI	B,6	;6 bytes each.
   366 DDFD 1A		VERIFY1	LDAX	D
   367 DDFE BE			CMP	M
   368 DDFF C2 CF DF		JNZ	HALT	;jump to halt routine.
   369 DE02 13			INX	D
   370 DE03 23			INX	H
   371 DE04 05			DCR	B
   372 DE05 C2 FD DD		JNZ	VERIFY1
   373 DE08 C9			RET
   374 			;
   375 			;   Print back file name with a '?' to indicate a syntax error.
   376 			;
   377 DE09 CD 98 DC	SYNERR	CALL	CRLF	;end current line.
   378 DE0C 2A 8A DC		LHLD	NAMEPNT	;this points to name in error.
   379 DE0F 7E		SYNERR1	MOV	A,M	;print it until a space or null is found.
   380 DE10 FE 20		CPI	' '
   381 DE12 CA 22 DE		JZ	SYNERR2
   382 DE15 B7			ORA	A
   383 DE16 CA 22 DE		JZ	SYNERR2
   384 DE19 E5			PUSH	H
   385 DE1A CD 8C DC		CALL	PRINT
   386 DE1D E1			POP	H
   387 DE1E 23			INX	H
   388 DE1F C3 0F DE		JMP	SYNERR1
   389 DE22 3E 3F	SYNERR2	MVI	A,'?'	;add trailing '?'.
   390 DE24 CD 8C DC		CALL	PRINT
   391 DE27 CD 98 DC		CALL	CRLF
   392 DE2A CD DD DD		CALL	DELBATCH;delete any batch file.
   393 DE2D C3 82 DF		JMP	CMMND1	;and restart from console input.
   394 			;
   395 			;   Check character at (DE) for legal command input. Note that the
   396 			; zero flag is set if the character is a delimiter.
   397 			;
   398 DE30 1A		CHECK	LDAX	D
   399 DE31 B7			ORA	A
   400 DE32 C8			RZ
   401 DE33 FE 20		CPI	' '	;control characters are not legal here.
   402 DE35 DA 09 DE		JC	SYNERR
   403 DE38 C8			RZ		;check for valid delimiter.
   404 DE39 FE 3D		CPI	'='
   405 DE3B C8			RZ
   406 DE3C FE 5F		CPI	'_'
   407 DE3E C8			RZ
   408 DE3F FE 2E		CPI	'.'
   409 DE41 C8			RZ
   410 DE42 FE 3A		CPI	':'
   411 DE44 C8			RZ
   412 DE45 FE 3B		CPI	03bh;';'
   413 DE47 C8			RZ
   414 DE48 FE 3C		CPI	'<'
   415 DE4A C8			RZ
   416 DE4B FE 3E		CPI	'>'
   417 DE4D C8			RZ
   418 DE4E C9			RET
   419 			;
   420 			;   Get the next non-blank character from (DE).
   421 			;
   422 DE4F 1A		NONBLANK:LDAX	D
   423 DE50 B7			ORA	A	;string ends with a null.
   424 DE51 C8			RZ
   425 DE52 FE 20		CPI	' '
   426 DE54 C0			RNZ
   427 DE55 13			INX	D
   428 DE56 C3 4F DE		JMP	NONBLANK
   429 			;
   430 			;   Add (HL)=(HL)+(A)
   431 			;
   432 DE59 85		ADDHL	ADD	L
   433 DE5A 6F			MOV	L,A
   434 DE5B D0			RNC	;take care of any carry.
   435 DE5C 24			INR	H
   436 DE5D C9			RET
   437 			;
   438 			;   Convert the first name in (FCB).
   439 			;
   440 DE5E 3E 00	CONVFST	MVI	A,0
   441 			;
   442 			;   Format a file name (convert * to '?', etc.). On return,
   443 			; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
   444 			; the position within the fcb for the name (either 0 or 16).
   445 			;
   446 DE60 21 CD E3	CONVERT	LXI	H,FCB
   447 DE63 CD 59 DE		CALL	ADDHL
   448 DE66 E5			PUSH	H
   449 DE67 E5			PUSH	H
   450 DE68 AF			XRA	A
   451 DE69 32 F0 E3		STA	CHGDRV	;initialize drive change flag.
   452 DE6C 2A 88 DC		LHLD	INPOINT	;set (HL) as pointer into input line.
   453 DE6F EB			XCHG
   454 DE70 CD 4F DE		CALL	NONBLANK;get next non-blank character.
   455 DE73 EB			XCHG
   456 DE74 22 8A DC		SHLD	NAMEPNT	;save pointer here for any error message.
   457 DE77 EB			XCHG
   458 DE78 E1			POP	H
   459 DE79 1A			LDAX	D	;get first character.
   460 DE7A B7			ORA	A
   461 DE7B CA 89 DE		JZ	CONVRT1
   462 DE7E DE 40		SBI	'A'-1	;might be a drive name, convert to binary.
   463 DE80 47			MOV	B,A	;and save.
   464 DE81 13			INX	D	;check next character for a ':'.
   465 DE82 1A			LDAX	D
   466 DE83 FE 3A		CPI	':'
   467 DE85 CA 90 DE		JZ	CONVRT2
   468 DE88 1B			DCX	D	;nope, move pointer back to the start of the line.
   469 DE89 3A EF E3	CONVRT1	LDA	CDRIVE
   470 DE8C 77			MOV	M,A
   471 DE8D C3 96 DE		JMP	CONVRT3
   472 DE90 78		CONVRT2	MOV	A,B
   473 DE91 32 F0 E3		STA	CHGDRV	;set change in drives flag.
   474 DE94 70			MOV	M,B
   475 DE95 13			INX	D
   476 			;
   477 			;   Convert the basic file name.
   478 			;
   479 DE96 06 08	CONVRT3	MVI	B,08H
   480 DE98 CD 30 DE	CONVRT4	CALL	CHECK
   481 DE9B CA B9 DE		JZ	CONVRT8
   482 DE9E 23			INX	H
   483 DE9F FE 2A		CPI	'*'	;note that an '*' will fill the remaining
   484 DEA1 C2 A9 DE		JNZ	CONVRT5	;field with '?'.
   485 DEA4 36 3F		MVI	M,'?'
   486 DEA6 C3 AB DE		JMP	CONVRT6
   487 DEA9 77		CONVRT5	MOV	M,A
   488 DEAA 13			INX	D
   489 DEAB 05		CONVRT6	DCR	B
   490 DEAC C2 98 DE		JNZ	CONVRT4
   491 DEAF CD 30 DE	CONVRT7	CALL	CHECK	;get next delimiter.
   492 DEB2 CA C0 DE		JZ	GETEXT
   493 DEB5 13			INX	D
   494 DEB6 C3 AF DE		JMP	CONVRT7
   495 DEB9 23		CONVRT8	INX	H	;blank fill the file name.
   496 DEBA 36 20		MVI	M,' '
   497 DEBC 05			DCR	B
   498 DEBD C2 B9 DE		JNZ	CONVRT8
   499 			;
   500 			;   Get the extension and convert it.
   501 			;
   502 DEC0 06 03	GETEXT	MVI	B,03H
   503 DEC2 FE 2E		CPI	'.'
   504 DEC4 C2 E9 DE		JNZ	GETEXT5
   505 DEC7 13			INX	D
   506 DEC8 CD 30 DE	GETEXT1	CALL	CHECK
   507 DECB CA E9 DE		JZ	GETEXT5
   508 DECE 23			INX	H
   509 DECF FE 2A		CPI	'*'
   510 DED1 C2 D9 DE		JNZ	GETEXT2
   511 DED4 36 3F		MVI	M,'?'
   512 DED6 C3 DB DE		JMP	GETEXT3
   513 DED9 77		GETEXT2	MOV	M,A
   514 DEDA 13			INX	D
   515 DEDB 05		GETEXT3	DCR	B
   516 DEDC C2 C8 DE		JNZ	GETEXT1
   517 DEDF CD 30 DE	GETEXT4	CALL	CHECK
   518 DEE2 CA F0 DE		JZ	GETEXT6
   519 DEE5 13			INX	D
   520 DEE6 C3 DF DE		JMP	GETEXT4
   521 DEE9 23		GETEXT5	INX	H
   522 DEEA 36 20		MVI	M,' '
   523 DEEC 05			DCR	B
   524 DEED C2 E9 DE		JNZ	GETEXT5
   525 DEF0 06 03	GETEXT6	MVI	B,3
   526 DEF2 23		GETEXT7	INX	H
   527 DEF3 36 00		MVI	M,0
   528 DEF5 05			DCR	B
   529 DEF6 C2 F2 DE		JNZ	GETEXT7
   530 DEF9 EB			XCHG
   531 DEFA 22 88 DC		SHLD	INPOINT	;save input line pointer.
   532 DEFD E1			POP	H
   533 			;
   534 			;   Check to see if this is an ambigeous file name specification.
   535 			; Set the (A) register to non zero if it is.
   536 			;
   537 DEFE 01 0B 00		LXI	B,11	;set name length.
   538 DF01 23		GETEXT8	INX	H
   539 DF02 7E			MOV	A,M
   540 DF03 FE 3F		CPI	'?'	;any question marks?
   541 DF05 C2 09 DF		JNZ	GETEXT9
   542 DF08 04			INR	B	;count them.
   543 DF09 0D		GETEXT9	DCR	C
   544 DF0A C2 01 DF		JNZ	GETEXT8
   545 DF0D 78			MOV	A,B
   546 DF0E B7			ORA	A
   547 DF0F C9			RET
   548 			;
   549 			;   CP/M command table. Note commands can be either 3 or 4 characters long.
   550 			;
   551      00 06	NUMCMDS	EQU	6	;number of commands
   552 DF10		CMDTBL	DB	'DIR '
            44 49 52 20 
            
   553 DF14			DB	'ERA '
            45 52 41 20 
            
   554 DF18			DB	'TYPE'
            54 59 50 45 
            
   555 DF1C			DB	'SAVE'
            53 41 56 45 
            
   556 DF20			DB	'REN '
            52 45 4E 20 
            
   557 DF24			DB	'USER'
            55 53 45 52 
            
   558 			;
   559 			;   The following six bytes must agree with those at (PATTRN2)
   560 			; or cp/m will HALT. Why?
   561 			;
   562 DF28		PATTRN1	DB	0,22,0,0,0,0;(* serial number bytes *).
            00 16 00 00 
            00 00 
   563 			;
   564 			;   Search the command table for a match with what has just
   565 			; been entered. If a match is found, then we jump to the
   566 			; proper section. Else jump to (UNKNOWN).
   567 			; On return, the (C) register is set to the command number
   568 			; that matched (or NUMCMDS+1 if no match).
   569 			;
   570 DF2E 21 10 DF	SEARCH	LXI	H,CMDTBL
   571 DF31 0E 00		MVI	C,0
   572 DF33 79		SEARCH1	MOV	A,C
   573 DF34 FE 06		CPI	NUMCMDS	;this commands exists.
   574 DF36 D0			RNC
   575 DF37 11 CE E3		LXI	D,FCB+1	;check this one.
   576 DF3A 06 04		MVI	B,4	;max command length.
   577 DF3C 1A		SEARCH2	LDAX	D
   578 DF3D BE			CMP	M
   579 DF3E C2 4F DF		JNZ	SEARCH3	;not a match.
   580 DF41 13			INX	D
   581 DF42 23			INX	H
   582 DF43 05			DCR	B
   583 DF44 C2 3C DF		JNZ	SEARCH2
   584 DF47 1A			LDAX	D	;allow a 3 character command to match.
   585 DF48 FE 20		CPI	' '
   586 DF4A C2 54 DF		JNZ	SEARCH4
   587 DF4D 79			MOV	A,C	;set return register for this command.
   588 DF4E C9			RET
   589 DF4F 23		SEARCH3	INX	H
   590 DF50 05			DCR	B
   591 DF51 C2 4F DF		JNZ	SEARCH3
   592 DF54 0C		SEARCH4	INR	C
   593 DF55 C3 33 DF		JMP	SEARCH1
   594 			;
   595 			;   Set the input buffer to empty and then start the command
   596 			; processor (ccp).
   597 			;
   598 DF58 AF		CLEARBUF:XRA	A
   599 DF59 32 07 DC		STA	INBUFF+1;second byte is actual length.
   600 			;
   601 			;**************************************************************
   602 			;*
   603 			;*
   604 			;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
   605 			;*
   606 			;**************************************************************
   607 			;*
   608 DF5C 31 AB E3	COMMAND	LXI	SP,CCPSTACK;setup stack area.
   609 DF5F C5			PUSH	B	;note that (C) should be equal to:
   610 DF60 79			MOV	A,C	;(uuuudddd) where 'uuuu' is the user number
   611 DF61 1F			RAR		;and 'dddd' is the drive number.
   612 DF62 1F			RAR
   613 DF63 1F			RAR
   614 DF64 1F			RAR
   615 DF65 E6 0F		ANI	0FH	;isolate the user number.
   616 DF67 5F			MOV	E,A
   617 DF68 CD 15 DD		CALL	GETSETUC;and set it.
   618 DF6B CD B8 DC		CALL	RESDSK	;reset the disk system.
   619 DF6E 32 AB E3		STA	BATCH	;clear batch mode flag.
   620 DF71 C1			POP	B
   621 DF72 79			MOV	A,C
   622 DF73 E6 0F		ANI	0FH	;isolate the drive number.
   623 DF75 32 EF E3		STA	CDRIVE	;and save.
   624 DF78 CD BD DC		CALL	DSKSEL	;...and select.
   625 DF7B 3A 07 DC		LDA	INBUFF+1
   626 DF7E B7			ORA	A	;anything in input buffer already?
   627 DF7F C2 98 DF		JNZ	CMMND2	;yes, we just process it.
   628 			;
   629 			;   Entry point to get a command line from the console.
   630 			;
   631 DF82 31 AB E3	CMMND1	LXI	SP,CCPSTACK;set stack straight.
   632 DF85 CD 98 DC		CALL	CRLF	;start a new line on the screen.
   633 DF88 CD D0 DD		CALL	GETDSK	;get current drive.
   634 DF8B C6 61		ADI	'a'
   635 DF8D CD 8C DC		CALL	PRINT	;print current drive.
   636 DF90 3E 3E		MVI	A,'>'
   637 DF92 CD 8C DC		CALL	PRINT	;and add prompt.
   638 DF95 CD 39 DD		CALL	GETINP	;get line from user.
   639 			;
   640 			;   Process command line here.
   641 			;
   642 DF98 11 80 00	CMMND2	LXI	D,TBUFF
   643 DF9B CD D8 DD		CALL	DMASET	;set standard dma address.
   644 DF9E CD D0 DD		CALL	GETDSK
   645 DFA1 32 EF E3		STA	CDRIVE	;set current drive.
   646 DFA4 CD 5E DE		CALL	CONVFST	;convert name typed in.
   647 DFA7 C4 09 DE		CNZ	SYNERR	;wild cards are not allowed.
   648 DFAA 3A F0 E3		LDA	CHGDRV	;if a change in drives was indicated,
   649 DFAD B7			ORA	A	;then treat this as an unknown command
   650 DFAE C2 A5 E2		JNZ	UNKNOWN	;which gets executed.
   651 DFB1 CD 2E DF		CALL	SEARCH	;else search command table for a match.
   652 			;
   653 			;   Note that an unknown command returns
   654 			; with (A) pointing to the last address
   655 			; in our table which is (UNKNOWN).
   656 			;
   657 DFB4 21 C1 DF		LXI	H,CMDADR;now, look thru our address table for command (A).
   658 DFB7 5F			MOV	E,A	;set (DE) to command number.
   659 DFB8 16 00		MVI	D,0
   660 DFBA 19			DAD	D
   661 DFBB 19			DAD	D	;(HL)=(CMDADR)+2*(command number).
   662 DFBC 7E			MOV	A,M	;now pick out this address.
   663 DFBD 23			INX	H
   664 DFBE 66			MOV	H,M
   665 DFBF 6F			MOV	L,A
   666 DFC0 E9			PCHL		;now execute it.
   667 			;
   668 			;   CP/M command address table.
   669 			;
   670 DFC1		CMDADR	DW	DIRECT,ERASE,TYPE,SAVE
            77E0 1FE1 5DE1 
            ADE1 
   671 DFC9			DW	RENAME,USER,UNKNOWN
            10E2 8EE2 A5E2 
            
   672 			;
   673 			;   Halt the system. Reason for this is unknown at present.
   674 			;
   675 DFCF 21 F3 76	HALT	LXI	H,76F3H	;'DI HLT' instructions.
   676 DFD2 22 00 DC		SHLD	CBASE
   677 DFD5 21 00 DC		LXI	H,CBASE
   678 DFD8 E9			PCHL
   679 			;
   680 			;   Read error while TYPEing a file.
   681 			;
   682 DFD9 01 DF DF	RDERROR	LXI	B,RDERR
   683 DFDC C3 A7 DC		JMP	PLINE
   684 DFDF		RDERR	DB	'Read error',0
            52 65 61 64 
            20 65 72 72 
            6F 72 00 
   685 			;
   686 			;   Required file was not located.
   687 			;
   688 DFEA 01 F0 DF	NONE	LXI	B,NOFILE
   689 DFED C3 A7 DC		JMP	PLINE
   690 DFF0		NOFILE	DB	'No file',0
            4E 6F 20 66 
            69 6C 65 00 
            
   691 			;
   692 			;   Decode a command of the form 'A>filename number{ filename}.
   693 			; Note that a drive specifier is not allowed on the first file
   694 			; name. On return, the number is in register (A). Any error
   695 			; causes 'filename?' to be printed and the command is aborted.
   696 			;
   697 DFF8 CD 5E DE	DECODE	CALL	CONVFST	;convert filename.
   698 DFFB 3A F0 E3		LDA	CHGDRV	;do not allow a drive to be specified.
   699 DFFE B7			ORA	A
   700 DFFF C2 09 DE		JNZ	SYNERR
   701 E002 21 CE E3		LXI	H,FCB+1	;convert number now.
   702 E005 01 0B 00		LXI	B,11	;(B)=sum register, (C)=max digit count.
   703 E008 7E		DECODE1	MOV	A,M
   704 E009 FE 20		CPI	' '	;a space terminates the numeral.
   705 E00B CA 33 E0		JZ	DECODE3
   706 E00E 23			INX	H
   707 E00F D6 30		SUI	'0'	;make binary from ascii.
   708 E011 FE 0A		CPI	10	;legal digit?
   709 E013 D2 09 DE		JNC	SYNERR
   710 E016 57			MOV	D,A	;yes, save it in (D).
   711 E017 78			MOV	A,B	;compute (B)=(B)*10 and check for overflow.
   712 E018 E6 E0		ANI	0E0H
   713 E01A C2 09 DE		JNZ	SYNERR
   714 E01D 78			MOV	A,B
   715 E01E 07			RLC
   716 E01F 07			RLC
   717 E020 07			RLC	;(A)=(B)*8
   718 E021 80			ADD	B	;.......*9
   719 E022 DA 09 DE		JC	SYNERR
   720 E025 80			ADD	B	;.......*10
   721 E026 DA 09 DE		JC	SYNERR
   722 E029 82			ADD	D	;add in new digit now.
   723 E02A DA 09 DE	DECODE2	JC	SYNERR
   724 E02D 47			MOV	B,A	;and save result.
   725 E02E 0D			DCR	C	;only look at 11 digits.
   726 E02F C2 08 E0		JNZ	DECODE1
   727 E032 C9			RET
   728 E033 7E		DECODE3	MOV	A,M	;spaces must follow (why?).
   729 E034 FE 20		CPI	' '
   730 E036 C2 09 DE		JNZ	SYNERR
   731 E039 23			INX	H
   732 E03A 0D		DECODE4	DCR	C
   733 E03B C2 33 E0		JNZ	DECODE3
   734 E03E 78			MOV	A,B	;set (A)=the numeric value entered.
   735 E03F C9			RET
   736 			;
   737 			;   Move 3 bytes from (HL) to (DE). Note that there is only
   738 			; one reference to this at (A2D5h).
   739 			;
   740 E040 06 03	MOVE3	MVI	B,3
   741 			;
   742 			;   Move (B) bytes from (HL) to (DE).
   743 			;
   744 E042 7E		HL2DE	MOV	A,M
   745 E043 12			STAX	D
   746 E044 23			INX	H
   747 E045 13			INX	D
   748 E046 05			DCR	B
   749 E047 C2 42 E0		JNZ	HL2DE
   750 E04A C9			RET
   751 			;
   752 			;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
   753 			;
   754 E04B 21 80 00	EXTRACT	LXI	H,TBUFF
   755 E04E 81			ADD	C
   756 E04F CD 59 DE		CALL	ADDHL
   757 E052 7E			MOV	A,M
   758 E053 C9			RET
   759 			;
   760 			;  Check drive specified. If it means a change, then the new
   761 			; drive will be selected. In any case, the drive byte of the
   762 			; fcb will be set to null (means use current drive).
   763 			;
   764 E054 AF		DSELECT	XRA	A	;null out first byte of fcb.
   765 E055 32 CD E3		STA	FCB
   766 E058 3A F0 E3		LDA	CHGDRV	;a drive change indicated?
   767 E05B B7			ORA	A
   768 E05C C8			RZ
   769 E05D 3D			DCR	A	;yes, is it the same as the current drive?
   770 E05E 21 EF E3		LXI	H,CDRIVE
   771 E061 BE			CMP	M
   772 E062 C8			RZ
   773 E063 C3 BD DC		JMP	DSKSEL	;no. Select it then.
   774 			;
   775 			;   Check the drive selection and reset it to the previous
   776 			; drive if it was changed for the preceeding command.
   777 			;
   778 E066 3A F0 E3	RESETDR	LDA	CHGDRV	;drive change indicated?
   779 E069 B7			ORA	A
   780 E06A C8			RZ
   781 E06B 3D			DCR	A	;yes, was it a different drive?
   782 E06C 21 EF E3		LXI	H,CDRIVE
   783 E06F BE			CMP	M
   784 E070 C8			RZ
   785 E071 3A EF E3		LDA	CDRIVE	;yes, re-select our old drive.
   786 E074 C3 BD DC		JMP	DSKSEL
   787 			;
   788 			;**************************************************************
   789 			;*
   790 			;*           D I R E C T O R Y   C O M M A N D
   791 			;*
   792 			;**************************************************************
   793 			;
   794 E077 CD 5E DE	DIRECT	CALL	CONVFST	;convert file name.
   795 E07A CD 54 E0		CALL	DSELECT	;select indicated drive.
   796 E07D 21 CE E3		LXI	H,FCB+1	;was any file indicated?
   797 E080 7E			MOV	A,M
   798 E081 FE 20		CPI	' '
   799 E083 C2 8F E0		JNZ	DIRECT2
   800 E086 06 0B		MVI	B,11	;no. Fill field with '?' - same as *.*.
   801 E088 36 3F	DIRECT1	MVI	M,'?'
   802 E08A 23			INX	H
   803 E08B 05			DCR	B
   804 E08C C2 88 E0		JNZ	DIRECT1
   805 E08F 1E 00	DIRECT2	MVI	E,0	;set initial cursor position.
   806 E091 D5			PUSH	D
   807 E092 CD E9 DC		CALL	SRCHFCB	;get first file name.
   808 E095 CC EA DF		CZ	NONE	;none found at all?
   809 E098 CA 1B E1	DIRECT3	JZ	DIRECT9	;terminate if no more names.
   810 E09B 3A EE E3		LDA	RTNCODE	;get file's position in segment (0-3).
   811 E09E 0F			RRC
   812 E09F 0F			RRC
   813 E0A0 0F			RRC
   814 E0A1 E6 60		ANI	60H	;(A)=position*32
   815 E0A3 4F			MOV	C,A
   816 E0A4 3E 0A		MVI	A,10
   817 E0A6 CD 4B E0		CALL	EXTRACT	;extract the tenth entry in fcb.
   818 E0A9 17			RAL		;check system file status bit.
   819 E0AA DA 0F E1		JC	DIRECT8	;we don't list them.
   820 E0AD D1			POP	D
   821 E0AE 7B			MOV	A,E	;bump name count.
   822 E0AF 1C			INR	E
   823 E0B0 D5			PUSH	D
   824 E0B1 E6 03		ANI	03H	;at end of line?
   825 E0B3 F5			PUSH	PSW
   826 E0B4 C2 CC E0		JNZ	DIRECT4
   827 E0B7 CD 98 DC		CALL	CRLF	;yes, end this line and start another.
   828 E0BA C5			PUSH	B
   829 E0BB CD D0 DD		CALL	GETDSK	;start line with ('A:').
   830 E0BE C1			POP	B
   831 E0BF C6 41		ADI	'A'
   832 E0C1 CD 92 DC		CALL	PRINTB
   833 E0C4 3E 3A		MVI	A,':'
   834 E0C6 CD 92 DC		CALL	PRINTB
   835 E0C9 C3 D4 E0		JMP	DIRECT5
   836 E0CC CD A2 DC	DIRECT4	CALL	SPACE	;add seperator between file names.
   837 E0CF 3E 3A		MVI	A,':'
   838 E0D1 CD 92 DC		CALL	PRINTB
   839 E0D4 CD A2 DC	DIRECT5	CALL	SPACE
   840 E0D7 06 01		MVI	B,1	;'extract' each file name character at a time.
   841 E0D9 78		DIRECT6	MOV	A,B
   842 E0DA CD 4B E0		CALL	EXTRACT
   843 E0DD E6 7F		ANI	7FH	;strip bit 7 (status bit).
   844 E0DF FE 20		CPI	' '	;are we at the end of the name?
   845 E0E1 C2 F9 E0		JNZ	DRECT65
   846 E0E4 F1			POP	PSW	;yes, don't print spaces at the end of a line.
   847 E0E5 F5			PUSH	PSW
   848 E0E6 FE 03		CPI	3
   849 E0E8 C2 F7 E0		JNZ	DRECT63
   850 E0EB 3E 09		MVI	A,9	;first check for no extension.
   851 E0ED CD 4B E0		CALL	EXTRACT
   852 E0F0 E6 7F		ANI	7FH
   853 E0F2 FE 20		CPI	' '
   854 E0F4 CA 0E E1		JZ	DIRECT7	;don't print spaces.
   855 E0F7 3E 20	DRECT63	MVI	A,' '	;else print them.
   856 E0F9 CD 92 DC	DRECT65	CALL	PRINTB
   857 E0FC 04			INR	B	;bump to next character psoition.
   858 E0FD 78			MOV	A,B
   859 E0FE FE 0C		CPI	12	;end of the name?
   860 E100 D2 0E E1		JNC	DIRECT7
   861 E103 FE 09		CPI	9	;nope, starting extension?
   862 E105 C2 D9 E0		JNZ	DIRECT6
   863 E108 CD A2 DC		CALL	SPACE	;yes, add seperating space.
   864 E10B C3 D9 E0		JMP	DIRECT6
   865 E10E F1		DIRECT7	POP	PSW	;get the next file name.
   866 E10F CD C2 DD	DIRECT8	CALL	CHKCON	;first check console, quit on anything.
   867 E112 C2 1B E1		JNZ	DIRECT9
   868 E115 CD E4 DC		CALL	SRCHNXT	;get next name.
   869 E118 C3 98 E0		JMP	DIRECT3	;and continue with our list.
   870 E11B D1		DIRECT9	POP	D	;restore the stack and return to command level.
   871 E11C C3 86 E3		JMP	GETBACK
   872 			;
   873 			;**************************************************************
   874 			;*
   875 			;*                E R A S E   C O M M A N D
   876 			;*
   877 			;**************************************************************
   878 			;
   879 E11F CD 5E DE	ERASE	CALL	CONVFST	;convert file name.
   880 E122 FE 0B		CPI	11	;was '*.*' entered?
   881 E124 C2 42 E1		JNZ	ERASE1
   882 E127 01 52 E1		LXI	B,YESNO	;yes, ask for confirmation.
   883 E12A CD A7 DC		CALL	PLINE
   884 E12D CD 39 DD		CALL	GETINP
   885 E130 21 07 DC		LXI	H,INBUFF+1
   886 E133 35			DCR	M	;must be exactly 'y'.
   887 E134 C2 82 DF		JNZ	CMMND1
   888 E137 23			INX	H
   889 E138 7E			MOV	A,M
   890 E139 FE 59		CPI	'Y'
   891 E13B C2 82 DF		JNZ	CMMND1
   892 E13E 23			INX	H
   893 E13F 22 88 DC		SHLD	INPOINT	;save input line pointer.
   894 E142 CD 54 E0	ERASE1	CALL	DSELECT	;select desired disk.
   895 E145 11 CD E3		LXI	D,FCB
   896 E148 CD EF DC		CALL	DELETE	;delete the file.
   897 E14B 3C			INR	A
   898 E14C CC EA DF		CZ	NONE	;not there?
   899 E14F C3 86 E3		JMP	GETBACK	;return to command level now.
   900 E152		YESNO	DB	'All (y/n)?',0
            41 6C 6C 20 
            28 79 2F 6E 
            29 3F 00 
   901 			;
   902 			;**************************************************************
   903 			;*
   904 			;*            T Y P E   C O M M A N D
   905 			;*
   906 			;**************************************************************
   907 			;
   908 E15D CD 5E DE	TYPE	CALL	CONVFST	;convert file name.
   909 E160 C2 09 DE		JNZ	SYNERR	;wild cards not allowed.
   910 E163 CD 54 E0		CALL	DSELECT	;select indicated drive.
   911 E166 CD D0 DC		CALL	OPENFCB	;open the file.
   912 E169 CA A7 E1		JZ	TYPE5	;not there?
   913 E16C CD 98 DC		CALL	CRLF	;ok, start a new line on the screen.
   914 E16F 21 F1 E3		LXI	H,NBYTES;initialize byte counter.
   915 E172 36 FF		MVI	M,0FFH	;set to read first sector.
   916 E174 21 F1 E3	TYPE1	LXI	H,NBYTES
   917 E177 7E		TYPE2	MOV	A,M	;have we written the entire sector?
   918 E178 FE 80		CPI	128
   919 E17A DA 87 E1		JC	TYPE3
   920 E17D E5			PUSH	H	;yes, read in the next one.
   921 E17E CD FE DC		CALL	READFCB
   922 E181 E1			POP	H
   923 E182 C2 A0 E1		JNZ	TYPE4	;end or error?
   924 E185 AF			XRA	A	;ok, clear byte counter.
   925 E186 77			MOV	M,A
   926 E187 34		TYPE3	INR	M	;count this byte.
   927 E188 21 80 00		LXI	H,TBUFF	;and get the (A)th one from the buffer (TBUFF).
   928 E18B CD 59 DE		CALL	ADDHL
   929 E18E 7E			MOV	A,M
   930 E18F FE 1A		CPI	CNTRLZ	;end of file mark?
   931 E191 CA 86 E3		JZ	GETBACK
   932 E194 CD 8C DC		CALL	PRINT	;no, print it.
   933 E197 CD C2 DD		CALL	CHKCON	;check console, quit if anything ready.
   934 E19A C2 86 E3		JNZ	GETBACK
   935 E19D C3 74 E1		JMP	TYPE1
   936 			;
   937 			;   Get here on an end of file or read error.
   938 			;
   939 E1A0 3D		TYPE4	DCR	A	;read error?
   940 E1A1 CA 86 E3		JZ	GETBACK
   941 E1A4 CD D9 DF		CALL	RDERROR	;yes, print message.
   942 E1A7 CD 66 E0	TYPE5	CALL	RESETDR	;and reset proper drive
   943 E1AA C3 09 DE		JMP	SYNERR	;now print file name with problem.
   944 			;
   945 			;**************************************************************
   946 			;*
   947 			;*            S A V E   C O M M A N D
   948 			;*
   949 			;**************************************************************
   950 			;
   951 E1AD CD F8 DF	SAVE	CALL	DECODE	;get numeric number that follows SAVE.
   952 E1B0 F5			PUSH	PSW	;save number of pages to write.
   953 E1B1 CD 5E DE		CALL	CONVFST	;convert file name.
   954 E1B4 C2 09 DE		JNZ	SYNERR	;wild cards not allowed.
   955 E1B7 CD 54 E0		CALL	DSELECT	;select specified drive.
   956 E1BA 11 CD E3		LXI	D,FCB	;now delete this file.
   957 E1BD D5			PUSH	D
   958 E1BE CD EF DC		CALL	DELETE
   959 E1C1 D1			POP	D
   960 E1C2 CD 09 DD		CALL	CREATE	;and create it again.
   961 E1C5 CA FB E1		JZ	SAVE3	;can't create?
   962 E1C8 AF			XRA	A	;clear record number byte.
   963 E1C9 32 ED E3		STA	FCB+32
   964 E1CC F1			POP	PSW	;convert pages to sectors.
   965 E1CD 6F			MOV	L,A
   966 E1CE 26 00		MVI	H,0
   967 E1D0 29			DAD	H	;(HL)=number of sectors to write.
   968 E1D1 11 00 01		LXI	D,TBASE	;and we start from here.
   969 E1D4 7C		SAVE1	MOV	A,H	;done yet?
   970 E1D5 B5			ORA	L
   971 E1D6 CA F1 E1		JZ	SAVE2
   972 E1D9 2B			DCX	H	;nope, count this and compute the start
   973 E1DA E5			PUSH	H	;of the next 128 byte sector.
   974 E1DB 21 80 00		LXI	H,128
   975 E1DE 19			DAD	D
   976 E1DF E5			PUSH	H	;save it and set the transfer address.
   977 E1E0 CD D8 DD		CALL	DMASET
   978 E1E3 11 CD E3		LXI	D,FCB	;write out this sector now.
   979 E1E6 CD 04 DD		CALL	WRTREC
   980 E1E9 D1			POP	D	;reset (DE) to the start of the last sector.
   981 E1EA E1			POP	H	;restore sector count.
   982 E1EB C2 FB E1		JNZ	SAVE3	;write error?
   983 E1EE C3 D4 E1		JMP	SAVE1
   984 			;
   985 			;   Get here after writing all of the file.
   986 			;
   987 E1F1 11 CD E3	SAVE2	LXI	D,FCB	;now close the file.
   988 E1F4 CD DA DC		CALL	CLOSE
   989 E1F7 3C			INR	A	;did it close ok?
   990 E1F8 C2 01 E2		JNZ	SAVE4
   991 			;
   992 			;   Print out error message (no space).
   993 			;
   994 E1FB 01 07 E2	SAVE3	LXI	B,NOSPACE
   995 E1FE CD A7 DC		CALL	PLINE
   996 E201 CD D5 DD	SAVE4	CALL	STDDMA	;reset the standard dma address.
   997 E204 C3 86 E3		JMP	GETBACK
   998 E207		NOSPACE	DB	'No space',0
            4E 6F 20 73 
            70 61 63 65 
            00 
   999 			;
  1000 			;**************************************************************
  1001 			;*
  1002 			;*           R E N A M E   C O M M A N D
  1003 			;*
  1004 			;**************************************************************
  1005 			;
  1006 E210 CD 5E DE	RENAME	CALL	CONVFST	;convert first file name.
  1007 E213 C2 09 DE		JNZ	SYNERR	;wild cards not allowed.
  1008 E216 3A F0 E3		LDA	CHGDRV	;remember any change in drives specified.
  1009 E219 F5			PUSH	PSW
  1010 E21A CD 54 E0		CALL	DSELECT	;and select this drive.
  1011 E21D CD E9 DC		CALL	SRCHFCB	;is this file present?
  1012 E220 C2 79 E2		JNZ	RENAME6	;yes, print error message.
  1013 E223 21 CD E3		LXI	H,FCB	;yes, move this name into second slot.
  1014 E226 11 DD E3		LXI	D,FCB+16
  1015 E229 06 10		MVI	B,16
  1016 E22B CD 42 E0		CALL	HL2DE
  1017 E22E 2A 88 DC		LHLD	INPOINT	;get input pointer.
  1018 E231 EB			XCHG
  1019 E232 CD 4F DE		CALL	NONBLANK;get next non blank character.
  1020 E235 FE 3D		CPI	'='	;only allow an '=' or '_' seperator.
  1021 E237 CA 3F E2		JZ	RENAME1
  1022 E23A FE 5F		CPI	'_'
  1023 E23C C2 73 E2		JNZ	RENAME5
  1024 E23F EB		RENAME1	XCHG
  1025 E240 23			INX	H	;ok, skip seperator.
  1026 E241 22 88 DC		SHLD	INPOINT	;save input line pointer.
  1027 E244 CD 5E DE		CALL	CONVFST	;convert this second file name now.
  1028 E247 C2 73 E2		JNZ	RENAME5	;again, no wild cards.
  1029 E24A F1			POP	PSW	;if a drive was specified, then it
  1030 E24B 47			MOV	B,A	;must be the same as before.
  1031 E24C 21 F0 E3		LXI	H,CHGDRV
  1032 E24F 7E			MOV	A,M
  1033 E250 B7			ORA	A
  1034 E251 CA 59 E2		JZ	RENAME2
  1035 E254 B8			CMP	B
  1036 E255 70			MOV	M,B
  1037 E256 C2 73 E2		JNZ	RENAME5	;they were different, error.
  1038 E259 70		RENAME2	MOV	M,B;	reset as per the first file specification.
  1039 E25A AF			XRA	A
  1040 E25B 32 CD E3		STA	FCB	;clear the drive byte of the fcb.
  1041 E25E CD E9 DC	RENAME3	CALL	SRCHFCB	;and go look for second file.
  1042 E261 CA 6D E2		JZ	RENAME4	;doesn't exist?
  1043 E264 11 CD E3		LXI	D,FCB
  1044 E267 CD 0E DD		CALL	RENAM	;ok, rename the file.
  1045 E26A C3 86 E3		JMP	GETBACK
  1046 			;
  1047 			;   Process rename errors here.
  1048 			;
  1049 E26D CD EA DF	RENAME4	CALL	NONE	;file not there.
  1050 E270 C3 86 E3		JMP	GETBACK
  1051 E273 CD 66 E0	RENAME5	CALL	RESETDR	;bad command format.
  1052 E276 C3 09 DE		JMP	SYNERR
  1053 E279 01 82 E2	RENAME6	LXI	B,EXISTS;destination file already exists.
  1054 E27C CD A7 DC		CALL	PLINE
  1055 E27F C3 86 E3		JMP	GETBACK
  1056 E282		EXISTS	DB	'File exists',0
            46 69 6C 65 
            20 65 78 69 
            73 74 73 00 
            
  1057 			;
  1058 			;**************************************************************
  1059 			;*
  1060 			;*             U S E R   C O M M A N D
  1061 			;*
  1062 			;**************************************************************
  1063 			;
  1064 E28E CD F8 DF	USER	CALL	DECODE	;get numeric value following command.
  1065 E291 FE 10		CPI	16	;legal user number?
  1066 E293 D2 09 DE		JNC	SYNERR
  1067 E296 5F			MOV	E,A	;yes but is there anything else?
  1068 E297 3A CE E3		LDA	FCB+1
  1069 E29A FE 20		CPI	' '
  1070 E29C CA 09 DE		JZ	SYNERR	;yes, that is not allowed.
  1071 E29F CD 15 DD		CALL	GETSETUC;ok, set user code.
  1072 E2A2 C3 89 E3		JMP	GETBACK1
  1073 			;
  1074 			;**************************************************************
  1075 			;*
  1076 			;*        T R A N S I A N T   P R O G R A M   C O M M A N D
  1077 			;*
  1078 			;**************************************************************
  1079 			;
  1080 E2A5 CD F5 DD	UNKNOWN	CALL	VERIFY	;check for valid system (why?).
  1081 E2A8 3A CE E3		LDA	FCB+1	;anything to execute?
  1082 E2AB FE 20		CPI	' '
  1083 E2AD C2 C4 E2		JNZ	UNKWN1
  1084 E2B0 3A F0 E3		LDA	CHGDRV	;nope, only a drive change?
  1085 E2B3 B7			ORA	A
  1086 E2B4 CA 89 E3		JZ	GETBACK1;neither???
  1087 E2B7 3D			DCR	A
  1088 E2B8 32 EF E3		STA	CDRIVE	;ok, store new drive.
  1089 E2BB CD 29 DD		CALL	MOVECD	;set (TDRIVE) also.
  1090 E2BE CD BD DC		CALL	DSKSEL	;and select this drive.
  1091 E2C1 C3 89 E3		JMP	GETBACK1;then return.
  1092 			;
  1093 			;   Here a file name was typed. Prepare to execute it.
  1094 			;
  1095 E2C4 11 D6 E3	UNKWN1	LXI	D,FCB+9	;an extension specified?
  1096 E2C7 1A			LDAX	D
  1097 E2C8 FE 20		CPI	' '
  1098 E2CA C2 09 DE		JNZ	SYNERR	;yes, not allowed.
  1099 E2CD D5		UNKWN2	PUSH	D
  1100 E2CE CD 54 E0		CALL	DSELECT	;select specified drive.
  1101 E2D1 D1			POP	D
  1102 E2D2 21 83 E3		LXI	H,COMFILE	;set the extension to 'COM'.
  1103 E2D5 CD 40 E0		CALL	MOVE3
  1104 E2D8 CD D0 DC		CALL	OPENFCB	;and open this file.
  1105 E2DB CA 6B E3		JZ	UNKWN9	;not present?
  1106 			;
  1107 			;   Load in the program.
  1108 			;
  1109 E2DE 21 00 01		LXI	H,TBASE	;store the program starting here.
  1110 E2E1 E5		UNKWN3	PUSH	H
  1111 E2E2 EB			XCHG
  1112 E2E3 CD D8 DD		CALL	DMASET	;set transfer address.
  1113 E2E6 11 CD E3		LXI	D,FCB	;and read the next record.
  1114 E2E9 CD F9 DC		CALL	RDREC
  1115 E2EC C2 01 E3		JNZ	UNKWN4	;end of file or read error?
  1116 E2EF E1			POP	H	;nope, bump pointer for next sector.
  1117 E2F0 11 80 00		LXI	D,128
  1118 E2F3 19			DAD	D
  1119 E2F4 11 00 DC		LXI	D,CBASE	;enough room for the whole file?
  1120 E2F7 7D			MOV	A,L
  1121 E2F8 93			SUB	E
  1122 E2F9 7C			MOV	A,H
  1123 E2FA 9A			SBB	D
  1124 E2FB D2 71 E3		JNC	UNKWN0	;no, it can't fit.
  1125 E2FE C3 E1 E2		JMP	UNKWN3
  1126 			;
  1127 			;   Get here after finished reading.
  1128 			;
  1129 E301 E1		UNKWN4	POP	H
  1130 E302 3D			DCR	A	;normal end of file?
  1131 E303 C2 71 E3		JNZ	UNKWN0
  1132 E306 CD 66 E0		CALL	RESETDR	;yes, reset previous drive.
  1133 E309 CD 5E DE		CALL	CONVFST	;convert the first file name that follows
  1134 E30C 21 F0 E3		LXI	H,CHGDRV;command name.
  1135 E30F E5			PUSH	H
  1136 E310 7E			MOV	A,M	;set drive code in default fcb.
  1137 E311 32 CD E3		STA	FCB
  1138 E314 3E 10		MVI	A,16	;put second name 16 bytes later.
  1139 E316 CD 60 DE		CALL	CONVERT	;convert second file name.
  1140 E319 E1			POP	H
  1141 E31A 7E			MOV	A,M	;and set the drive for this second file.
  1142 E31B 32 DD E3		STA	FCB+16
  1143 E31E AF			XRA	A	;clear record byte in fcb.
  1144 E31F 32 ED E3		STA	FCB+32
  1145 E322 11 5C 00		LXI	D,TFCB	;move it into place at(005Ch).
  1146 E325 21 CD E3		LXI	H,FCB
  1147 E328 06 21		MVI	B,33
  1148 E32A CD 42 E0		CALL	HL2DE
  1149 E32D 21 08 DC		LXI	H,INBUFF+2;now move the remainder of the input
  1150 E330 7E		UNKWN5	MOV	A,M	;line down to (0080h). Look for a non blank.
  1151 E331 B7			ORA	A	;or a null.
  1152 E332 CA 3E E3		JZ	UNKWN6
  1153 E335 FE 20		CPI	' '
  1154 E337 CA 3E E3		JZ	UNKWN6
  1155 E33A 23			INX	H
  1156 E33B C3 30 E3		JMP	UNKWN5
  1157 			;
  1158 			;   Do the line move now. It ends in a null byte.
  1159 			;
  1160 E33E 06 00	UNKWN6	MVI	B,0	;keep a character count.
  1161 E340 11 81 00		LXI	D,TBUFF+1;data gets put here.
  1162 E343 7E		UNKWN7	MOV	A,M	;move it now.
  1163 E344 12			STAX	D
  1164 E345 B7			ORA	A
  1165 E346 CA 4F E3		JZ	UNKWN8
  1166 E349 04			INR	B
  1167 E34A 23			INX	H
  1168 E34B 13			INX	D
  1169 E34C C3 43 E3		JMP	UNKWN7
  1170 E34F 78		UNKWN8	MOV	A,B	;now store the character count.
  1171 E350 32 80 00		STA	TBUFF
  1172 E353 CD 98 DC		CALL	CRLF	;clean up the screen.
  1173 E356 CD D5 DD		CALL	STDDMA	;set standard transfer address.
  1174 E359 CD 1A DD		CALL	SETCDRV	;reset current drive.
  1175 E35C CD 00 01		CALL	TBASE	;and execute the program.
  1176 			;
  1177 			;   Transiant programs return here (or reboot).
  1178 			;
  1179 E35F 31 AB E3		LXI	SP,BATCH	;set stack first off.
  1180 E362 CD 29 DD		CALL	MOVECD	;move current drive into place (TDRIVE).
  1181 E365 CD BD DC		CALL	DSKSEL	;and reselect it.
  1182 E368 C3 82 DF		JMP	CMMND1	;back to comand mode.
  1183 			;
  1184 			;   Get here if some error occured.
  1185 			;
  1186 E36B CD 66 E0	UNKWN9	CALL	RESETDR	;inproper format.
  1187 E36E C3 09 DE		JMP	SYNERR
  1188 E371 01 7A E3	UNKWN0	LXI	B,BADLOAD;read error or won't fit.
  1189 E374 CD A7 DC		CALL	PLINE
  1190 E377 C3 86 E3		JMP	GETBACK
  1191 E37A		BADLOAD	DB	'Bad load',0
            42 61 64 20 
            6C 6F 61 64 
            00 
  1192 E383		COMFILE	DB	'COM'	;command file extension.
            43 4F 4D 
  1193 			;
  1194 			;   Get here to return to command level. We will reset the
  1195 			; previous active drive and then either return to command
  1196 			; level directly or print error message and then return.
  1197 			;
  1198 E386 CD 66 E0	GETBACK	CALL	RESETDR	;reset previous drive.
  1199 E389 CD 5E DE	GETBACK1:CALL	CONVFST	;convert first name in (FCB).
  1200 E38C 3A CE E3		LDA	FCB+1	;if this was just a drive change request,
  1201 E38F D6 20		SUI	' '	;make sure it was valid.
  1202 E391 21 F0 E3		LXI	H,CHGDRV
  1203 E394 B6			ORA	M
  1204 E395 C2 09 DE		JNZ	SYNERR
  1205 E398 C3 82 DF		JMP	CMMND1	;ok, return to command level.
  1206 			;
  1207 			;   ccp stack area.
  1208 			;
  1209 E39B			DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            
  1210      E3 AB	CCPSTACK:EQU	$	;end of ccp stack area.
  1211 			;
  1212 			;   Batch (or SUBMIT) processing information storage.
  1213 			;
  1214 E3AB		BATCH	DB	0	;batch mode flag (0=not active).
            00 
  1215 E3AC		BATCHFCB:DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 24 24 24 
            20 20 20 20 
            20 53 55 42 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 
  1216 			;
  1217 			;   File control block setup by the CCP.
  1218 			;
  1219 E3CD		FCB	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
            00 20 20 20 
            20 20 20 20 
            20 20 20 20 
            00 00 00 00 
            00 20 20 20 
            20 20 20 20 
            20 20 20 20 
            00 00 00 00 
            00 
  1220 E3EE		RTNCODE	DB	0	;status returned from bdos call.
            00 
  1221 E3EF		CDRIVE	DB	0	;currently active drive.
            00 
  1222 E3F0		CHGDRV	DB	0	;change in drives flag (0=no change).
            00 
  1223 E3F1		NBYTES	DW	0	;byte counter used by TYPE.
            0000 
  1224 			;
  1225 			;   Room for expansion?
  1226 			;
  1227 E3F3			DB	0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 
  1228 			;
  1229 			;   Note that the following six bytes must match those at
  1230 			; (PATTRN1) or cp/m will HALT. Why?
  1231 			;
  1232 E400		PATTRN2	DB	0,22,0,0,0,0;(* serial number bytes *).
            00 16 00 00 
            00 00 
  1233 			;
  1234 			;**************************************************************
  1235 			;*
  1236 			;*                    B D O S   E N T R Y
  1237 			;*
  1238 			;**************************************************************
  1239 			;
  1240 E406 C3 11 E4	FBASE	JMP	FBASE1
  1241 			;
  1242 			;   Bdos error table.
  1243 			;
  1244 E409		BADSCTR	DW	ERROR1	;bad sector on read or write.
            99E4 
  1245 E40B		BADSLCT	DW	ERROR2	;bad disk select.
            A5E4 
  1246 E40D		RODISK	DW	ERROR3	;disk is read only.
            ABE4 
  1247 E40F		ROFILE	DW	ERROR4	;file is read only.
            B1E4 
  1248 			;
  1249 			;   Entry into bdos. (DE) or (E) are the parameters passed. The
  1250 			; function number desired is in register (C).
  1251 			;
  1252 E411 EB		FBASE1	XCHG		;save the (DE) parameters.
  1253 E412 22 43 E7		SHLD	PARAMS
  1254 E415 EB			XCHG
  1255 E416 7B			MOV	A,E	;and save register (E) in particular.
  1256 E417 32 D6 F1		STA	EPARAM
  1257 E41A 21 00 00		LXI	H,0
  1258 E41D 22 45 E7		SHLD	STATUS	;clear return status.
  1259 E420 39			DAD	SP
  1260 E421 22 0F E7		SHLD	USRSTACK;save users stack pointer.
  1261 E424 31 41 E7		LXI	SP,STKAREA;and set our own.
  1262 E427 AF			XRA	A	;clear auto select storage space.
  1263 E428 32 E0 F1		STA	AUTOFLAG
  1264 E42B 32 DE F1		STA	AUTO
  1265 E42E 21 74 F1		LXI	H,GOBACK;set return address.
  1266 E431 E5			PUSH	H
  1267 E432 79			MOV	A,C	;get function number.
  1268 E433 FE 29		CPI	NFUNCTS	;valid function number?
  1269 E435 D0			RNC
  1270 E436 4B			MOV	C,E	;keep single register function here.
  1271 E437 21 47 E4		LXI	H,FUNCTNS;now look thru the function table.
  1272 E43A 5F			MOV	E,A
  1273 E43B 16 00		MVI	D,0	;(DE)=function number.
  1274 E43D 19			DAD	D
  1275 E43E 19			DAD	D	;(HL)=(start of table)+2*(function number).
  1276 E43F 5E			MOV	E,M
  1277 E440 23			INX	H
  1278 E441 56			MOV	D,M	;now (DE)=address for this function.
  1279 E442 2A 43 E7		LHLD	PARAMS	;retrieve parameters.
  1280 E445 EB			XCHG		;now (DE) has the original parameters.
  1281 E446 E9			PCHL		;execute desired function.
  1282 			;
  1283 			;   BDOS function jump table.
  1284 			;
  1285      00 29	NFUNCTS	EQU	41	;number of functions in followin table.
  1286 			;
  1287 E447		FUNCTNS	DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
            03F2 C8E6 90E5 
            CEE6 12F2 0FF2 
            D4E6 EDE6 
  1288 E457			DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
            F3E6 F8E6 E1E5 
            FEE6 7EF0 83F0 
            45F0 9CF0 
  1289 E467			DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
            A5F0 ABF0 C8F0 
            D7F0 E0F0 E6F0 
            ECF0 
  1290 E475			DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
            F5F0 FEF0 04F1 
            0AF1 11F1 2CE9 
            17F1 1DF1 
  1291 E485			DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
            26F1 2DF1 41F1 
            47F1 4DF1 0EF0 
            53F1 04E7 
  1292 E495			DW	RTN,WTSPECL
            04E7 9BF1 
  1293 			;
  1294 			;   Bdos error message section.
  1295 			;
  1296 E499 21 CA E4	ERROR1	LXI	H,BADSEC	;bad sector message.
  1297 E49C CD E5 E4		CALL	PRTERR	;print it and get a 1 char responce.
  1298 E49F FE 03		CPI	CNTRLC	;re-boot request (control-c)?
  1299 E4A1 CA 00 00		JZ	0	;yes.
  1300 E4A4 C9			RET		;no, return to retry i/o function.
  1301 			;
  1302 E4A5 21 D5 E4	ERROR2	LXI	H,BADSEL	;bad drive selected.
  1303 E4A8 C3 B4 E4		JMP	ERROR5
  1304 			;
  1305 E4AB 21 E1 E4	ERROR3	LXI	H,DISKRO	;disk is read only.
  1306 E4AE C3 B4 E4		JMP	ERROR5
  1307 			;
  1308 E4B1 21 DC E4	ERROR4	LXI	H,FILERO	;file is read only.
  1309 			;
  1310 E4B4 CD E5 E4	ERROR5	CALL	PRTERR
  1311 E4B7 C3 00 00		JMP	0	;always reboot on these errors.
  1312 			;
  1313 E4BA		BDOSERR	DB	'Bdos Err On '
            42 64 6F 73 
            20 45 72 72 
            20 4F 6E 20 
            
  1314 E4C6		BDOSDRV	DB	' : $'
            20 3A 20 24 
            
  1315 E4CA		BADSEC	DB	'Bad Sector$'
            42 61 64 20 
            53 65 63 74 
            6F 72 24 
  1316 E4D5		BADSEL	DB	'Select$'
            53 65 6C 65 
            63 74 24 
  1317 E4DC		FILERO	DB	'File '
            46 69 6C 65 
            20 
  1318 E4E1		DISKRO	DB	'R/O$'
            52 2F 4F 24 
            
  1319 			;
  1320 			;   Print bdos error message.
  1321 			;
  1322 E4E5 E5		PRTERR	PUSH	H	;save second message pointer.
  1323 E4E6 CD C9 E5		CALL	OUTCRLF	;send (cr)(lf).
  1324 E4E9 3A 42 E7		LDA	ACTIVE	;get active drive.
  1325 E4EC C6 41		ADI	'A'	;make ascii.
  1326 E4EE 32 C6 E4		STA	BDOSDRV	;and put in message.
  1327 E4F1 01 BA E4		LXI	B,BDOSERR;and print it.
  1328 E4F4 CD D3 E5		CALL	PRTMESG
  1329 E4F7 C1			POP	B	;print second message line now.
  1330 E4F8 CD D3 E5		CALL	PRTMESG
  1331 			;
  1332 			;   Get an input character. We will check our 1 character
  1333 			; buffer first. This may be set by the console status routine.
  1334 			;
  1335 E4FB 21 0E E7	GETCHAR	LXI	H,CHARBUF;check character buffer.
  1336 E4FE 7E			MOV	A,M	;anything present already?
  1337 E4FF 36 00		MVI	M,0	;...either case clear it.
  1338 E501 B7			ORA	A
  1339 E502 C0			RNZ		;yes, use it.
  1340 E503 C3 09 F2		JMP	CONIN	;nope, go get a character responce.
  1341 			;
  1342 			;   Input and echo a character.
  1343 			;
  1344 E506 CD FB E4	GETECHO	CALL	GETCHAR	;input a character.
  1345 E509 CD 14 E5		CALL	CHKCHAR	;carriage control?
  1346 E50C D8			RC		;no, a regular control char so don't echo.
  1347 E50D F5			PUSH	PSW	;ok, save character now.
  1348 E50E 4F			MOV	C,A
  1349 E50F CD 90 E5		CALL	OUTCON	;and echo it.
  1350 E512 F1			POP	PSW	;get character and return.
  1351 E513 C9			RET
  1352 			;
  1353 			;   Check character in (A). Set the zero flag on a carriage
  1354 			; control character and the carry flag on any other control
  1355 			; character.
  1356 			;
  1357 E514 FE 0D	CHKCHAR	CPI	CR	;check for carriage return, line feed, backspace,
  1358 E516 C8			RZ		;or a tab.
  1359 E517 FE 0A		CPI	LF
  1360 E519 C8			RZ
  1361 E51A FE 09		CPI	TAB
  1362 E51C C8			RZ
  1363 E51D FE 08		CPI	BS
  1364 E51F C8			RZ
  1365 E520 FE 20		CPI	' '	;other control char? Set carry flag.
  1366 E522 C9			RET
  1367 			;
  1368 			;   Check the console during output. Halt on a control-s, then
  1369 			; reboot on a control-c. If anything else is ready, clear the
  1370 			; zero flag and return (the calling routine may want to do
  1371 			; something).
  1372 			;
  1373 E523 3A 0E E7	CKCONSOL:LDA	CHARBUF	;check buffer.
  1374 E526 B7			ORA	A	;if anything, just return without checking.
  1375 E527 C2 45 E5		JNZ	CKCON2
  1376 E52A CD 06 F2		CALL	CONST	;nothing in buffer. Check console.
  1377 E52D E6 01		ANI	01H	;look at bit 0.
  1378 E52F C8			RZ		;return if nothing.
  1379 E530 CD 09 F2		CALL	CONIN	;ok, get it.
  1380 E533 FE 13		CPI	CNTRLS	;if not control-s, return with zero cleared.
  1381 E535 C2 42 E5		JNZ	CKCON1
  1382 E538 CD 09 F2		CALL	CONIN	;halt processing until another char
  1383 E53B FE 03		CPI	CNTRLC	;is typed. Control-c?
  1384 E53D CA 00 00		JZ	0	;yes, reboot now.
  1385 E540 AF			XRA	A	;no, just pretend nothing was ever ready.
  1386 E541 C9			RET
  1387 E542 32 0E E7	CKCON1	STA	CHARBUF	;save character in buffer for later processing.
  1388 E545 3E 01	CKCON2	MVI	A,1	;set (A) to non zero to mean something is ready.
  1389 E547 C9			RET
  1390 			;
  1391 			;   Output (C) to the screen. If the printer flip-flop flag
  1392 			; is set, we will send character to printer also. The console
  1393 			; will be checked in the process.
  1394 			;
  1395 E548 3A 0A E7	OUTCHAR	LDA	OUTFLAG	;check output flag.
  1396 E54B B7			ORA	A	;anything and we won't generate output.
  1397 E54C C2 62 E5		JNZ	OUTCHR1
  1398 E54F C5			PUSH	B
  1399 E550 CD 23 E5		CALL	CKCONSOL;check console (we don't care whats there).
  1400 E553 C1			POP	B
  1401 E554 C5			PUSH	B
  1402 E555 CD 0C F2		CALL	CONOUT	;output (C) to the screen.
  1403 E558 C1			POP	B
  1404 E559 C5			PUSH	B
  1405 E55A 3A 0D E7		LDA	PRTFLAG	;check printer flip-flop flag.
  1406 E55D B7			ORA	A
  1407 E55E C4 0F F2		CNZ	LIST	;print it also if non-zero.
  1408 E561 C1			POP	B
  1409 E562 79		OUTCHR1	MOV	A,C	;update cursors position.
  1410 E563 21 0C E7		LXI	H,CURPOS
  1411 E566 FE 7F		CPI	DEL	;rubouts don't do anything here.
  1412 E568 C8			RZ
  1413 E569 34			INR	M	;bump line pointer.
  1414 E56A FE 20		CPI	' '	;and return if a normal character.
  1415 E56C D0			RNC
  1416 E56D 35			DCR	M	;restore and check for the start of the line.
  1417 E56E 7E			MOV	A,M
  1418 E56F B7			ORA	A
  1419 E570 C8			RZ		;ingnore control characters at the start of the line.
  1420 E571 79			MOV	A,C
  1421 E572 FE 08		CPI	BS	;is it a backspace?
  1422 E574 C2 79 E5		JNZ	OUTCHR2
  1423 E577 35			DCR	M	;yes, backup pointer.
  1424 E578 C9			RET
  1425 E579 FE 0A	OUTCHR2	CPI	LF	;is it a line feed?
  1426 E57B C0			RNZ		;ignore anything else.
  1427 E57C 36 00		MVI	M,0	;reset pointer to start of line.
  1428 E57E C9			RET
  1429 			;
  1430 			;   Output (A) to the screen. If it is a control character
  1431 			; (other than carriage control), use ^x format.
  1432 			;
  1433 E57F 79		SHOWIT	MOV	A,C
  1434 E580 CD 14 E5		CALL	CHKCHAR	;check character.
  1435 E583 D2 90 E5		JNC	OUTCON	;not a control, use normal output.
  1436 E586 F5			PUSH	PSW
  1437 E587 0E 5E		MVI	C,'^'	;for a control character, preceed it with '^'.
  1438 E589 CD 48 E5		CALL	OUTCHAR
  1439 E58C F1			POP	PSW
  1440 E58D F6 40		ORI	'@'	;and then use the letter equivelant.
  1441 E58F 4F			MOV	C,A
  1442 			;
  1443 			;   Function to output (C) to the console device and expand tabs
  1444 			; if necessary.
  1445 			;
  1446 E590 79		OUTCON	MOV	A,C
  1447 E591 FE 09		CPI	TAB	;is it a tab?
  1448 E593 C2 48 E5		JNZ	OUTCHAR	;use regular output.
  1449 E596 0E 20	OUTCON1	MVI	C,' '	;yes it is, use spaces instead.
  1450 E598 CD 48 E5		CALL	OUTCHAR
  1451 E59B 3A 0C E7		LDA	CURPOS	;go until the cursor is at a multiple of 8
  1452
  1453 E59E E6 07		ANI	07H	;position.
  1454 E5A0 C2 96 E5		JNZ	OUTCON1
  1455 E5A3 C9			RET
  1456 			;
  1457 			;   Echo a backspace character. Erase the prevoius character
  1458 			; on the screen.
  1459 			;
  1460 E5A4 CD AC E5	BACKUP	CALL	BACKUP1	;backup the screen 1 place.
  1461 E5A7 0E 20		MVI	C,' '	;then blank that character.
  1462 E5A9 CD 0C F2		CALL	CONOUT
  1463 E5AC 0E 08	BACKUP1	MVI	C,BS	;then back space once more.
  1464 E5AE C3 0C F2		JMP	CONOUT
  1465 			;
  1466 			;   Signal a deleted line. Print a '#' at the end and start
  1467 			; over.
  1468 			;
  1469 E5B1 0E 23	NEWLINE	MVI	C,'#'
  1470 E5B3 CD 48 E5		CALL	OUTCHAR	;print this.
  1471 E5B6 CD C9 E5		CALL	OUTCRLF	;start new line.
  1472 E5B9 3A 0C E7	NEWLN1	LDA	CURPOS	;move the cursor to the starting position.
  1473 E5BC 21 0B E7		LXI	H,STARTING
  1474 E5BF BE			CMP	M
  1475 E5C0 D0			RNC		;there yet?
  1476 E5C1 0E 20		MVI	C,' '
  1477 E5C3 CD 48 E5		CALL	OUTCHAR	;nope, keep going.
  1478 E5C6 C3 B9 E5		JMP	NEWLN1
  1479 			;
  1480 			;   Output a (cr) (lf) to the console device (screen).
  1481 			;
  1482 E5C9 0E 0D	OUTCRLF	MVI	C,CR
  1483 E5CB CD 48 E5		CALL	OUTCHAR
  1484 E5CE 0E 0A		MVI	C,LF
  1485 E5D0 C3 48 E5		JMP	OUTCHAR
  1486 			;
  1487 			;   Print message pointed to by (BC). It will end with a '$'.
  1488 			;
  1489 E5D3 0A		PRTMESG	LDAX	B	;check for terminating character.
  1490 E5D4 FE 24		CPI	'$'
  1491 E5D6 C8			RZ
  1492 E5D7 03			INX	B
  1493 E5D8 C5			PUSH	B	;otherwise, bump pointer and print it.
  1494 E5D9 4F			MOV	C,A
  1495 E5DA CD 90 E5		CALL	OUTCON
  1496 E5DD C1			POP	B
  1497 E5DE C3 D3 E5		JMP	PRTMESG
  1498 			;
  1499 			;   Function to execute a buffered read.
  1500 			;
  1501 E5E1 3A 0C E7	RDBUFF	LDA	CURPOS	;use present location as starting one.
  1502 E5E4 32 0B E7		STA	STARTING
  1503 E5E7 2A 43 E7		LHLD	PARAMS	;get the maximum buffer space.
  1504 E5EA 4E			MOV	C,M
  1505 E5EB 23			INX	H	;point to first available space.
  1506 E5EC E5			PUSH	H	;and save.
  1507 E5ED 06 00		MVI	B,0	;keep a character count.
  1508 E5EF C5		RDBUF1	PUSH	B
  1509 E5F0 E5			PUSH	H
  1510 E5F1 CD FB E4	RDBUF2	CALL	GETCHAR	;get the next input character.
  1511 E5F4 E6 7F		ANI	7FH	;strip bit 7.
  1512 E5F6 E1			POP	H	;reset registers.
  1513 E5F7 C1			POP	B
  1514 E5F8 FE 0D		CPI	CR	;en of the line?
  1515 E5FA CA C1 E6		JZ	RDBUF17
  1516 E5FD FE 0A		CPI	LF
  1517 E5FF CA C1 E6		JZ	RDBUF17
  1518 E602 FE 08		CPI	BS	;how about a backspace?
  1519 E604 C2 16 E6		JNZ	RDBUF3
  1520 E607 78			MOV	A,B	;yes, but ignore at the beginning of the line.
  1521 E608 B7			ORA	A
  1522 E609 CA EF E5		JZ	RDBUF1
  1523 E60C 05			DCR	B	;ok, update counter.
  1524 E60D 3A 0C E7		LDA	CURPOS	;if we backspace to the start of the line,
  1525 E610 32 0A E7		STA	OUTFLAG	;treat as a cancel (control-x).
  1526 E613 C3 70 E6		JMP	RDBUF10
  1527 E616 FE 7F	RDBUF3	CPI	DEL	;user typed a rubout?
  1528 E618 C2 26 E6		JNZ	RDBUF4
  1529 E61B 78			MOV	A,B	;ignore at the start of the line.
  1530 E61C B7			ORA	A
  1531 E61D CA EF E5		JZ	RDBUF1
  1532 E620 7E			MOV	A,M	;ok, echo the prevoius character.
  1533 E621 05			DCR	B	;and reset pointers (counters).
  1534 E622 2B			DCX	H
  1535 E623 C3 A9 E6		JMP	RDBUF15
  1536 E626 FE 05	RDBUF4	CPI	CNTRLE	;physical end of line?
  1537 E628 C2 37 E6		JNZ	RDBUF5
  1538 E62B C5			PUSH	B	;yes, do it.
  1539 E62C E5			PUSH	H
  1540 E62D CD C9 E5		CALL	OUTCRLF
  1541 E630 AF			XRA	A	;and update starting position.
  1542 E631 32 0B E7		STA	STARTING
  1543 E634 C3 F1 E5		JMP	RDBUF2
  1544 E637 FE 10	RDBUF5	CPI	CNTRLP	;control-p?
  1545 E639 C2 48 E6		JNZ	RDBUF6
  1546 E63C E5			PUSH	H	;yes, flip the print flag filp-flop byte.
  1547 E63D 21 0D E7		LXI	H,PRTFLAG
  1548 E640 3E 01		MVI	A,1	;PRTFLAG=1-PRTFLAG
  1549 E642 96			SUB	M
  1550 E643 77			MOV	M,A
  1551 E644 E1			POP	H
  1552 E645 C3 EF E5		JMP	RDBUF1
  1553 E648 FE 18	RDBUF6	CPI	CNTRLX	;control-x (cancel)?
  1554 E64A C2 5F E6		JNZ	RDBUF8
  1555 E64D E1			POP	H
  1556 E64E 3A 0B E7	RDBUF7	LDA	STARTING;yes, backup the cursor to here.
  1557 E651 21 0C E7		LXI	H,CURPOS
  1558 E654 BE			CMP	M
  1559 E655 D2 E1 E5		JNC	RDBUFF	;done yet?
  1560 E658 35			DCR	M	;no, decrement pointer and output back up one space.
  1561 E659 CD A4 E5		CALL	BACKUP
  1562 E65C C3 4E E6		JMP	RDBUF7
  1563 E65F FE 15	RDBUF8	CPI	CNTRLU	;cntrol-u (cancel line)?
  1564 E661 C2 6B E6		JNZ	RDBUF9
  1565 E664 CD B1 E5		CALL	NEWLINE	;start a new line.
  1566 E667 E1			POP	H
  1567 E668 C3 E1 E5		JMP	RDBUFF
  1568 E66B FE 12	RDBUF9	CPI	CNTRLR	;control-r?
  1569 E66D C2 A6 E6		JNZ	RDBUF14
  1570 E670 C5		RDBUF10	PUSH	B	;yes, start a new line and retype the old one.
  1571 E671 CD B1 E5		CALL	NEWLINE
  1572 E674 C1			POP	B
  1573 E675 E1			POP	H
  1574 E676 E5			PUSH	H
  1575 E677 C5			PUSH	B
  1576 E678 78		RDBUF11	MOV	A,B	;done whole line yet?
  1577 E679 B7			ORA	A
  1578 E67A CA 8A E6		JZ	RDBUF12
  1579 E67D 23			INX	H	;nope, get next character.
  1580 E67E 4E			MOV	C,M
  1581 E67F 05			DCR	B	;count it.
  1582 E680 C5			PUSH	B
  1583 E681 E5			PUSH	H
  1584 E682 CD 7F E5		CALL	SHOWIT	;and display it.
  1585 E685 E1			POP	H
  1586 E686 C1			POP	B
  1587 E687 C3 78 E6		JMP	RDBUF11
  1588 E68A E5		RDBUF12	PUSH	H	;done with line. If we were displaying
  1589 E68B 3A 0A E7		LDA	OUTFLAG	;then update cursor position.
  1590 E68E B7			ORA	A
  1591 E68F CA F1 E5		JZ	RDBUF2
  1592 E692 21 0C E7		LXI	H,CURPOS;because this line is shorter, we must
  1593 E695 96			SUB	M	;back up the cursor (not the screen however)
  1594 E696 32 0A E7		STA	OUTFLAG	;some number of positions.
  1595 E699 CD A4 E5	RDBUF13	CALL	BACKUP	;note that as long as (OUTFLAG) is non
  1596 E69C 21 0A E7		LXI	H,OUTFLAG;zero, the screen will not be changed.
  1597 E69F 35			DCR	M
  1598 E6A0 C2 99 E6		JNZ	RDBUF13
  1599 E6A3 C3 F1 E5		JMP	RDBUF2	;now just get the next character.
  1600 			;
  1601 			;   Just a normal character, put this in our buffer and echo.
  1602 			;
  1603 E6A6 23		RDBUF14	INX	H
  1604 E6A7 77			MOV	M,A	;store character.
  1605 E6A8 04			INR	B	;and count it.
  1606 E6A9 C5		RDBUF15	PUSH	B
  1607 E6AA E5			PUSH	H
  1608 E6AB 4F			MOV	C,A	;echo it now.
  1609 E6AC CD 7F E5		CALL	SHOWIT
  1610 E6AF E1			POP	H
  1611 E6B0 C1			POP	B
  1612 E6B1 7E			MOV	A,M	;was it an abort request?
  1613 E6B2 FE 03		CPI	CNTRLC	;control-c abort?
  1614 E6B4 78			MOV	A,B
  1615 E6B5 C2 BD E6		JNZ	RDBUF16
  1616 E6B8 FE 01		CPI	1	;only if at start of line.
  1617 E6BA CA 00 00		JZ	0
  1618 E6BD B9		RDBUF16	CMP	C	;nope, have we filled the buffer?
  1619 E6BE DA EF E5		JC	RDBUF1
  1620 E6C1 E1		RDBUF17	POP	H	;yes end the line and return.
  1621 E6C2 70			MOV	M,B
  1622 E6C3 0E 0D		MVI	C,CR
  1623 E6C5 C3 48 E5		JMP	OUTCHAR	;output (cr) and return.
  1624 			;
  1625 			;   Function to get a character from the console device.
  1626 			;
  1627 E6C8 CD 06 E5	GETCON	CALL	GETECHO	;get and echo.
  1628 E6CB C3 01 E7		JMP	SETSTAT	;save status and return.
  1629 			;
  1630 			;   Function to get a character from the tape reader device.
  1631 			;
  1632 E6CE CD 15 F2	GETRDR	CALL	READER	;get a character from reader, set status and return.
  1633 E6D1 C3 01 E7		JMP	SETSTAT
  1634 			;
  1635 			;  Function to perform direct console i/o. If (C) contains (FF)
  1636 			; then this is an input request. If (C) contains (FE) then
  1637 			; this is a status request. Otherwise we are to output (C).
  1638 			;
  1639 E6D4 79		DIRCIO	MOV	A,C	;test for (FF).
  1640 E6D5 3C			INR	A
  1641 E6D6 CA E0 E6		JZ	DIRC1
  1642 E6D9 3C			INR	A	;test for (FE).
  1643 E6DA CA 06 F2		JZ	CONST
  1644 E6DD C3 0C F2		JMP	CONOUT	;just output (C).
  1645 E6E0 CD 06 F2	DIRC1	CALL	CONST	;this is an input request.
  1646 E6E3 B7			ORA	A
  1647 E6E4 CA 91 F1		JZ	GOBACK1	;not ready? Just return (directly).
  1648 E6E7 CD 09 F2		CALL	CONIN	;yes, get character.
  1649 E6EA C3 01 E7		JMP	SETSTAT	;set status and return.
  1650 			;
  1651 			;   Function to return the i/o byte.
  1652 			;
  1653 E6ED 3A 03 00	GETIOB	LDA	IOBYTE
  1654 E6F0 C3 01 E7		JMP	SETSTAT
  1655 			;
  1656 			;   Function to set the i/o byte.
  1657 			;
  1658 E6F3 21 03 00	SETIOB	LXI	H,IOBYTE
  1659 E6F6 71			MOV	M,C
  1660 E6F7 C9			RET
  1661 			;
  1662 			;   Function to print the character string pointed to by (DE)
  1663 			; on the console device. The string ends with a '$'.
  1664 			;
  1665 E6F8 EB		PRTSTR	XCHG
  1666 E6F9 4D			MOV	C,L
  1667 E6FA 44			MOV	B,H	;now (BC) points to it.
  1668 E6FB C3 D3 E5		JMP	PRTMESG
  1669 			;
  1670 			;   Function to interigate the console device.
  1671 			;
  1672 E6FE CD 23 E5	GETCSTS	CALL	CKCONSOL
  1673 			;
  1674 			;   Get here to set the status and return to the cleanup
  1675 			; section. Then back to the user.
  1676 			;
  1677 E701 32 45 E7	SETSTAT	STA	STATUS
  1678 E704 C9		RTN	RET
  1679 			;
  1680 			;   Set the status to 1 (read or write error code).
  1681 			;
  1682 E705 3E 01	IOERR1	MVI	A,1
  1683 E707 C3 01 E7		JMP	SETSTAT
  1684 			;
  1685 E70A		OUTFLAG	DB	0	;output flag (non zero means no output).
            00 
  1686 E70B		STARTING:DB	2	;starting position for cursor.
            02 
  1687 E70C		CURPOS	DB	0	;cursor position (0=start of line).
            00 
  1688 E70D		PRTFLAG	DB	0	;printer flag (control-p toggle). List if non zero.
            00 
  1689 E70E		CHARBUF	DB	0	;single input character buffer.
            00 
  1690 			;
  1691 			;   Stack area for BDOS calls.
  1692 			;
  1693 E70F		USRSTACK:DW	0	;save users stack pointer here.
            0000 
  1694 			;
  1695 E711			DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            
  1696 E729			DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            
  1697      E7 41	STKAREA	EQU	$	;end of stack area.
  1698 			;
  1699 E741		USERNO	DB	0	;current user number.
            00 
  1700 E742		ACTIVE	DB	0	;currently active drive.
            00 
  1701 E743		PARAMS	DW	0	;save (DE) parameters here on entry.
            0000 
  1702 E745		STATUS	DW	0	;status returned from bdos function.
            0000 
  1703 			;
  1704 			;   Select error occured, jump to error routine.
  1705 			;
  1706 E747 21 0B E4	SLCTERR	LXI	H,BADSLCT
  1707 			;
  1708 			;   Jump to (HL) indirectly.
  1709 			;
  1710 E74A 5E		JUMPHL	MOV	E,M
  1711 E74B 23			INX	H
  1712 E74C 56			MOV	D,M	;now (DE) contain the desired address.
  1713 E74D EB			XCHG
  1714 E74E E9			PCHL
  1715 			;
  1716 			;   Block move. (DE) to (HL), (C) bytes total.
  1717 			;
  1718 E74F 0C		DE2HL	INR	C	;is count down to zero?
  1719 E750 0D		DE2HL1	DCR	C
  1720 E751 C8			RZ		;yes, we are done.
  1721 E752 1A			LDAX	D	;no, move one more byte.
  1722 E753 77			MOV	M,A
  1723 E754 13			INX	D
  1724 E755 23			INX	H
  1725 E756 C3 50 E7		JMP	DE2HL1	;and repeat.
  1726 			;
  1727 			;   Select the desired drive.
  1728 			;
  1729 E759 3A 42 E7	SELECT	LDA	ACTIVE	;get active disk.
  1730 E75C 4F			MOV	C,A
  1731 E75D CD 1B F2		CALL	SELDSK	;select it.
  1732 E760 7C			MOV	A,H	;valid drive?
  1733 E761 B5			ORA	L	;valid drive?
  1734 E762 C8			RZ		;return if not.
  1735 			;
  1736 			;   Here, the BIOS returned the address of the parameter block
  1737 			; in (HL). We will extract the necessary pointers and save them.
  1738 			;
  1739 E763 5E			MOV	E,M	;yes, get address of translation table into (DE).
  1740 E764 23			INX	H
  1741 E765 56			MOV	D,M
  1742 E766 23			INX	H
  1743 E767 22 B3 F1		SHLD	SCRATCH1	;save pointers to scratch areas.
  1744 E76A 23			INX	H
  1745 E76B 23			INX	H
  1746 E76C 22 B5 F1		SHLD	SCRATCH2	;ditto.
  1747 E76F 23			INX	H
  1748 E770 23			INX	H
  1749 E771 22 B7 F1		SHLD	SCRATCH3	;ditto.
  1750 E774 23			INX	H
  1751 E775 23			INX	H
  1752 E776 EB			XCHG		;now save the translation table address.
  1753 E777 22 D0 F1		SHLD	XLATE
  1754 E77A 21 B9 F1		LXI	H,DIRBUF	;put the next 8 bytes here.
  1755 E77D 0E 08		MVI	C,8	;they consist of the directory buffer
  1756 E77F CD 4F E7		CALL	DE2HL	;pointer, parameter block pointer,
  1757 E782 2A BB F1		LHLD	DISKPB	;check and allocation vectors.
  1758 E785 EB			XCHG
  1759 E786 21 C1 F1		LXI	H,SECTORS	;move parameter block into our ram.
  1760 E789 0E 0F		MVI	C,15	;it is 15 bytes long.
  1761 E78B CD 4F E7		CALL	DE2HL
  1762 E78E 2A C6 F1		LHLD	DSKSIZE	;check disk size.
  1763 E791 7C			MOV	A,H	;more than 256 blocks on this?
  1764 E792 21 DD F1		LXI	H,BIGDISK
  1765 E795 36 FF		MVI	M,0FFH	;set to samll.
  1766 E797 B7			ORA	A
  1767 E798 CA 9D E7		JZ	SELECT1
  1768 E79B 36 00		MVI	M,0	;wrong, set to large.
  1769 E79D 3E FF	SELECT1	MVI	A,0FFH	;clear the zero flag.
  1770 E79F B7			ORA	A
  1771 E7A0 C9			RET
  1772 			;
  1773 			;   Routine to home the disk track head and clear pointers.
  1774 			;
  1775 E7A1 CD 18 F2	HOMEDRV	CALL	HOME	;home the head.
  1776 E7A4 AF			XRA	A
  1777 E7A5 2A B5 F1		LHLD	SCRATCH2;set our track pointer also.
  1778 E7A8 77			MOV	M,A
  1779 E7A9 23			INX	H
  1780 E7AA 77			MOV	M,A
  1781 E7AB 2A B7 F1		LHLD	SCRATCH3;and our sector pointer.
  1782 E7AE 77			MOV	M,A
  1783 E7AF 23			INX	H
  1784 E7B0 77			MOV	M,A
  1785 E7B1 C9			RET
  1786 			;
  1787 			;   Do the actual disk read and check the error return status.
  1788 			;
  1789 E7B2 CD 27 F2	DOREAD	CALL	READ
  1790 E7B5 C3 BB E7		JMP	IORET
  1791 			;
  1792 			;   Do the actual disk write and handle any bios error.
  1793 			;
  1794 E7B8 CD 2A F2	DOWRITE	CALL	WRITE
  1795 E7BB B7		IORET	ORA	A
  1796 E7BC C8			RZ		;return unless an error occured.
  1797 E7BD 21 09 E4		LXI	H,BADSCTR;bad read/write on this sector.
  1798 E7C0 C3 4A E7		JMP	JUMPHL
  1799 			;
  1800 			;   Routine to select the track and sector that the desired
  1801 			; block number falls in.
  1802 			;
  1803 E7C3 2A EA F1	TRKSEC	LHLD	FILEPOS	;get position of last accessed file
  1804 E7C6 0E 02		MVI	C,2	;in directory and compute sector #.
  1805 E7C8 CD EA E8		CALL	SHIFTR	;sector #=file-position/4.
  1806 E7CB 22 E5 F1		SHLD	BLKNMBR	;save this as the block number of interest.
  1807 E7CE 22 EC F1		SHLD	CKSUMTBL;what's it doing here too?
  1808 			;
  1809 			;   if the sector number has already been set (BLKNMBR), enter
  1810 			; at this point.
  1811 			;
  1812 E7D1 21 E5 F1	TRKSEC1	LXI	H,BLKNMBR
  1813 E7D4 4E			MOV	C,M	;move sector number into (BC).
  1814 E7D5 23			INX	H
  1815 E7D6 46			MOV	B,M
  1816 E7D7 2A B7 F1		LHLD	SCRATCH3;get current sector number and
  1817 E7DA 5E			MOV	E,M	;move this into (DE).
  1818 E7DB 23			INX	H
  1819 E7DC 56			MOV	D,M
  1820 E7DD 2A B5 F1		LHLD	SCRATCH2;get current track number.
  1821 E7E0 7E			MOV	A,M	;and this into (HL).
  1822 E7E1 23			INX	H
  1823 E7E2 66			MOV	H,M
  1824 E7E3 6F			MOV	L,A
  1825 E7E4 79		TRKSEC2	MOV	A,C	;is desired sector before current one?
  1826 E7E5 93			SUB	E
  1827 E7E6 78			MOV	A,B
  1828 E7E7 9A			SBB	D
  1829 E7E8 D2 FA E7		JNC	TRKSEC3
  1830 E7EB E5			PUSH	H	;yes, decrement sectors by one track.
  1831 E7EC 2A C1 F1		LHLD	SECTORS	;get sectors per track.
  1832 E7EF 7B			MOV	A,E
  1833 E7F0 95			SUB	L
  1834 E7F1 5F			MOV	E,A
  1835 E7F2 7A			MOV	A,D
  1836 E7F3 9C			SBB	H
  1837 E7F4 57			MOV	D,A	;now we have backed up one full track.
  1838 E7F5 E1			POP	H
  1839 E7F6 2B			DCX	H	;adjust track counter.
  1840 E7F7 C3 E4 E7		JMP	TRKSEC2
  1841 E7FA E5		TRKSEC3	PUSH	H	;desired sector is after current one.
  1842 E7FB 2A C1 F1		LHLD	SECTORS	;get sectors per track.
  1843 E7FE 19			DAD	D	;bump sector pointer to next track.
  1844 E7FF DA 0F E8		JC	TRKSEC4
  1845 E802 79			MOV	A,C	;is desired sector now before current one?
  1846 E803 95			SUB	L
  1847 E804 78			MOV	A,B
  1848 E805 9C			SBB	H
  1849 E806 DA 0F E8		JC	TRKSEC4
  1850 E809 EB			XCHG		;not yes, increment track counter
  1851 E80A E1			POP	H	;and continue until it is.
  1852 E80B 23			INX	H
  1853 E80C C3 FA E7		JMP	TRKSEC3
  1854 			;
  1855 			;   here we have determined the track number that contains the
  1856 			; desired sector.
  1857 			;
  1858 E80F E1		TRKSEC4	POP	H	;get track number (HL).
  1859 E810 C5			PUSH	B
  1860 E811 D5			PUSH	D
  1861 E812 E5			PUSH	H
  1862 E813 EB			XCHG
  1863 E814 2A CE F1		LHLD	OFFSET	;adjust for first track offset.
  1864 E817 19			DAD	D
  1865 E818 44			MOV	B,H
  1866 E819 4D			MOV	C,L
  1867 E81A CD 1E F2		CALL	SETTRK	;select this track.
  1868 E81D D1			POP	D	;reset current track pointer.
  1869 E81E 2A B5 F1		LHLD	SCRATCH2
  1870 E821 73			MOV	M,E
  1871 E822 23			INX	H
  1872 E823 72			MOV	M,D
  1873 E824 D1			POP	D
  1874 E825 2A B7 F1		LHLD	SCRATCH3;reset the first sector on this track.
  1875 E828 73			MOV	M,E
  1876 E829 23			INX	H
  1877 E82A 72			MOV	M,D
  1878 E82B C1			POP	B
  1879 E82C 79			MOV	A,C	;now subtract the desired one.
  1880 E82D 93			SUB	E	;to make it relative (1-# sectors/track).
  1881 E82E 4F			MOV	C,A
  1882 E82F 78			MOV	A,B
  1883 E830 9A			SBB	D
  1884 E831 47			MOV	B,A
  1885 E832 2A D0 F1		LHLD	XLATE	;translate this sector according to this table.
  1886 E835 EB			XCHG
  1887 E836 CD 30 F2		CALL	SECTRN	;let the bios translate it.
  1888 E839 4D			MOV	C,L
  1889 E83A 44			MOV	B,H
  1890 E83B C3 21 F2		JMP	SETSEC	;and select it.
  1891 			;
  1892 			;   Compute block number from record number (SAVNREC) and
  1893 			; extent number (SAVEXT).
  1894 			;
  1895 E83E 21 C3 F1	GETBLOCK:LXI	H,BLKSHFT;get logical to physical conversion.
  1896 E841 4E			MOV	C,M	;note that this is base 2 log of ratio.
  1897 E842 3A E3 F1		LDA	SAVNREC	;get record number.
  1898 E845 B7		GETBLK1	ORA	A	;compute (A)=(A)/2^BLKSHFT.
  1899 E846 1F			RAR
  1900 E847 0D			DCR	C
  1901 E848 C2 45 E8		JNZ	GETBLK1
  1902 E84B 47			MOV	B,A	;save result in (B).
  1903 E84C 3E 08		MVI	A,8
  1904 E84E 96			SUB	M
  1905 E84F 4F			MOV	C,A	;compute (C)=8-BLKSHFT.
  1906 E850 3A E2 F1		LDA	SAVEXT
  1907 E853 0D		GETBLK2	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
  1908 E854 CA 5C E8		JZ	GETBLK3
  1909 E857 B7			ORA	A
  1910 E858 17			RAL
  1911 E859 C3 53 E8		JMP	GETBLK2
  1912 E85C 80		GETBLK3	ADD	B
  1913 E85D C9			RET
  1914 			;
  1915 			;   Routine to extract the (BC) block byte from the fcb pointed
  1916 			; to by (PARAMS). If this is a big-disk, then these are 16 bit
  1917 			; block numbers, else they are 8 bit numbers.
  1918 			; Number is returned in (HL).
  1919 			;
  1920 E85E 2A 43 E7	EXTBLK	LHLD	PARAMS	;get fcb address.
  1921 E861 11 10 00		LXI	D,16	;block numbers start 16 bytes into fcb.
  1922 E864 19			DAD	D
  1923 E865 09			DAD	B
  1924 E866 3A DD F1		LDA	BIGDISK	;are we using a big-disk?
  1925 E869 B7			ORA	A
  1926 E86A CA 71 E8		JZ	EXTBLK1
  1927 E86D 6E			MOV	L,M	;no, extract an 8 bit number from the fcb.
  1928 E86E 26 00		MVI	H,0
  1929 E870 C9			RET
  1930 E871 09		EXTBLK1	DAD	B	;yes, extract a 16 bit number.
  1931 E872 5E			MOV	E,M
  1932 E873 23			INX	H
  1933 E874 56			MOV	D,M
  1934 E875 EB			XCHG		;return in (HL).
  1935 E876 C9			RET
  1936 			;
  1937 			;   Compute block number.
  1938 			;
  1939 E877 CD 3E E8	COMBLK	CALL	GETBLOCK
  1940 E87A 4F			MOV	C,A
  1941 E87B 06 00		MVI	B,0
  1942 E87D CD 5E E8		CALL	EXTBLK
  1943 E880 22 E5 F1		SHLD	BLKNMBR
  1944 E883 C9			RET
  1945 			;
  1946 			;   Check for a zero block number (unused).
  1947 			;
  1948 E884 2A E5 F1	CHKBLK	LHLD	BLKNMBR
  1949 E887 7D			MOV	A,L	;is it zero?
  1950 E888 B4			ORA	H
  1951 E889 C9			RET
  1952 			;
  1953 			;   Adjust physical block (BLKNMBR) and convert to logical
  1954 			; sector (LOGSECT). This is the starting sector of this block.
  1955 			; The actual sector of interest is then added to this and the
  1956 			; resulting sector number is stored back in (BLKNMBR). This
  1957 			; will still have to be adjusted for the track number.
  1958 			;
  1959 E88A 3A C3 F1	LOGICAL	LDA	BLKSHFT	;get log2(physical/logical sectors).
  1960 E88D 2A E5 F1		LHLD	BLKNMBR	;get physical sector desired.
  1961 E890 29		LOGICL1	DAD	H	;compute logical sector number.
  1962 E891 3D			DCR	A	;note logical sectors are 128 bytes long.
  1963 E892 C2 90 E8		JNZ	LOGICL1
  1964 E895 22 E7 F1		SHLD	LOGSECT	;save logical sector.
  1965 E898 3A C4 F1		LDA	BLKMASK	;get block mask.
  1966 E89B 4F			MOV	C,A
  1967 E89C 3A E3 F1		LDA	SAVNREC	;get next sector to access.
  1968 E89F A1			ANA	C	;extract the relative position within physical block.
  1969 E8A0 B5			ORA	L	;and add it too logical sector.
  1970 E8A1 6F			MOV	L,A
  1971 E8A2 22 E5 F1		SHLD	BLKNMBR	;and store.
  1972 E8A5 C9			RET
  1973 			;
  1974 			;   Set (HL) to point to extent byte in fcb.
  1975 			;
  1976 E8A6 2A 43 E7	SETEXT	LHLD	PARAMS
  1977 E8A9 11 0C 00		LXI	D,12	;it is the twelth byte.
  1978 E8AC 19			DAD	D
  1979 E8AD C9			RET
  1980 			;
  1981 			;   Set (HL) to point to record count byte in fcb and (DE) to
  1982 			; next record number byte.
  1983 			;
  1984 E8AE 2A 43 E7	SETHLDE	LHLD	PARAMS
  1985 E8B1 11 0F 00		LXI	D,15	;record count byte (#15).
  1986 E8B4 19			DAD	D
  1987 E8B5 EB			XCHG
  1988 E8B6 21 11 00		LXI	H,17	;next record number (#32).
  1989 E8B9 19			DAD	D
  1990 E8BA C9			RET
  1991 			;
  1992 			;   Save current file data from fcb.
  1993 			;
  1994 E8BB CD AE E8	STRDATA	CALL	SETHLDE
  1995 E8BE 7E			MOV	A,M	;get and store record count byte.
  1996 E8BF 32 E3 F1		STA	SAVNREC
  1997 E8C2 EB			XCHG
  1998 E8C3 7E			MOV	A,M	;get and store next record number byte.
  1999 E8C4 32 E1 F1		STA	SAVNXT
  2000 E8C7 CD A6 E8		CALL	SETEXT	;point to extent byte.
  2001 E8CA 3A C5 F1		LDA	EXTMASK	;get extent mask.
  2002 E8CD A6			ANA	M
  2003 E8CE 32 E2 F1		STA	SAVEXT	;and save extent here.
  2004 E8D1 C9			RET
  2005 			;
  2006 			;   Set the next record to access. If (MODE) is set to 2, then
  2007 			; the last record byte (SAVNREC) has the correct number to access.
  2008 			; For sequential access, (MODE) will be equal to 1.
  2009 			;
  2010 E8D2 CD AE E8	SETNREC	CALL	SETHLDE
  2011 E8D5 3A D5 F1		LDA	MODE	;get sequential flag (=1).
  2012 E8D8 FE 02		CPI	2	;a 2 indicates that no adder is needed.
  2013 E8DA C2 DE E8		JNZ	STNREC1
  2014 E8DD AF			XRA	A	;clear adder (random access?).
  2015 E8DE 4F		STNREC1	MOV	C,A
  2016 E8DF 3A E3 F1		LDA	SAVNREC	;get last record number.
  2017 E8E2 81			ADD	C	;increment record count.
  2018 E8E3 77			MOV	M,A	;and set fcb's next record byte.
  2019 E8E4 EB			XCHG
  2020 E8E5 3A E1 F1		LDA	SAVNXT	;get next record byte from storage.
  2021 E8E8 77			MOV	M,A	;and put this into fcb as number of records used.
  2022 E8E9 C9			RET
  2023 			;
  2024 			;   Shift (HL) right (C) bits.
  2025 			;
  2026 E8EA 0C		SHIFTR	INR	C
  2027 E8EB 0D		SHIFTR1	DCR	C
  2028 E8EC C8			RZ
  2029 E8ED 7C			MOV	A,H
  2030 E8EE B7			ORA	A
  2031 E8EF 1F			RAR
  2032 E8F0 67			MOV	H,A
  2033 E8F1 7D			MOV	A,L
  2034 E8F2 1F			RAR
  2035 E8F3 6F			MOV	L,A
  2036 E8F4 C3 EB E8		JMP	SHIFTR1
  2037 			;
  2038 			;   Compute the check-sum for the directory buffer. Return
  2039 			; integer sum in (A).
  2040 			;
  2041 E8F7 0E 80	CHECKSUM:MVI	C,128	;length of buffer.
  2042 E8F9 2A B9 F1		LHLD	DIRBUF	;get its location.
  2043 E8FC AF			XRA	A	;clear summation byte.
  2044 E8FD 86		CHKSUM1	ADD	M	;and compute sum ignoring carries.
  2045 E8FE 23			INX	H
  2046 E8FF 0D			DCR	C
  2047 E900 C2 FD E8		JNZ	CHKSUM1
  2048 E903 C9			RET
  2049 			;
  2050 			;   Shift (HL) left (C) bits.
  2051 			;
  2052 E904 0C		SHIFTL	INR	C
  2053 E905 0D		SHIFTL1	DCR	C
  2054 E906 C8			RZ
  2055 E907 29			DAD	H	;shift left 1 bit.
  2056 E908 C3 05 E9		JMP	SHIFTL1
  2057 			;
  2058 			;   Routine to set a bit in a 16 bit value contained in (BC).
  2059 			; The bit set depends on the current drive selection.
  2060 			;
  2061 E90B C5		SETBIT	PUSH	B	;save 16 bit word.
  2062 E90C 3A 42 E7		LDA	ACTIVE	;get active drive.
  2063 E90F 4F			MOV	C,A
  2064 E910 21 01 00		LXI	H,1
  2065 E913 CD 04 E9		CALL	SHIFTL	;shift bit 0 into place.
  2066 E916 C1			POP	B	;now 'or' this with the original word.
  2067 E917 79			MOV	A,C
  2068 E918 B5			ORA	L
  2069 E919 6F			MOV	L,A	;low byte done, do high byte.
  2070 E91A 78			MOV	A,B
  2071 E91B B4			ORA	H
  2072 E91C 67			MOV	H,A
  2073 E91D C9			RET
  2074 			;
  2075 			;   Extract the write protect status bit for the current drive.
  2076 			; The result is returned in (A), bit 0.
  2077 			;
  2078 E91E 2A AD F1	GETWPRT	LHLD	WRTPRT	;get status bytes.
  2079 E921 3A 42 E7		LDA	ACTIVE	;which drive is current?
  2080 E924 4F			MOV	C,A
  2081 E925 CD EA E8		CALL	SHIFTR	;shift status such that bit 0 is the
  2082 E928 7D			MOV	A,L	;one of interest for this drive.
  2083 E929 E6 01		ANI	01H	;and isolate it.
  2084 E92B C9			RET
  2085 			;
  2086 			;   Function to write protect the current disk.
  2087 			;
  2088 E92C 21 AD F1	WRTPRTD	LXI	H,WRTPRT;point to status word.
  2089 E92F 4E			MOV	C,M	;set (BC) equal to the status.
  2090 E930 23			INX	H
  2091 E931 46			MOV	B,M
  2092 E932 CD 0B E9		CALL	SETBIT	;and set this bit according to current drive.
  2093 E935 22 AD F1		SHLD	WRTPRT	;then save.
  2094 E938 2A C8 F1		LHLD	DIRSIZE	;now save directory size limit.
  2095 E93B 23			INX	H	;remember the last one.
  2096 E93C EB			XCHG
  2097 E93D 2A B3 F1		LHLD	SCRATCH1;and store it here.
  2098 E940 73			MOV	M,E	;put low byte.
  2099 E941 23			INX	H
  2100 E942 72			MOV	M,D	;then high byte.
  2101 E943 C9			RET
  2102 			;
  2103 			;   Check for a read only file.
  2104 			;
  2105 E944 CD 5E E9	CHKROFL	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
  2106 E947 11 09 00	CKROF1	LXI	D,9	;look at bit 7 of the ninth byte.
  2107 E94A 19			DAD	D
  2108 E94B 7E			MOV	A,M
  2109 E94C 17			RAL
  2110 E94D D0			RNC		;return if ok.
  2111 E94E 21 0F E4		LXI	H,ROFILE;else, print error message and terminate.
  2112 E951 C3 4A E7		JMP	JUMPHL
  2113 			;
  2114 			;   Check the write protect status of the active disk.
  2115 			;
  2116 E954 CD 1E E9	CHKWPRT	CALL	GETWPRT
  2117 E957 C8			RZ		;return if ok.
  2118 E958 21 0D E4		LXI	H,RODISK;else print message and terminate.
  2119 E95B C3 4A E7		JMP	JUMPHL
  2120 			;
  2121 			;   Routine to set (HL) pointing to the proper entry in the
  2122 			; directory buffer.
  2123 			;
  2124 E95E 2A B9 F1	FCB2HL	LHLD	DIRBUF	;get address of buffer.
  2125 E961 3A E9 F1		LDA	FCBPOS	;relative position of file.
  2126 			;
  2127 			;   Routine to add (A) to (HL).
  2128 			;
  2129 E964 85		ADDA2HL	ADD	L
  2130 E965 6F			MOV	L,A
  2131 E966 D0			RNC
  2132 E967 24			INR	H	;take care of any carry.
  2133 E968 C9			RET
  2134 			;
  2135 			;   Routine to get the 's2' byte from the fcb supplied in
  2136 			; the initial parameter specification.
  2137 			;
  2138 E969 2A 43 E7	GETS2	LHLD	PARAMS	;get address of fcb.
  2139 E96C 11 0E 00		LXI	D,14	;relative position of 's2'.
  2140 E96F 19			DAD	D
  2141 E970 7E			MOV	A,M	;extract this byte.
  2142 E971 C9			RET
  2143 			;
  2144 			;   Clear the 's2' byte in the fcb.
  2145 			;
  2146 E972 CD 69 E9	CLEARS2	CALL	GETS2	;this sets (HL) pointing to it.
  2147 E975 36 00		MVI	M,0	;now clear it.
  2148 E977 C9			RET
  2149 			;
  2150 			;   Set bit 7 in the 's2' byte of the fcb.
  2151 			;
  2152 E978 CD 69 E9	SETS2B7	CALL	GETS2	;get the byte.
  2153 E97B F6 80		ORI	80H	;and set bit 7.
  2154 E97D 77			MOV	M,A	;then store.
  2155 E97E C9			RET
  2156 			;
  2157 			;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
  2158 			; the difference. This checks to see if there are more file
  2159 			; names in the directory. We are at (FILEPOS) and there are
  2160 			; (SCRATCH1) of them to check.
  2161 			;
  2162 E97F 2A EA F1	MOREFLS	LHLD	FILEPOS	;we are here.
  2163 E982 EB			XCHG
  2164 E983 2A B3 F1		LHLD	SCRATCH1;and don't go past here.
  2165 E986 7B			MOV	A,E	;compute difference but don't keep.
  2166 E987 96			SUB	M
  2167 E988 23			INX	H
  2168 E989 7A			MOV	A,D
  2169 E98A 9E			SBB	M	;set carry if no more names.
  2170 E98B C9			RET
  2171 			;
  2172 			;   Call this routine to prevent (SCRATCH1) from being greater
  2173 			; than (FILEPOS).
  2174 			;
  2175 E98C CD 7F E9	CHKNMBR	CALL	MOREFLS	;SCRATCH1 too big?
  2176 E98F D8			RC
  2177 E990 13			INX	D	;yes, reset it to (FILEPOS).
  2178 E991 72			MOV	M,D
  2179 E992 2B			DCX	H
  2180 E993 73			MOV	M,E
  2181 E994 C9			RET
  2182 			;
  2183 			;   Compute (HL)=(DE)-(HL)
  2184 			;
  2185 E995 7B		SUBHL	MOV	A,E	;compute difference.
  2186 E996 95			SUB	L
  2187 E997 6F			MOV	L,A	;store low byte.
  2188 E998 7A			MOV	A,D
  2189 E999 9C			SBB	H
  2190 E99A 67			MOV	H,A	;and then high byte.
  2191 E99B C9			RET
  2192 			;
  2193 			;   Set the directory checksum byte.
  2194 			;
  2195 E99C 0E FF	SETDIR	MVI	C,0FFH
  2196 			;
  2197 			;   Routine to set or compare the directory checksum byte. If
  2198 			; (C)=0ffh, then this will set the checksum byte. Else the byte
  2199 			; will be checked. If the check fails (the disk has been changed),
  2200 			; then this disk will be write protected.
  2201 			;
  2202 E99E 2A EC F1	CHECKDIR:LHLD	CKSUMTBL
  2203 E9A1 EB			XCHG
  2204 E9A2 2A CC F1		LHLD	ALLOC1
  2205 E9A5 CD 95 E9		CALL	SUBHL
  2206 E9A8 D0			RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
  2207 E9A9 C5			PUSH	B
  2208 E9AA CD F7 E8		CALL	CHECKSUM;else compute checksum.
  2209 E9AD 2A BD F1		LHLD	CHKVECT	;get address of checksum table.
  2210 E9B0 EB			XCHG
  2211 E9B1 2A EC F1		LHLD	CKSUMTBL
  2212 E9B4 19			DAD	D	;set (HL) to point to byte for this drive.
  2213 E9B5 C1			POP	B
  2214 E9B6 0C			INR	C	;set or check ?
  2215 E9B7 CA C4 E9		JZ	CHKDIR1
  2216 E9BA BE			CMP	M	;check them.
  2217 E9BB C8			RZ		;return if they are the same.
  2218 E9BC CD 7F E9		CALL	MOREFLS	;not the same, do we care?
  2219 E9BF D0			RNC
  2220 E9C0 CD 2C E9		CALL	WRTPRTD	;yes, mark this as write protected.
  2221 E9C3 C9			RET
  2222 E9C4 77		CHKDIR1	MOV	M,A	;just set the byte.
  2223 E9C5 C9			RET
  2224 			;
  2225 			;   Do a write to the directory of the current disk.
  2226 			;
  2227 E9C6 CD 9C E9	DIRWRITE:CALL	SETDIR	;set checksum byte.
  2228 E9C9 CD E0 E9		CALL	DIRDMA	;set directory dma address.
  2229 E9CC 0E 01		MVI	C,1	;tell the bios to actually write.
  2230 E9CE CD B8 E7		CALL	DOWRITE	;then do the write.
  2231 E9D1 C3 DA E9		JMP	DEFDMA
  2232 			;
  2233 			;   Read from the directory.
  2234 			;
  2235 E9D4 CD E0 E9	DIRREAD	CALL	DIRDMA	;set the directory dma address.
  2236 E9D7 CD B2 E7		CALL	DOREAD	;and read it.
  2237 			;
  2238 			;   Routine to set the dma address to the users choice.
  2239 			;
  2240 E9DA 21 B1 F1	DEFDMA	LXI	H,USERDMA;reset the default dma address and return.
  2241 E9DD C3 E3 E9		JMP	DIRDMA1
  2242 			;
  2243 			;   Routine to set the dma address for directory work.
  2244 			;
  2245 E9E0 21 B9 F1	DIRDMA	LXI	H,DIRBUF
  2246 			;
  2247 			;   Set the dma address. On entry, (HL) points to
  2248 			; word containing the desired dma address.
  2249 			;
  2250 E9E3 4E		DIRDMA1	MOV	C,M
  2251 E9E4 23			INX	H
  2252 E9E5 46			MOV	B,M	;setup (BC) and go to the bios to set it.
  2253 E9E6 C3 24 F2		JMP	SETDMA
  2254 			;
  2255 			;   Move the directory buffer into user's dma space.
  2256 			;
  2257 E9E9 2A B9 F1	MOVEDIR	LHLD	DIRBUF	;buffer is located here, and
  2258 E9EC EB			XCHG
  2259 E9ED 2A B1 F1		LHLD	USERDMA; put it here.
  2260 E9F0 0E 80		MVI	C,128	;this is its length.
  2261 E9F2 C3 4F E7		JMP	DE2HL	;move it now and return.
  2262 			;
  2263 			;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
  2264 			;
  2265 E9F5 21 EA F1	CKFILPOS:LXI	H,FILEPOS
  2266 E9F8 7E			MOV	A,M
  2267 E9F9 23			INX	H
  2268 E9FA BE			CMP	M	;are both bytes the same?
  2269 E9FB C0			RNZ
  2270 E9FC 3C			INR	A	;yes, but are they each 0ffh?
  2271 E9FD C9			RET
  2272 			;
  2273 			;   Set location (FILEPOS) to 0ffffh.
  2274 			;
  2275 E9FE 21 FF FF	STFILPOS:LXI	H,0FFFFH
  2276 EA01 22 EA F1		SHLD	FILEPOS
  2277 EA04 C9			RET
  2278 			;
  2279 			;   Move on to the next file position within the current
  2280 			; directory buffer. If no more exist, set pointer to 0ffffh
  2281 			; and the calling routine will check for this. Enter with (C)
  2282 			; equal to 0ffh to cause the checksum byte to be set, else we
  2283 			; will check this disk and set write protect if checksums are
  2284 			; not the same (applies only if another directory sector must
  2285 			; be read).
  2286 			;
  2287 EA05 2A C8 F1	NXENTRY	LHLD	DIRSIZE	;get directory entry size limit.
  2288 EA08 EB			XCHG
  2289 EA09 2A EA F1		LHLD	FILEPOS	;get current count.
  2290 EA0C 23			INX	H	;go on to the next one.
  2291 EA0D 22 EA F1		SHLD	FILEPOS
  2292 EA10 CD 95 E9		CALL	SUBHL	;(HL)=(DIRSIZE)-(FILEPOS)
  2293 EA13 D2 19 EA		JNC	NXENT1	;is there more room left?
  2294 EA16 C3 FE E9		JMP	STFILPOS;no. Set this flag and return.
  2295 EA19 3A EA F1	NXENT1	LDA	FILEPOS	;get file position within directory.
  2296 EA1C E6 03		ANI	03H	;only look within this sector (only 4 entries fit).
  2297 EA1E 06 05		MVI	B,5	;convert to relative position (32 bytes each).
  2298 EA20 87		NXENT2	ADD	A	;note that this is not efficient code.
  2299 EA21 05			DCR	B	;5 'ADD A's would be better.
  2300 EA22 C2 20 EA		JNZ	NXENT2
  2301 EA25 32 E9 F1		STA	FCBPOS	;save it as position of fcb.
  2302 EA28 B7			ORA	A
  2303 EA29 C0			RNZ		;return if we are within buffer.
  2304 EA2A C5			PUSH	B
  2305 EA2B CD C3 E7		CALL	TRKSEC	;we need the next directory sector.
  2306 EA2E CD D4 E9		CALL	DIRREAD
  2307 EA31 C1			POP	B
  2308 EA32 C3 9E E9		JMP	CHECKDIR
  2309 			;
  2310 			;   Routine to to get a bit from the disk space allocation
  2311 			; map. It is returned in (A), bit position 0. On entry to here,
  2312 			; set (BC) to the block number on the disk to check.
  2313 			; On return, (D) will contain the original bit position for
  2314 			; this block number and (HL) will point to the address for it.
  2315 			;
  2316 EA35 79		CKBITMAP:MOV	A,C	;determine bit number of interest.
  2317 EA36 E6 07		ANI	07H	;compute (D)=(E)=(C and 7)+1.
  2318 EA38 3C			INR	A
  2319 EA39 5F			MOV	E,A	;save particular bit number.
  2320 EA3A 57			MOV	D,A
  2321 			;
  2322 			;   compute (BC)=(BC)/8.
  2323 			;
  2324 EA3B 79			MOV	A,C
  2325 EA3C 0F			RRC		;now shift right 3 bits.
  2326 EA3D 0F			RRC
  2327 EA3E 0F			RRC
  2328 EA3F E6 1F		ANI	1FH	;and clear bits 7,6,5.
  2329 EA41 4F			MOV	C,A
  2330 EA42 78			MOV	A,B
  2331 EA43 87			ADD	A	;now shift (B) into bits 7,6,5.
  2332 EA44 87			ADD	A
  2333 EA45 87			ADD	A
  2334 EA46 87			ADD	A
  2335 EA47 87			ADD	A
  2336 EA48 B1			ORA	C	;and add in (C).
  2337 EA49 4F			MOV	C,A	;ok, (C) ha been completed.
  2338 EA4A 78			MOV	A,B	;is there a better way of doing this?
  2339 EA4B 0F			RRC
  2340 EA4C 0F			RRC
  2341 EA4D 0F			RRC
  2342 EA4E E6 1F		ANI	1FH
  2343 EA50 47			MOV	B,A	;and now (B) is completed.
  2344 			;
  2345 			;   use this as an offset into the disk space allocation
  2346 			; table.
  2347 			;
  2348 EA51 2A BF F1		LHLD	ALOCVECT
  2349 EA54 09			DAD	B
  2350 EA55 7E			MOV	A,M	;now get correct byte.
  2351 EA56 07		CKBMAP1	RLC		;get correct bit into position 0.
  2352 EA57 1D			DCR	E
  2353 EA58 C2 56 EA		JNZ	CKBMAP1
  2354 EA5B C9			RET
  2355 			;
  2356 			;   Set or clear the bit map such that block number (BC) will be marked
  2357 			; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
  2358 			; 1 then it will be set (don't use anyother values).
  2359 			;
  2360 EA5C D5		STBITMAP:PUSH	D
  2361 EA5D CD 35 EA		CALL	CKBITMAP;get the byte of interest.
  2362 EA60 E6 FE		ANI	0FEH	;clear the affected bit.
  2363 EA62 C1			POP	B
  2364 EA63 B1			ORA	C	;and now set it acording to (C).
  2365 			;
  2366 			;  entry to restore the original bit position and then store
  2367 			; in table. (A) contains the value, (D) contains the bit
  2368 			; position (1-8), and (HL) points to the address within the
  2369 			; space allocation table for this byte.
  2370 			;
  2371 EA64 0F		STBMAP1	RRC		;restore original bit position.
  2372 EA65 15			DCR	D
  2373 EA66 C2 64 EA		JNZ	STBMAP1
  2374 EA69 77			MOV	M,A	;and stor byte in table.
  2375 EA6A C9			RET
  2376 			;
  2377 			;   Set/clear space used bits in allocation map for this file.
  2378 			; On entry, (C)=1 to set the map and (C)=0 to clear it.
  2379 			;
  2380 EA6B CD 5E E9	SETFILE	CALL	FCB2HL	;get address of fcb
  2381 EA6E 11 10 00		LXI	D,16
  2382 EA71 19			DAD	D	;get to block number bytes.
  2383 EA72 C5			PUSH	B
  2384 EA73 0E 11		MVI	C,17	;check all 17 bytes (max) of table.
  2385 EA75 D1		SETFL1	POP	D
  2386 EA76 0D			DCR	C	;done all bytes yet?
  2387 EA77 C8			RZ
  2388 EA78 D5			PUSH	D
  2389 EA79 3A DD F1		LDA	BIGDISK	;check disk size for 16 bit block numbers.
  2390 EA7C B7			ORA	A
  2391 EA7D CA 88 EA		JZ	SETFL2
  2392 EA80 C5			PUSH	B	;only 8 bit numbers. set (BC) to this one.
  2393 EA81 E5			PUSH	H
  2394 EA82 4E			MOV	C,M	;get low byte from table, always
  2395 EA83 06 00		MVI	B,0	;set high byte to zero.
  2396 EA85 C3 8E EA		JMP	SETFL3
  2397 EA88 0D		SETFL2	DCR	C	;for 16 bit block numbers, adjust counter.
  2398 EA89 C5			PUSH	B
  2399 EA8A 4E			MOV	C,M	;now get both the low and high bytes.
  2400 EA8B 23			INX	H
  2401 EA8C 46			MOV	B,M
  2402 EA8D E5			PUSH	H
  2403 EA8E 79		SETFL3	MOV	A,C	;block used?
  2404 EA8F B0			ORA	B
  2405 EA90 CA 9D EA		JZ	SETFL4
  2406 EA93 2A C6 F1		LHLD	DSKSIZE	;is this block number within the
  2407 EA96 7D			MOV	A,L	;space on the disk?
  2408 EA97 91			SUB	C
  2409 EA98 7C			MOV	A,H
  2410 EA99 98			SBB	B
  2411 EA9A D4 5C EA		CNC	STBITMAP;yes, set the proper bit.
  2412 EA9D E1		SETFL4	POP	H	;point to next block number in fcb.
  2413 EA9E 23			INX	H
  2414 EA9F C1			POP	B
  2415 EAA0 C3 75 EA		JMP	SETFL1
  2416 			;
  2417 			;   Construct the space used allocation bit map for the active
  2418 			; drive. If a file name starts with '$' and it is under the
  2419 			; current user number, then (STATUS) is set to minus 1. Otherwise
  2420 			; it is not set at all.
  2421 			;
  2422 EAA3 2A C6 F1	BITMAP	LHLD	DSKSIZE	;compute size of allocation table.
  2423 EAA6 0E 03		MVI	C,3
  2424 EAA8 CD EA E8		CALL	SHIFTR	;(HL)=(HL)/8.
  2425 EAAB 23			INX	H	;at lease 1 byte.
  2426 EAAC 44			MOV	B,H
  2427 EAAD 4D			MOV	C,L	;set (BC) to the allocation table length.
  2428 			;
  2429 			;   Initialize the bitmap for this drive. Right now, the first
  2430 			; two bytes are specified by the disk parameter block. However
  2431 			; a patch could be entered here if it were necessary to setup
  2432 			; this table in a special mannor. For example, the bios could
  2433 			; determine locations of 'bad blocks' and set them as already
  2434 			; 'used' in the map.
  2435 			;
  2436 EAAE 2A BF F1		LHLD	ALOCVECT;now zero out the table now.
  2437 EAB1 36 00	BITMAP1	MVI	M,0
  2438 EAB3 23			INX	H
  2439 EAB4 0B			DCX	B
  2440 EAB5 78			MOV	A,B
  2441 EAB6 B1			ORA	C
  2442 EAB7 C2 B1 EA		JNZ	BITMAP1
  2443 EABA 2A CA F1		LHLD	ALLOC0	;get initial space used by directory.
  2444 EABD EB			XCHG
  2445 EABE 2A BF F1		LHLD	ALOCVECT;and put this into map.
  2446 EAC1 73			MOV	M,E
  2447 EAC2 23			INX	H
  2448 EAC3 72			MOV	M,D
  2449 			;
  2450 			;   End of initialization portion.
  2451 			;
  2452 EAC4 CD A1 E7		CALL	HOMEDRV	;now home the drive.
  2453 EAC7 2A B3 F1		LHLD	SCRATCH1
  2454 EACA 36 03		MVI	M,3	;force next directory request to read
  2455 EACC 23			INX	H	;in a sector.
  2456 EACD 36 00		MVI	M,0
  2457 EACF CD FE E9		CALL	STFILPOS;clear initial file position also.
  2458 EAD2 0E FF	BITMAP2	MVI	C,0FFH	;read next file name in directory
  2459 EAD4 CD 05 EA		CALL	NXENTRY	;and set checksum byte.
  2460 EAD7 CD F5 E9		CALL	CKFILPOS;is there another file?
  2461 EADA C8			RZ
  2462 EADB CD 5E E9		CALL	FCB2HL	;yes, get its address.
  2463 EADE 3E E5		MVI	A,0E5H
  2464 EAE0 BE			CMP	M	;empty file entry?
  2465 EAE1 CA D2 EA		JZ	BITMAP2
  2466 EAE4 3A 41 E7		LDA	USERNO	;no, correct user number?
  2467 EAE7 BE			CMP	M
  2468 EAE8 C2 F6 EA		JNZ	BITMAP3
  2469 EAEB 23			INX	H
  2470 EAEC 7E			MOV	A,M	;yes, does name start with a '$'?
  2471 EAED D6 24		SUI	'$'
  2472 EAEF C2 F6 EA		JNZ	BITMAP3
  2473 EAF2 3D			DCR	A	;yes, set atatus to minus one.
  2474 EAF3 32 45 E7		STA	STATUS
  2475 EAF6 0E 01	BITMAP3	MVI	C,1	;now set this file's space as used in bit map.
  2476 EAF8 CD 6B EA		CALL	SETFILE
  2477 EAFB CD 8C E9		CALL	CHKNMBR	;keep (SCRATCH1) in bounds.
  2478 EAFE C3 D2 EA		JMP	BITMAP2
  2479 			;
  2480 			;   Set the status (STATUS) and return.
  2481 			;
  2482 EB01 3A D4 F1	STSTATUS:LDA	FNDSTAT
  2483 EB04 C3 01 E7		JMP	SETSTAT
  2484 			;
  2485 			;   Check extents in (A) and (C). Set the zero flag if they
  2486 			; are the same. The number of 16k chunks of disk space that
  2487 			; the directory extent covers is expressad is (EXTMASK+1).
  2488 			; No registers are modified.
  2489 			;
  2490 EB07 C5		SAMEXT	PUSH	B
  2491 EB08 F5			PUSH	PSW
  2492 EB09 3A C5 F1		LDA	EXTMASK	;get extent mask and use it to
  2493 EB0C 2F			CMA		;to compare both extent numbers.
  2494 EB0D 47			MOV	B,A	;save resulting mask here.
  2495 EB0E 79			MOV	A,C	;mask first extent and save in (C).
  2496 EB0F A0			ANA	B
  2497 EB10 4F			MOV	C,A
  2498 EB11 F1			POP	PSW	;now mask second extent and compare
  2499 EB12 A0			ANA	B	;with the first one.
  2500 EB13 91			SUB	C
  2501 EB14 E6 1F		ANI	1FH	;(* only check buts 0-4 *)
  2502 EB16 C1			POP	B	;the zero flag is set if they are the same.
  2503 EB17 C9			RET		;restore (BC) and return.
  2504 			;
  2505 			;   Search for the first occurence of a file name. On entry,
  2506 			; register (C) should contain the number of bytes of the fcb
  2507 			; that must match.
  2508 			;
  2509 EB18 3E FF	FINDFST	MVI	A,0FFH
  2510 EB1A 32 D4 F1		STA	FNDSTAT
  2511 EB1D 21 D8 F1		LXI	H,COUNTER;save character count.
  2512 EB20 71			MOV	M,C
  2513 EB21 2A 43 E7		LHLD	PARAMS	;get filename to match.
  2514 EB24 22 D9 F1		SHLD	SAVEFCB	;and save.
  2515 EB27 CD FE E9		CALL	STFILPOS;clear initial file position (set to 0ffffh).
  2516 EB2A CD A1 E7		CALL	HOMEDRV	;home the drive.
  2517 			;
  2518 			;   Entry to locate the next occurence of a filename within the
  2519 			; directory. The disk is not expected to have been changed. If
  2520 			; it was, then it will be write protected.
  2521 			;
  2522 EB2D 0E 00	FINDNXT	MVI	C,0	;write protect the disk if changed.
  2523 EB2F CD 05 EA		CALL	NXENTRY	;get next filename entry in directory.
  2524 EB32 CD F5 E9		CALL	CKFILPOS;is file position = 0ffffh?
  2525 EB35 CA 94 EB		JZ	FNDNXT6	;yes, exit now then.
  2526 EB38 2A D9 F1		LHLD	SAVEFCB	;set (DE) pointing to filename to match.
  2527 EB3B EB			XCHG
  2528 EB3C 1A			LDAX	D
  2529 EB3D FE E5		CPI	0E5H	;empty directory entry?
  2530 EB3F CA 4A EB		JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
  2531 EB42 D5			PUSH	D
  2532 EB43 CD 7F E9		CALL	MOREFLS	;more files in directory?
  2533 EB46 D1			POP	D
  2534 EB47 D2 94 EB		JNC	FNDNXT6	;no more. Exit now.
  2535 EB4A CD 5E E9	FNDNXT1	CALL	FCB2HL	;get address of this fcb in directory.
  2536 EB4D 3A D8 F1		LDA	COUNTER	;get number of bytes (characters) to check.
  2537 EB50 4F			MOV	C,A
  2538 EB51 06 00		MVI	B,0	;initialize byte position counter.
  2539 EB53 79		FNDNXT2	MOV	A,C	;are we done with the compare?
  2540 EB54 B7			ORA	A
  2541 EB55 CA 83 EB		JZ	FNDNXT5
  2542 EB58 1A			LDAX	D	;no, check next byte.
  2543 EB59 FE 3F		CPI	'?'	;don't care about this character?
  2544 EB5B CA 7C EB		JZ	FNDNXT4
  2545 EB5E 78			MOV	A,B	;get bytes position in fcb.
  2546 EB5F FE 0D		CPI	13	;don't care about the thirteenth byte either.
  2547 EB61 CA 7C EB		JZ	FNDNXT4
  2548 EB64 FE 0C		CPI	12	;extent byte?
  2549 EB66 1A			LDAX	D
  2550 EB67 CA 73 EB		JZ	FNDNXT3
  2551 EB6A 96			SUB	M	;otherwise compare characters.
  2552 EB6B E6 7F		ANI	7FH
  2553 EB6D C2 2D EB		JNZ	FINDNXT	;not the same, check next entry.
  2554 EB70 C3 7C EB		JMP	FNDNXT4	;so far so good, keep checking.
  2555 EB73 C5		FNDNXT3	PUSH	B	;check the extent byte here.
  2556 EB74 4E			MOV	C,M
  2557 EB75 CD 07 EB		CALL	SAMEXT
  2558 EB78 C1			POP	B
  2559 EB79 C2 2D EB		JNZ	FINDNXT	;not the same, look some more.
  2560 			;
  2561 			;   So far the names compare. Bump pointers to the next byte
  2562 			; and continue until all (C) characters have been checked.
  2563 			;
  2564 EB7C 13		FNDNXT4	INX	D	;bump pointers.
  2565 EB7D 23			INX	H
  2566 EB7E 04			INR	B
  2567 EB7F 0D			DCR	C	;adjust character counter.
  2568 EB80 C3 53 EB		JMP	FNDNXT2
  2569 EB83 3A EA F1	FNDNXT5	LDA	FILEPOS	;return the position of this entry.
  2570 EB86 E6 03		ANI	03H
  2571 EB88 32 45 E7		STA	STATUS
  2572 EB8B 21 D4 F1		LXI	H,FNDSTAT
  2573 EB8E 7E			MOV	A,M
  2574 EB8F 17			RAL
  2575 EB90 D0			RNC
  2576 EB91 AF			XRA	A
  2577 EB92 77			MOV	M,A
  2578 EB93 C9			RET
  2579 			;
  2580 			;   Filename was not found. Set appropriate status.
  2581 			;
  2582 EB94 CD FE E9	FNDNXT6	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
  2583 EB97 3E FF		MVI	A,0FFH	;say not located.
  2584 EB99 C3 01 E7		JMP	SETSTAT
  2585 			;
  2586 			;   Erase files from the directory. Only the first byte of the
  2587 			; fcb will be affected. It is set to (E5).
  2588 			;
  2589 EB9C CD 54 E9	ERAFILE	CALL	CHKWPRT	;is disk write protected?
  2590 EB9F 0E 0C		MVI	C,12	;only compare file names.
  2591 EBA1 CD 18 EB		CALL	FINDFST	;get first file name.
  2592 EBA4 CD F5 E9	ERAFIL1	CALL	CKFILPOS;any found?
  2593 EBA7 C8			RZ		;nope, we must be done.
  2594 EBA8 CD 44 E9		CALL	CHKROFL	;is file read only?
  2595 EBAB CD 5E E9		CALL	FCB2HL	;nope, get address of fcb and
  2596 EBAE 36 E5		MVI	M,0E5H	;set first byte to 'empty'.
  2597 EBB0 0E 00		MVI	C,0	;clear the space from the bit map.
  2598 EBB2 CD 6B EA		CALL	SETFILE
  2599 EBB5 CD C6 E9		CALL	DIRWRITE;now write the directory sector back out.
  2600 EBB8 CD 2D EB		CALL	FINDNXT	;find the next file name.
  2601 EBBB C3 A4 EB		JMP	ERAFIL1	;and repeat process.
  2602 			;
  2603 			;   Look through the space allocation map (bit map) for the
  2604 			; next available block. Start searching at block number (BC-1).
  2605 			; The search procedure is to look for an empty block that is
  2606 			; before the starting block. If not empty, look at a later
  2607 			; block number. In this way, we return the closest empty block
  2608 			; on either side of the 'target' block number. This will speed
  2609 			; access on random devices. For serial devices, this should be
  2610 			; changed to look in the forward direction first and then start
  2611 			; at the front and search some more.
  2612 			;
  2613 			;   On return, (DE)= block number that is empty and (HL) =0
  2614 			; if no empry block was found.
  2615 			;
  2616 EBBE 50		FNDSPACE:MOV	D,B	;set (DE) as the block that is checked.
  2617 EBBF 59			MOV	E,C
  2618 			;
  2619 			;   Look before target block. Registers (BC) are used as the lower
  2620 			; pointer and (DE) as the upper pointer.
  2621 			;
  2622 EBC0 79		FNDSPA1	MOV	A,C	;is block 0 specified?
  2623 EBC1 B0			ORA	B
  2624 EBC2 CA D1 EB		JZ	FNDSPA2
  2625 EBC5 0B			DCX	B	;nope, check previous block.
  2626 EBC6 D5			PUSH	D
  2627 EBC7 C5			PUSH	B
  2628 EBC8 CD 35 EA		CALL	CKBITMAP
  2629 EBCB 1F			RAR		;is this block empty?
  2630 EBCC D2 EC EB		JNC	FNDSPA3	;yes. use this.
  2631 			;
  2632 			;   Note that the above logic gets the first block that it finds
  2633 			; that is empty. Thus a file could be written 'backward' making
  2634 			; it very slow to access. This could be changed to look for the
  2635 			; first empty block and then continue until the start of this
  2636 			; empty space is located and then used that starting block.
  2637 			; This should help speed up access to some files especially on
  2638 			; a well used disk with lots of fairly small 'holes'.
  2639 			;
  2640 EBCF C1			POP	B	;nope, check some more.
  2641 EBD0 D1			POP	D
  2642 			;
  2643 			;   Now look after target block.
  2644 			;
  2645 EBD1 2A C6 F1	FNDSPA2	LHLD	DSKSIZE	;is block (DE) within disk limits?
  2646 EBD4 7B			MOV	A,E
  2647 EBD5 95			SUB	L
  2648 EBD6 7A			MOV	A,D
  2649 EBD7 9C			SBB	H
  2650 EBD8 D2 F4 EB		JNC	FNDSPA4
  2651 EBDB 13			INX	D	;yes, move on to next one.
  2652 EBDC C5			PUSH	B
  2653 EBDD D5			PUSH	D
  2654 EBDE 42			MOV	B,D
  2655 EBDF 4B			MOV	C,E
  2656 EBE0 CD 35 EA		CALL	CKBITMAP;check it.
  2657 EBE3 1F			RAR		;empty?
  2658 EBE4 D2 EC EB		JNC	FNDSPA3
  2659 EBE7 D1			POP	D	;nope, continue searching.
  2660 EBE8 C1			POP	B
  2661 EBE9 C3 C0 EB		JMP	FNDSPA1
  2662 			;
  2663 			;   Empty block found. Set it as used and return with (HL)
  2664 			; pointing to it (true?).
  2665 			;
  2666 EBEC 17		FNDSPA3	RAL		;reset byte.
  2667 EBED 3C			INR	A	;and set bit 0.
  2668 EBEE CD 64 EA		CALL	STBMAP1	;update bit map.
  2669 EBF1 E1			POP	H	;set return registers.
  2670 EBF2 D1			POP	D
  2671 EBF3 C9			RET
  2672 			;
  2673 			;   Free block was not found. If (BC) is not zero, then we have
  2674 			; not checked all of the disk space.
  2675 			;
  2676 EBF4 79		FNDSPA4	MOV	A,C
  2677 EBF5 B0			ORA	B
  2678 EBF6 C2 C0 EB		JNZ	FNDSPA1
  2679 EBF9 21 00 00		LXI	H,0	;set 'not found' status.
  2680 EBFC C9			RET
  2681 			;
  2682 			;   Move a complete fcb entry into the directory and write it.
  2683 			;
  2684 EBFD 0E 00	FCBSET	MVI	C,0
  2685 EBFF 1E 20		MVI	E,32	;length of each entry.
  2686 			;
  2687 			;   Move (E) bytes from the fcb pointed to by (PARAMS) into
  2688 			; fcb in directory starting at relative byte (C). This updated
  2689 			; directory buffer is then written to the disk.
  2690 			;
  2691 EC01 D5		UPDATE	PUSH	D
  2692 EC02 06 00		MVI	B,0	;set (BC) to relative byte position.
  2693 EC04 2A 43 E7		LHLD	PARAMS	;get address of fcb.
  2694 EC07 09			DAD	B	;compute starting byte.
  2695 EC08 EB			XCHG
  2696 EC09 CD 5E E9		CALL	FCB2HL	;get address of fcb to update in directory.
  2697 EC0C C1			POP	B	;set (C) to number of bytes to change.
  2698 EC0D CD 4F E7		CALL	DE2HL
  2699 EC10 CD C3 E7	UPDATE1	CALL	TRKSEC	;determine the track and sector affected.
  2700 EC13 C3 C6 E9		JMP	DIRWRITE	;then write this sector out.
  2701 			;
  2702 			;   Routine to change the name of all files on the disk with a
  2703 			; specified name. The fcb contains the current name as the
  2704 			; first 12 characters and the new name 16 bytes into the fcb.
  2705 			;
  2706 EC16 CD 54 E9	CHGNAMES:CALL	CHKWPRT	;check for a write protected disk.
  2707 EC19 0E 0C		MVI	C,12	;match first 12 bytes of fcb only.
  2708 EC1B CD 18 EB		CALL	FINDFST	;get first name.
  2709 EC1E 2A 43 E7		LHLD	PARAMS	;get address of fcb.
  2710 EC21 7E			MOV	A,M	;get user number.
  2711 EC22 11 10 00		LXI	D,16	;move over to desired name.
  2712 EC25 19			DAD	D
  2713 EC26 77			MOV	M,A	;keep same user number.
  2714 EC27 CD F5 E9	CHGNAM1	CALL	CKFILPOS;any matching file found?
  2715 EC2A C8			RZ		;no, we must be done.
  2716 EC2B CD 44 E9		CALL	CHKROFL	;check for read only file.
  2717 EC2E 0E 10		MVI	C,16	;start 16 bytes into fcb.
  2718 EC30 1E 0C		MVI	E,12	;and update the first 12 bytes of directory.
  2719 EC32 CD 01 EC		CALL	UPDATE
  2720 EC35 CD 2D EB		CALL	FINDNXT	;get te next file name.
  2721 EC38 C3 27 EC		JMP	CHGNAM1	;and continue.
  2722 			;
  2723 			;   Update a files attributes. The procedure is to search for
  2724 			; every file with the same name as shown in fcb (ignoring bit 7)
  2725 			; and then to update it (which includes bit 7). No other changes
  2726 			; are made.
  2727 			;
  2728 EC3B 0E 0C	SAVEATTR:MVI	C,12	;match first 12 bytes.
  2729 EC3D CD 18 EB		CALL	FINDFST	;look for first filename.
  2730 EC40 CD F5 E9	SAVATR1	CALL	CKFILPOS;was one found?
  2731 EC43 C8			RZ		;nope, we must be done.
  2732 EC44 0E 00		MVI	C,0	;yes, update the first 12 bytes now.
  2733 EC46 1E 0C		MVI	E,12
  2734 EC48 CD 01 EC		CALL	UPDATE	;update filename and write directory.
  2735 EC4B CD 2D EB		CALL	FINDNXT	;and get the next file.
  2736 EC4E C3 40 EC		JMP	SAVATR1	;then continue until done.
  2737 			;
  2738 			;  Open a file (name specified in fcb).
  2739 			;
  2740 EC51 0E 0F	OPENIT	MVI	C,15	;compare the first 15 bytes.
  2741 EC53 CD 18 EB		CALL	FINDFST	;get the first one in directory.
  2742 EC56 CD F5 E9		CALL	CKFILPOS;any at all?
  2743 EC59 C8			RZ
  2744 EC5A CD A6 E8	OPENIT1	CALL	SETEXT	;point to extent byte within users fcb.
  2745 EC5D 7E			MOV	A,M	;and get it.
  2746 EC5E F5			PUSH	PSW	;save it and address.
  2747 EC5F E5			PUSH	H
  2748 EC60 CD 5E E9		CALL	FCB2HL	;point to fcb in directory.
  2749 EC63 EB			XCHG
  2750 EC64 2A 43 E7		LHLD	PARAMS	;this is the users copy.
  2751 EC67 0E 20		MVI	C,32	;move it into users space.
  2752 EC69 D5			PUSH	D
  2753 EC6A CD 4F E7		CALL	DE2HL
  2754 EC6D CD 78 E9		CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
  2755 EC70 D1			POP	D	;now get the extent byte from this fcb.
  2756 EC71 21 0C 00		LXI	H,12
  2757 EC74 19			DAD	D
  2758 EC75 4E			MOV	C,M	;into (C).
  2759 EC76 21 0F 00		LXI	H,15	;now get the record count byte into (B).
  2760 EC79 19			DAD	D
  2761 EC7A 46			MOV	B,M
  2762 EC7B E1			POP	H	;keep the same extent as the user had originally.
  2763 EC7C F1			POP	PSW
  2764 EC7D 77			MOV	M,A
  2765 EC7E 79			MOV	A,C	;is it the same as in the directory fcb?
  2766 EC7F BE			CMP	M
  2767 EC80 78			MOV	A,B	;if yes, then use the same record count.
  2768 EC81 CA 8B EC		JZ	OPENIT2
  2769 EC84 3E 00		MVI	A,0	;if the user specified an extent greater than
  2770 EC86 DA 8B EC		JC	OPENIT2	;the one in the directory, then set record count to 0.
  2771 EC89 3E 80		MVI	A,128	;otherwise set to maximum.
  2772 EC8B 2A 43 E7	OPENIT2	LHLD	PARAMS	;set record count in users fcb to (A).
  2773 EC8E 11 0F 00		LXI	D,15
  2774 EC91 19			DAD	D	;compute relative position.
  2775 EC92 77			MOV	M,A	;and set the record count.
  2776 EC93 C9			RET
  2777 			;
  2778 			;   Move two bytes from (DE) to (HL) if (and only if) (HL)
  2779 			; point to a zero value (16 bit).
  2780 			;   Return with zero flag set it (DE) was moved. Registers (DE)
  2781 			; and (HL) are not changed. However (A) is.
  2782 			;
  2783 EC94 7E		MOVEWORD:MOV	A,M	;check for a zero word.
  2784 EC95 23			INX	H
  2785 EC96 B6			ORA	M	;both bytes zero?
  2786 EC97 2B			DCX	H
  2787 EC98 C0			RNZ		;nope, just return.
  2788 EC99 1A			LDAX	D	;yes, move two bytes from (DE) into
  2789 EC9A 77			MOV	M,A	;this zero space.
  2790 EC9B 13			INX	D
  2791 EC9C 23			INX	H
  2792 EC9D 1A			LDAX	D
  2793 EC9E 77			MOV	M,A
  2794 EC9F 1B			DCX	D	;don't disturb these registers.
  2795 ECA0 2B			DCX	H
  2796 ECA1 C9			RET
  2797 			;
  2798 			;   Get here to close a file specified by (fcb).
  2799 			;
  2800 ECA2 AF		CLOSEIT	XRA	A	;clear status and file position bytes.
  2801 ECA3 32 45 E7		STA	STATUS
  2802 ECA6 32 EA F1		STA	FILEPOS
  2803 ECA9 32 EB F1		STA	FILEPOS+1
  2804 ECAC CD 1E E9		CALL	GETWPRT	;get write protect bit for this drive.
  2805 ECAF C0			RNZ		;just return if it is set.
  2806 ECB0 CD 69 E9		CALL	GETS2	;else get the 's2' byte.
  2807 ECB3 E6 80		ANI	80H	;and look at bit 7 (file unmodified?).
  2808 ECB5 C0			RNZ		;just return if set.
  2809 ECB6 0E 0F		MVI	C,15	;else look up this file in directory.
  2810 ECB8 CD 18 EB		CALL	FINDFST
  2811 ECBB CD F5 E9		CALL	CKFILPOS;was it found?
  2812 ECBE C8			RZ		;just return if not.
  2813 ECBF 01 10 00		LXI	B,16	;set (HL) pointing to records used section.
  2814 ECC2 CD 5E E9		CALL	FCB2HL
  2815 ECC5 09			DAD	B
  2816 ECC6 EB			XCHG
  2817 ECC7 2A 43 E7		LHLD	PARAMS	;do the same for users specified fcb.
  2818 ECCA 09			DAD	B
  2819 ECCB 0E 10		MVI	C,16	;this many bytes are present in this extent.
  2820 ECCD 3A DD F1	CLOSEIT1:LDA	BIGDISK	;8 or 16 bit record numbers?
  2821 ECD0 B7			ORA	A
  2822 ECD1 CA E8 EC		JZ	CLOSEIT4
  2823 ECD4 7E			MOV	A,M	;just 8 bit. Get one from users fcb.
  2824 ECD5 B7			ORA	A
  2825 ECD6 1A			LDAX	D	;now get one from directory fcb.
  2826 ECD7 C2 DB EC		JNZ	CLOSEIT2
  2827 ECDA 77			MOV	M,A	;users byte was zero. Update from directory.
  2828 ECDB B7		CLOSEIT2:ORA	A
  2829 ECDC C2 E1 EC		JNZ	CLOSEIT3
  2830 ECDF 7E			MOV	A,M	;directories byte was zero, update from users fcb.
  2831 ECE0 12			STAX	D
  2832 ECE1 BE		CLOSEIT3:CMP	M	;if neither one of these bytes were zero,
  2833 ECE2 C2 1F ED		JNZ	CLOSEIT7	;then close error if they are not the same.
  2834 ECE5 C3 FD EC		JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
  2835 ECE8 CD 94 EC	CLOSEIT4:CALL	MOVEWORD;update users fcb if it is zero.
  2836 ECEB EB			XCHG
  2837 ECEC CD 94 EC		CALL	MOVEWORD;update directories fcb if it is zero.
  2838 ECEF EB			XCHG
  2839 ECF0 1A			LDAX	D	;if these two values are no different,
  2840 ECF1 BE			CMP	M	;then a close error occured.
  2841 ECF2 C2 1F ED		JNZ	CLOSEIT7
  2842 ECF5 13			INX	D	;check second byte.
  2843 ECF6 23			INX	H
  2844 ECF7 1A			LDAX	D
  2845 ECF8 BE			CMP	M
  2846 ECF9 C2 1F ED		JNZ	CLOSEIT7
  2847 ECFC 0D			DCR	C	;remember 16 bit values.
  2848 ECFD 13		CLOSEIT5:INX	D	;bump to next item in table.
  2849 ECFE 23			INX	H
  2850 ECFF 0D			DCR	C	;there are 16 entries only.
  2851 ED00 C2 CD EC		JNZ	CLOSEIT1;continue if more to do.
  2852 ED03 01 EC FF		LXI	B,0FFECH;backup 20 places (extent byte).
  2853 ED06 09			DAD	B
  2854 ED07 EB			XCHG
  2855 ED08 09			DAD	B
  2856 ED09 1A			LDAX	D
  2857 ED0A BE			CMP	M	;directory's extent already greater than the
  2858 ED0B DA 17 ED		JC	CLOSEIT6	;users extent?
  2859 ED0E 77			MOV	M,A	;no, update directory extent.
  2860 ED0F 01 03 00		LXI	B,3	;and update the record count byte in
  2861 ED12 09			DAD	B	;directories fcb.
  2862 ED13 EB			XCHG
  2863 ED14 09			DAD	B
  2864 ED15 7E			MOV	A,M	;get from user.
  2865 ED16 12			STAX	D	;and put in directory.
  2866 ED17 3E FF	CLOSEIT6:MVI	A,0FFH	;set 'was open and is now closed' byte.
  2867 ED19 32 D2 F1		STA	CLOSEFLG
  2868 ED1C C3 10 EC		JMP	UPDATE1	;update the directory now.
  2869 ED1F 21 45 E7	CLOSEIT7:LXI	H,STATUS;set return status and then return.
  2870 ED22 35			DCR	M
  2871 ED23 C9			RET
  2872 			;
  2873 			;   Routine to get the next empty space in the directory. It
  2874 			; will then be cleared for use.
  2875 			;
  2876 ED24 CD 54 E9	GETEMPTY:CALL	CHKWPRT	;make sure disk is not write protected.
  2877 ED27 2A 43 E7		LHLD	PARAMS	;save current parameters (fcb).
  2878 ED2A E5			PUSH	H
  2879 ED2B 21 AC F1		LXI	H,EMPTYFCB;use special one for empty space.
  2880 ED2E 22 43 E7		SHLD	PARAMS
  2881 ED31 0E 01		MVI	C,1	;search for first empty spot in directory.
  2882 ED33 CD 18 EB		CALL	FINDFST	;(* only check first byte *)
  2883 ED36 CD F5 E9		CALL	CKFILPOS;none?
  2884 ED39 E1			POP	H
  2885 ED3A 22 43 E7		SHLD	PARAMS	;restore original fcb address.
  2886 ED3D C8			RZ		;return if no more space.
  2887 ED3E EB			XCHG
  2888 ED3F 21 0F 00		LXI	H,15	;point to number of records for this file.
  2889 ED42 19			DAD	D
  2890 ED43 0E 11		MVI	C,17	;and clear all of this space.
  2891 ED45 AF			XRA	A
  2892 ED46 77		GETMT1	MOV	M,A
  2893 ED47 23			INX	H
  2894 ED48 0D			DCR	C
  2895 ED49 C2 46 ED		JNZ	GETMT1
  2896 ED4C 21 0D 00		LXI	H,13	;clear the 's1' byte also.
  2897 ED4F 19			DAD	D
  2898 ED50 77			MOV	M,A
  2899 ED51 CD 8C E9		CALL	CHKNMBR	;keep (SCRATCH1) within bounds.
  2900 ED54 CD FD EB		CALL	FCBSET	;write out this fcb entry to directory.
  2901 ED57 C3 78 E9		JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
  2902 			;
  2903 			;   Routine to close the current extent and open the next one
  2904 			; for reading.
  2905 			;
  2906 ED5A AF		GETNEXT	XRA	A
  2907 ED5B 32 D2 F1		STA	CLOSEFLG;clear close flag.
  2908 ED5E CD A2 EC		CALL	CLOSEIT	;close this extent.
  2909 ED61 CD F5 E9		CALL	CKFILPOS
  2910 ED64 C8			RZ		;not there???
  2911 ED65 2A 43 E7		LHLD	PARAMS	;get extent byte.
  2912 ED68 01 0C 00		LXI	B,12
  2913 ED6B 09			DAD	B
  2914 ED6C 7E			MOV	A,M	;and increment it.
  2915 ED6D 3C			INR	A
  2916 ED6E E6 1F		ANI	1FH	;keep within range 0-31.
  2917 ED70 77			MOV	M,A
  2918 ED71 CA 83 ED		JZ	GTNEXT1	;overflow?
  2919 ED74 47			MOV	B,A	;mask extent byte.
  2920 ED75 3A C5 F1		LDA	EXTMASK
  2921 ED78 A0			ANA	B
  2922 ED79 21 D2 F1		LXI	H,CLOSEFLG;check close flag (0ffh is ok).
  2923 ED7C A6			ANA	M
  2924 ED7D CA 8E ED		JZ	GTNEXT2	;if zero, we must read in next extent.
  2925 ED80 C3 AC ED		JMP	GTNEXT3	;else, it is already in memory.
  2926 ED83 01 02 00	GTNEXT1	LXI	B,2	;Point to the 's2' byte.
  2927 ED86 09			DAD	B
  2928 ED87 34			INR	M	;and bump it.
  2929 ED88 7E			MOV	A,M	;too many extents?
  2930 ED89 E6 0F		ANI	0FH
  2931 ED8B CA B6 ED		JZ	GTNEXT5	;yes, set error code.
  2932 			;
  2933 			;   Get here to open the next extent.
  2934 			;
  2935 ED8E 0E 0F	GTNEXT2	MVI	C,15	;set to check first 15 bytes of fcb.
  2936 ED90 CD 18 EB		CALL	FINDFST	;find the first one.
  2937 ED93 CD F5 E9		CALL	CKFILPOS;none available?
  2938 ED96 C2 AC ED		JNZ	GTNEXT3
  2939 ED99 3A D3 F1		LDA	RDWRTFLG;no extent present. Can we open an empty one?
  2940 ED9C 3C			INR	A	;0ffh means reading (so not possible).
  2941 ED9D CA B6 ED		JZ	GTNEXT5	;or an error.
  2942 EDA0 CD 24 ED		CALL	GETEMPTY;we are writing, get an empty entry.
  2943 EDA3 CD F5 E9		CALL	CKFILPOS;none?
  2944 EDA6 CA B6 ED		JZ	GTNEXT5	;error if true.
  2945 EDA9 C3 AF ED		JMP	GTNEXT4	;else we are almost done.
  2946 EDAC CD 5A EC	GTNEXT3	CALL	OPENIT1	;open this extent.
  2947 EDAF CD BB E8	GTNEXT4	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
  2948 EDB2 AF			XRA	A	;clear status and return.
  2949 EDB3 C3 01 E7		JMP	SETSTAT
  2950 			;
  2951 			;   Error in extending the file. Too many extents were needed
  2952 			; or not enough space on the disk.
  2953 			;
  2954 EDB6 CD 05 E7	GTNEXT5	CALL	IOERR1	;set error code, clear bit 7 of 's2'
  2955 EDB9 C3 78 E9		JMP	SETS2B7	;so this is not written on a close.
  2956 			;
  2957 			;   Read a sequential file.
  2958 			;
  2959 EDBC 3E 01	RDSEQ	MVI	A,1	;set sequential access mode.
  2960 EDBE 32 D5 F1		STA	MODE
  2961 EDC1 3E FF	RDSEQ1	MVI	A,0FFH	;don't allow reading unwritten space.
  2962 EDC3 32 D3 F1		STA	RDWRTFLG
  2963 EDC6 CD BB E8		CALL	STRDATA	;put rec# and ext# into fcb.
  2964 EDC9 3A E3 F1		LDA	SAVNREC	;get next record to read.
  2965 EDCC 21 E1 F1		LXI	H,SAVNXT;get number of records in extent.
  2966 EDCF BE			CMP	M	;within this extent?
  2967 EDD0 DA E6 ED		JC	RDSEQ2
  2968 EDD3 FE 80		CPI	128	;no. Is this extent fully used?
  2969 EDD5 C2 FB ED		JNZ	RDSEQ3	;no. End-of-file.
  2970 EDD8 CD 5A ED		CALL	GETNEXT	;yes, open the next one.
  2971 EDDB AF			XRA	A	;reset next record to read.
  2972 EDDC 32 E3 F1		STA	SAVNREC
  2973 EDDF 3A 45 E7		LDA	STATUS	;check on open, successful?
  2974 EDE2 B7			ORA	A
  2975 EDE3 C2 FB ED		JNZ	RDSEQ3	;no, error.
  2976 EDE6 CD 77 E8	RDSEQ2	CALL	COMBLK	;ok. compute block number to read.
  2977 EDE9 CD 84 E8		CALL	CHKBLK	;check it. Within bounds?
  2978 EDEC CA FB ED		JZ	RDSEQ3	;no, error.
  2979 EDEF CD 8A E8		CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
  2980 EDF2 CD D1 E7		CALL	TRKSEC1	;set the track and sector for this block #.
  2981 EDF5 CD B2 E7		CALL	DOREAD	;and read it.
  2982 EDF8 C3 D2 E8		JMP	SETNREC	;and set the next record to be accessed.
  2983 			;
  2984 			;   Read error occured. Set status and return.
  2985 			;
  2986 EDFB C3 05 E7	RDSEQ3	JMP	IOERR1
  2987 			;
  2988 			;   Write the next sequential record.
  2989 			;
  2990 EDFE 3E 01	WTSEQ	MVI	A,1	;set sequential access mode.
  2991 EE00 32 D5 F1		STA	MODE
  2992 EE03 3E 00	WTSEQ1	MVI	A,0	;allow an addition empty extent to be opened.
  2993 EE05 32 D3 F1		STA	RDWRTFLG
  2994 EE08 CD 54 E9		CALL	CHKWPRT	;check write protect status.
  2995 EE0B 2A 43 E7		LHLD	PARAMS
  2996 EE0E CD 47 E9		CALL	CKROF1	;check for read only file, (HL) already set to fcb.
  2997 EE11 CD BB E8		CALL	STRDATA	;put updated data into fcb.
  2998 EE14 3A E3 F1		LDA	SAVNREC	;get record number to write.
  2999 EE17 FE 80		CPI	128	;within range?
  3000 EE19 D2 05 E7		JNC	IOERR1	;no, error(?).
  3001 EE1C CD 77 E8		CALL	COMBLK	;compute block number.
  3002 EE1F CD 84 E8		CALL	CHKBLK	;check number.
  3003 EE22 0E 00		MVI	C,0	;is there one to write to?
  3004 EE24 C2 6E EE		JNZ	WTSEQ6	;yes, go do it.
  3005 EE27 CD 3E E8		CALL	GETBLOCK;get next block number within fcb to use.
  3006 EE2A 32 D7 F1		STA	RELBLOCK;and save.
  3007 EE2D 01 00 00		LXI	B,0	;start looking for space from the start
  3008 EE30 B7			ORA	A	;if none allocated as yet.
  3009 EE31 CA 3B EE		JZ	WTSEQ2
  3010 EE34 4F			MOV	C,A	;extract previous block number from fcb
  3011 EE35 0B			DCX	B	;so we can be closest to it.
  3012 EE36 CD 5E E8		CALL	EXTBLK
  3013 EE39 44			MOV	B,H
  3014 EE3A 4D			MOV	C,L
  3015 EE3B CD BE EB	WTSEQ2	CALL	FNDSPACE;find the next empty block nearest number (BC).
  3016 EE3E 7D			MOV	A,L	;check for a zero number.
  3017 EE3F B4			ORA	H
  3018 EE40 C2 48 EE		JNZ	WTSEQ3
  3019 EE43 3E 02		MVI	A,2	;no more space?
  3020 EE45 C3 01 E7		JMP	SETSTAT
  3021 EE48 22 E5 F1	WTSEQ3	SHLD	BLKNMBR	;save block number to access.
  3022 EE4B EB			XCHG		;put block number into (DE).
  3023 EE4C 2A 43 E7		LHLD	PARAMS	;now we must update the fcb for this
  3024 EE4F 01 10 00		LXI	B,16	;newly allocated block.
  3025 EE52 09			DAD	B
  3026 EE53 3A DD F1		LDA	BIGDISK	;8 or 16 bit block numbers?
  3027 EE56 B7			ORA	A
  3028 EE57 3A D7 F1		LDA	RELBLOCK	;(* update this entry *)
  3029 EE5A CA 64 EE		JZ	WTSEQ4	;zero means 16 bit ones.
  3030 EE5D CD 64 E9		CALL	ADDA2HL	;(HL)=(HL)+(A)
  3031 EE60 73			MOV	M,E	;store new block number.
  3032 EE61 C3 6C EE		JMP	WTSEQ5
  3033 EE64 4F		WTSEQ4	MOV	C,A	;compute spot in this 16 bit table.
  3034 EE65 06 00		MVI	B,0
  3035 EE67 09			DAD	B
  3036 EE68 09			DAD	B
  3037 EE69 73			MOV	M,E	;stuff block number (DE) there.
  3038 EE6A 23			INX	H
  3039 EE6B 72			MOV	M,D
  3040 EE6C 0E 02	WTSEQ5	MVI	C,2	;set (C) to indicate writing to un-used disk space.
  3041 EE6E 3A 45 E7	WTSEQ6	LDA	STATUS	;are we ok so far?
  3042 EE71 B7			ORA	A
  3043 EE72 C0			RNZ
  3044 EE73 C5			PUSH	B	;yes, save write flag for bios (register C).
  3045 EE74 CD 8A E8		CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
  3046 EE77 3A D5 F1		LDA	MODE	;get access mode flag (1=sequential,
  3047 EE7A 3D			DCR	A	;0=random, 2=special?).
  3048 EE7B 3D			DCR	A
  3049 EE7C C2 BB EE		JNZ	WTSEQ9
  3050 			;
  3051 			;   Special random i/o from function #40. Maybe for M/PM, but the
  3052 			; current block, if it has not been written to, will be zeroed
  3053 			; out and then written (reason?).
  3054 			;
  3055 EE7F C1			POP	B
  3056 EE80 C5			PUSH	B
  3057 EE81 79			MOV	A,C	;get write status flag (2=writing unused space).
  3058 EE82 3D			DCR	A
  3059 EE83 3D			DCR	A
  3060 EE84 C2 BB EE		JNZ	WTSEQ9
  3061 EE87 E5			PUSH	H
  3062 EE88 2A B9 F1		LHLD	DIRBUF	;zero out the directory buffer.
  3063 EE8B 57			MOV	D,A	;note that (A) is zero here.
  3064 EE8C 77		WTSEQ7	MOV	M,A
  3065 EE8D 23			INX	H
  3066 EE8E 14			INR	D	;do 128 bytes.
  3067 EE8F F2 8C EE		JP	WTSEQ7
  3068 EE92 CD E0 E9		CALL	DIRDMA	;tell the bios the dma address for directory access.
  3069 EE95 2A E7 F1		LHLD	LOGSECT	;get sector that starts current block.
  3070 EE98 0E 02		MVI	C,2	;set 'writing to unused space' flag.
  3071 EE9A 22 E5 F1	WTSEQ8	SHLD	BLKNMBR	;save sector to write.
  3072 EE9D C5			PUSH	B
  3073 EE9E CD D1 E7		CALL	TRKSEC1	;determine its track and sector numbers.
  3074 EEA1 C1			POP	B
  3075 EEA2 CD B8 E7		CALL	DOWRITE	;now write out 128 bytes of zeros.
  3076 EEA5 2A E5 F1		LHLD	BLKNMBR	;get sector number.
  3077 EEA8 0E 00		MVI	C,0	;set normal write flag.
  3078 EEAA 3A C4 F1		LDA	BLKMASK	;determine if we have written the entire
  3079 EEAD 47			MOV	B,A	;physical block.
  3080 EEAE A5			ANA	L
  3081 EEAF B8			CMP	B
  3082 EEB0 23			INX	H	;prepare for the next one.
  3083 EEB1 C2 9A EE		JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
  3084 EEB4 E1			POP	H	;reset next sector number.
  3085 EEB5 22 E5 F1		SHLD	BLKNMBR
  3086 EEB8 CD DA E9		CALL	DEFDMA	;and reset dma address.
  3087 			;
  3088 			;   Normal disk write. Set the desired track and sector then
  3089 			; do the actual write.
  3090 			;
  3091 EEBB CD D1 E7	WTSEQ9	CALL	TRKSEC1	;determine track and sector for this write.
  3092 EEBE C1			POP	B	;get write status flag.
  3093 EEBF C5			PUSH	B
  3094 EEC0 CD B8 E7		CALL	DOWRITE	;and write this out.
  3095 EEC3 C1			POP	B
  3096 EEC4 3A E3 F1		LDA	SAVNREC	;get number of records in file.
  3097 EEC7 21 E1 F1		LXI	H,SAVNXT;get last record written.
  3098 EECA BE			CMP	M
  3099 EECB DA D2 EE		JC	WTSEQ10
  3100 EECE 77			MOV	M,A	;we have to update record count.
  3101 EECF 34			INR	M
  3102 EED0 0E 02		MVI	C,2
  3103 			;
  3104 			;*   This area has been patched to correct disk update problem
  3105 			;* when using blocking and de-blocking in the BIOS.
  3106 			;
  3107 EED2 00		WTSEQ10	NOP		;was 'dcr c'
  3108 EED3 00			NOP		;was 'dcr c'
  3109 EED4 21 00 00		LXI	H,0	;was 'jnz wtseq99'
  3110 			;
  3111 			; *   End of patch.
  3112 			;
  3113 EED7 F5			PUSH	PSW
  3114 EED8 CD 69 E9		CALL	GETS2	;set 'extent written to' flag.
  3115 EEDB E6 7F		ANI	7FH	;(* clear bit 7 *)
  3116 EEDD 77			MOV	M,A
  3117 EEDE F1			POP	PSW	;get record count for this extent.
  3118 EEDF FE 7F	WTSEQ99	CPI	127	;is it full?
  3119 EEE1 C2 00 EF		JNZ	WTSEQ12
  3120 EEE4 3A D5 F1		LDA	MODE	;yes, are we in sequential mode?
  3121 EEE7 FE 01		CPI	1
  3122 EEE9 C2 00 EF		JNZ	WTSEQ12
  3123 EEEC CD D2 E8		CALL	SETNREC	;yes, set next record number.
  3124 EEEF CD 5A ED		CALL	GETNEXT	;and get next empty space in directory.
  3125 EEF2 21 45 E7		LXI	H,STATUS;ok?
  3126 EEF5 7E			MOV	A,M
  3127 EEF6 B7			ORA	A
  3128 EEF7 C2 FE EE		JNZ	WTSEQ11
  3129 EEFA 3D			DCR	A	;yes, set record count to -1.
  3130 EEFB 32 E3 F1		STA	SAVNREC
  3131 EEFE 36 00	WTSEQ11	MVI	M,0	;clear status.
  3132 EF00 C3 D2 E8	WTSEQ12	JMP	SETNREC	;set next record to access.
  3133 			;
  3134 			;   For random i/o, set the fcb for the desired record number
  3135 			; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
  3136 			; used as follows:
  3137 			;
  3138 			;       fcb+35            fcb+34            fcb+33
  3139 			;  |     'r-2'      |      'r-1'      |      'r-0'     |
  3140 			;  |7             0 | 7             0 | 7             0|
  3141 			;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
  3142 			;  |    overflow   | | extra |  extent   |   record #  |
  3143 			;  | ______________| |_extent|__number___|_____________|
  3144 			;                     also 's2'
  3145 			;
  3146 			;   On entry, register (C) contains 0ffh if this is a read
  3147 			; and thus we can not access unwritten disk space. Otherwise,
  3148 			; another extent will be opened (for writing) if required.
  3149 			;
  3150 EF03 AF		POSITION:XRA	A	;set random i/o flag.
  3151 EF04 32 D5 F1		STA	MODE
  3152 			;
  3153 			;   Special entry (function #40). M/PM ?
  3154 			;
  3155 EF07 C5		POSITN1	PUSH	B	;save read/write flag.
  3156 EF08 2A 43 E7		LHLD	PARAMS	;get address of fcb.
  3157 EF0B EB			XCHG
  3158 EF0C 21 21 00		LXI	H,33	;now get byte 'r0'.
  3159 EF0F 19			DAD	D
  3160 EF10 7E			MOV	A,M
  3161 EF11 E6 7F		ANI	7FH	;keep bits 0-6 for the record number to access.
  3162 EF13 F5			PUSH	PSW
  3163 EF14 7E			MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
  3164 EF15 17			RAL
  3165 EF16 23			INX	H
  3166 EF17 7E			MOV	A,M
  3167 EF18 17			RAL
  3168 EF19 E6 1F		ANI	1FH	;and save this in bits 0-4 of (C).
  3169 EF1B 4F			MOV	C,A	;this is the extent byte.
  3170 EF1C 7E			MOV	A,M	;now get the extra extent byte.
  3171 EF1D 1F			RAR
  3172 EF1E 1F			RAR
  3173 EF1F 1F			RAR
  3174 EF20 1F			RAR
  3175 EF21 E6 0F		ANI	0FH
  3176 EF23 47			MOV	B,A	;and save it in (B).
  3177 EF24 F1			POP	PSW	;get record number back to (A).
  3178 EF25 23			INX	H	;check overflow byte 'r2'.
  3179 EF26 6E			MOV	L,M
  3180 EF27 2C			INR	L
  3181 EF28 2D			DCR	L
  3182 EF29 2E 06		MVI	L,6	;prepare for error.
  3183 EF2B C2 8B EF		JNZ	POSITN5	;out of disk space error.
  3184 EF2E 21 20 00		LXI	H,32	;store record number into fcb.
  3185 EF31 19			DAD	D
  3186 EF32 77			MOV	M,A
  3187 EF33 21 0C 00		LXI	H,12	;and now check the extent byte.
  3188 EF36 19			DAD	D
  3189 EF37 79			MOV	A,C
  3190 EF38 96			SUB	M	;same extent as before?
  3191 EF39 C2 47 EF		JNZ	POSITN2
  3192 EF3C 21 0E 00		LXI	H,14	;yes, check extra extent byte 's2' also.
  3193 EF3F 19			DAD	D
  3194 EF40 78			MOV	A,B
  3195 EF41 96			SUB	M
  3196 EF42 E6 7F		ANI	7FH
  3197 EF44 CA 7F EF		JZ	POSITN3;same, we are almost done then.
  3198 			;
  3199 			;  Get here when another extent is required.
  3200 			;
  3201 EF47 C5		POSITN2	PUSH	B
  3202 EF48 D5			PUSH	D
  3203 EF49 CD A2 EC		CALL	CLOSEIT	;close current extent.
  3204 EF4C D1			POP	D
  3205 EF4D C1			POP	B
  3206 EF4E 2E 03		MVI	L,3	;prepare for error.
  3207 EF50 3A 45 E7		LDA	STATUS
  3208 EF53 3C			INR	A
  3209 EF54 CA 84 EF		JZ	POSITN4	;close error.
  3210 EF57 21 0C 00		LXI	H,12	;put desired extent into fcb now.
  3211 EF5A 19			DAD	D
  3212 EF5B 71			MOV	M,C
  3213 EF5C 21 0E 00		LXI	H,14	;and store extra extent byte 's2'.
  3214 EF5F 19			DAD	D
  3215 EF60 70			MOV	M,B
  3216 EF61 CD 51 EC		CALL	OPENIT	;try and get this extent.
  3217 EF64 3A 45 E7		LDA	STATUS	;was it there?
  3218 EF67 3C			INR	A
  3219 EF68 C2 7F EF		JNZ	POSITN3
  3220 EF6B C1			POP	B	;no. can we create a new one (writing?).
  3221 EF6C C5			PUSH	B
  3222 EF6D 2E 04		MVI	L,4	;prepare for error.
  3223 EF6F 0C			INR	C
  3224 EF70 CA 84 EF		JZ	POSITN4	;nope, reading unwritten space error.
  3225 EF73 CD 24 ED		CALL	GETEMPTY;yes we can, try to find space.
  3226 EF76 2E 05		MVI	L,5	;prepare for error.
  3227 EF78 3A 45 E7		LDA	STATUS
  3228 EF7B 3C			INR	A
  3229 EF7C CA 84 EF		JZ	POSITN4	;out of space?
  3230 			;
  3231 			;   Normal return location. Clear error code and return.
  3232 			;
  3233 EF7F C1		POSITN3	POP	B	;restore stack.
  3234 EF80 AF			XRA	A	;and clear error code byte.
  3235 EF81 C3 01 E7		JMP	SETSTAT
  3236 			;
  3237 			;   Error. Set the 's2' byte to indicate this (why?).
  3238 			;
  3239 EF84 E5		POSITN4	PUSH	H
  3240 EF85 CD 69 E9		CALL	GETS2
  3241 EF88 36 C0		MVI	M,0C0H
  3242 EF8A E1			POP	H
  3243 			;
  3244 			;   Return with error code (presently in L).
  3245 			;
  3246 EF8B C1		POSITN5	POP	B
  3247 EF8C 7D			MOV	A,L	;get error code.
  3248 EF8D 32 45 E7		STA	STATUS
  3249 EF90 C3 78 E9		JMP	SETS2B7
  3250 			;
  3251 			;   Read a random record.
  3252 			;
  3253 EF93 0E FF	READRAN	MVI	C,0FFH	;set 'read' status.
  3254 EF95 CD 03 EF		CALL	POSITION;position the file to proper record.
  3255 EF98 CC C1 ED		CZ	RDSEQ1	;and read it as usual (if no errors).
  3256 EF9B C9			RET
  3257 			;
  3258 			;   Write to a random record.
  3259 			;
  3260 EF9C 0E 00	WRITERAN:MVI	C,0	;set 'writing' flag.
  3261 EF9E CD 03 EF		CALL	POSITION;position the file to proper record.
  3262 EFA1 CC 03 EE		CZ	WTSEQ1	;and write as usual (if no errors).
  3263 EFA4 C9			RET
  3264 			;
  3265 			;   Compute the random record number. Enter with (HL) pointing
  3266 			; to a fcb an (DE) contains a relative location of a record
  3267 			; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
  3268 			; byte, and (A) the 'r2' byte.
  3269 			;
  3270 			;   On return, the zero flag is set if the record is within
  3271 			; bounds. Otherwise, an overflow occured.
  3272 			;
  3273 EFA5 EB		COMPRAND:XCHG		;save fcb pointer in (DE).
  3274 EFA6 19			DAD	D	;compute relative position of record #.
  3275 EFA7 4E			MOV	C,M	;get record number into (BC).
  3276 EFA8 06 00		MVI	B,0
  3277 EFAA 21 0C 00		LXI	H,12	;now get extent.
  3278 EFAD 19			DAD	D
  3279 EFAE 7E			MOV	A,M	;compute (BC)=(record #)+(extent)*128.
  3280 EFAF 0F			RRC		;move lower bit into bit 7.
  3281 EFB0 E6 80		ANI	80H	;and ignore all other bits.
  3282 EFB2 81			ADD	C	;add to our record number.
  3283 EFB3 4F			MOV	C,A
  3284 EFB4 3E 00		MVI	A,0	;take care of any carry.
  3285 EFB6 88			ADC	B
  3286 EFB7 47			MOV	B,A
  3287 EFB8 7E			MOV	A,M	;now get the upper bits of extent into
  3288 EFB9 0F			RRC		;bit positions 0-3.
  3289 EFBA E6 0F		ANI	0FH	;and ignore all others.
  3290 EFBC 80			ADD	B	;add this in to 'r1' byte.
  3291 EFBD 47			MOV	B,A
  3292 EFBE 21 0E 00		LXI	H,14	;get the 's2' byte (extra extent).
  3293 EFC1 19			DAD	D
  3294 EFC2 7E			MOV	A,M
  3295 EFC3 87			ADD	A	;and shift it left 4 bits (bits 4-7).
  3296 EFC4 87			ADD	A
  3297 EFC5 87			ADD	A
  3298 EFC6 87			ADD	A
  3299 EFC7 F5			PUSH	PSW	;save carry flag (bit 0 of flag byte).
  3300 EFC8 80			ADD	B	;now add extra extent into 'r1'.
  3301 EFC9 47			MOV	B,A
  3302 EFCA F5			PUSH	PSW	;and save carry (overflow byte 'r2').
  3303 EFCB E1			POP	H	;bit 0 of (L) is the overflow indicator.
  3304 EFCC 7D			MOV	A,L
  3305 EFCD E1			POP	H	;and same for first carry flag.
  3306 EFCE B5			ORA	L	;either one of these set?
  3307 EFCF E6 01		ANI	01H	;only check the carry flags.
  3308 EFD1 C9			RET
  3309 			;
  3310 			;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
  3311 			; reflect the last record used for a random (or other) file.
  3312 			; This reads the directory and looks at all extents computing
  3313 			; the largerst record number for each and keeping the maximum
  3314 			; value only. Then 'r0', 'r1', and 'r2' will reflect this
  3315 			; maximum record number. This is used to compute the space used
  3316 			; by a random file.
  3317 			;
  3318 EFD2 0E 0C	RANSIZE	MVI	C,12	;look thru directory for first entry with
  3319 EFD4 CD 18 EB		CALL	FINDFST	;this name.
  3320 EFD7 2A 43 E7		LHLD	PARAMS	;zero out the 'r0, r1, r2' bytes.
  3321 EFDA 11 21 00		LXI	D,33
  3322 EFDD 19			DAD	D
  3323 EFDE E5			PUSH	H
  3324 EFDF 72			MOV	M,D	;note that (D)=0.
  3325 EFE0 23			INX	H
  3326 EFE1 72			MOV	M,D
  3327 EFE2 23			INX	H
  3328 EFE3 72			MOV	M,D
  3329 EFE4 CD F5 E9	RANSIZ1	CALL	CKFILPOS;is there an extent to process?
  3330 EFE7 CA 0C F0		JZ	RANSIZ3	;no, we are done.
  3331 EFEA CD 5E E9		CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
  3332 EFED 11 0F 00		LXI	D,15	;point to last record in extent.
  3333 EFF0 CD A5 EF		CALL	COMPRAND;and compute random parameters.
  3334 EFF3 E1			POP	H
  3335 EFF4 E5			PUSH	H	;now check these values against those
  3336 EFF5 5F			MOV	E,A	;already in fcb.
  3337 EFF6 79			MOV	A,C	;the carry flag will be set if those
  3338 EFF7 96			SUB	M	;in the fcb represent a larger size than
  3339 EFF8 23			INX	H	;this extent does.
  3340 EFF9 78			MOV	A,B
  3341 EFFA 9E			SBB	M
  3342 EFFB 23			INX	H
  3343 EFFC 7B			MOV	A,E
  3344 EFFD 9E			SBB	M
  3345 EFFE DA 06 F0		JC	RANSIZ2
  3346 F001 73			MOV	M,E	;we found a larger (in size) extent.
  3347 F002 2B			DCX	H	;stuff these values into fcb.
  3348 F003 70			MOV	M,B
  3349 F004 2B			DCX	H
  3350 F005 71			MOV	M,C
  3351 F006 CD 2D EB	RANSIZ2	CALL	FINDNXT	;now get the next extent.
  3352 F009 C3 E4 EF		JMP	RANSIZ1	;continue til all done.
  3353 F00C E1		RANSIZ3	POP	H	;we are done, restore the stack and
  3354 F00D C9			RET		;return.
  3355 			;
  3356 			;   Function to return the random record position of a given
  3357 			; file which has been read in sequential mode up to now.
  3358 			;
  3359 F00E 2A 43 E7	SETRAN	LHLD	PARAMS	;point to fcb.
  3360 F011 11 20 00		LXI	D,32	;and to last used record.
  3361 F014 CD A5 EF		CALL	COMPRAND;compute random position.
  3362 F017 21 21 00		LXI	H,33	;now stuff these values into fcb.
  3363 F01A 19			DAD	D
  3364 F01B 71			MOV	M,C	;move 'r0'.
  3365 F01C 23			INX	H
  3366 F01D 70			MOV	M,B	;and 'r1'.
  3367 F01E 23			INX	H
  3368 F01F 77			MOV	M,A	;and lastly 'r2'.
  3369 F020 C9			RET
  3370 			;
  3371 			;   This routine select the drive specified in (ACTIVE) and
  3372 			; update the login vector and bitmap table if this drive was
  3373 			; not already active.
  3374 			;
  3375 F021 2A AF F1	LOGINDRV:LHLD	LOGIN	;get the login vector.
  3376 F024 3A 42 E7		LDA	ACTIVE	;get the default drive.
  3377 F027 4F			MOV	C,A
  3378 F028 CD EA E8		CALL	SHIFTR	;position active bit for this drive
  3379 F02B E5			PUSH	H	;into bit 0.
  3380 F02C EB			XCHG
  3381 F02D CD 59 E7		CALL	SELECT	;select this drive.
  3382 F030 E1			POP	H
  3383 F031 CC 47 E7		CZ	SLCTERR	;valid drive?
  3384 F034 7D			MOV	A,L	;is this a newly activated drive?
  3385 F035 1F			RAR
  3386 F036 D8			RC
  3387 F037 2A AF F1		LHLD	LOGIN	;yes, update the login vector.
  3388 F03A 4D			MOV	C,L
  3389 F03B 44			MOV	B,H
  3390 F03C CD 0B E9		CALL	SETBIT
  3391 F03F 22 AF F1		SHLD	LOGIN	;and save.
  3392 F042 C3 A3 EA		JMP	BITMAP	;now update the bitmap.
  3393 			;
  3394 			;   Function to set the active disk number.
  3395 			;
  3396 F045 3A D6 F1	SETDSK	LDA	EPARAM	;get parameter passed and see if this
  3397 F048 21 42 E7		LXI	H,ACTIVE;represents a change in drives.
  3398 F04B BE			CMP	M
  3399 F04C C8			RZ
  3400 F04D 77			MOV	M,A	;yes it does, log it in.
  3401 F04E C3 21 F0		JMP	LOGINDRV
  3402 			;
  3403 			;   This is the 'auto disk select' routine. The firsst byte
  3404 			; of the fcb is examined for a drive specification. If non
  3405 			; zero then the drive will be selected and loged in.
  3406 			;
  3407 F051 3E FF	AUTOSEL	MVI	A,0FFH	;say 'auto-select activated'.
  3408 F053 32 DE F1		STA	AUTO
  3409 F056 2A 43 E7		LHLD	PARAMS	;get drive specified.
  3410 F059 7E			MOV	A,M
  3411 F05A E6 1F		ANI	1FH	;look at lower 5 bits.
  3412 F05C 3D			DCR	A	;adjust for (1=A, 2=B) etc.
  3413 F05D 32 D6 F1		STA	EPARAM	;and save for the select routine.
  3414 F060 FE 1E		CPI	1EH	;check for 'no change' condition.
  3415 F062 D2 75 F0		JNC	AUTOSL1	;yes, don't change.
  3416 F065 3A 42 E7		LDA	ACTIVE	;we must change, save currently active
  3417 F068 32 DF F1		STA	OLDDRV	;drive.
  3418 F06B 7E			MOV	A,M	;and save first byte of fcb also.
  3419 F06C 32 E0 F1		STA	AUTOFLAG;this must be non-zero.
  3420 F06F E6 E0		ANI	0E0H	;whats this for (bits 6,7 are used for
  3421 F071 77			MOV	M,A	;something)?
  3422 F072 CD 45 F0		CALL	SETDSK	;select and log in this drive.
  3423 F075 3A 41 E7	AUTOSL1	LDA	USERNO	;move user number into fcb.
  3424 F078 2A 43 E7		LHLD	PARAMS	;(* upper half of first byte *)
  3425 F07B B6			ORA	M
  3426 F07C 77			MOV	M,A
  3427 F07D C9			RET		;and return (all done).
  3428 			;
  3429 			;   Function to return the current cp/m version number.
  3430 			;
  3431 F07E 3E 22	GETVER	MVI	A,022h	;version 2.2
  3432 F080 C3 01 E7		JMP	SETSTAT
  3433 			;
  3434 			;   Function to reset the disk system.
  3435 			;
  3436 F083 21 00 00	RSTDSK	LXI	H,0	;clear write protect status and log
  3437 F086 22 AD F1		SHLD	WRTPRT	;in vector.
  3438 F089 22 AF F1		SHLD	LOGIN
  3439 F08C AF			XRA	A	;select drive 'A'.
  3440 F08D 32 42 E7		STA	ACTIVE
  3441 F090 21 80 00		LXI	H,TBUFF	;setup default dma address.
  3442 F093 22 B1 F1		SHLD	USERDMA
  3443 F096 CD DA E9		CALL	DEFDMA
  3444 F099 C3 21 F0		JMP	LOGINDRV;now log in drive 'A'.
  3445 			;
  3446 			;   Function to open a specified file.
  3447 			;
  3448 F09C CD 72 E9	OPENFIL	CALL	CLEARS2	;clear 's2' byte.
  3449 F09F CD 51 F0		CALL	AUTOSEL	;select proper disk.
  3450 F0A2 C3 51 EC		JMP	OPENIT	;and open the file.
  3451 			;
  3452 			;   Function to close a specified file.
  3453 			;
  3454 F0A5 CD 51 F0	CLOSEFIL:CALL	AUTOSEL	;select proper disk.
  3455 F0A8 C3 A2 EC		JMP	CLOSEIT	;and close the file.
  3456 			;
  3457 			;   Function to return the first occurence of a specified file
  3458 			; name. If the first byte of the fcb is '?' then the name will
  3459 			; not be checked (get the first entry no matter what).
  3460 			;
  3461 F0AB 0E 00	GETFST	MVI	C,0	;prepare for special search.
  3462 F0AD EB			XCHG
  3463 F0AE 7E			MOV	A,M	;is first byte a '?'?
  3464 F0AF FE 3F		CPI	'?'
  3465 F0B1 CA C2 F0		JZ	GETFST1	;yes, just get very first entry (zero length match).
  3466 F0B4 CD A6 E8		CALL	SETEXT	;get the extension byte from fcb.
  3467 F0B7 7E			MOV	A,M	;is it '?'? if yes, then we want
  3468 F0B8 FE 3F		CPI	'?'	;an entry with a specific 's2' byte.
  3469 F0BA C4 72 E9		CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
  3470 F0BD CD 51 F0		CALL	AUTOSEL	;select proper drive.
  3471 F0C0 0E 0F		MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
  3472 F0C2 CD 18 EB	GETFST1	CALL	FINDFST	;find an entry and then move it into
  3473 F0C5 C3 E9 E9		JMP	MOVEDIR	;the users dma space.
  3474 			;
  3475 			;   Function to return the next occurence of a file name.
  3476 			;
  3477 F0C8 2A D9 F1	GETNXT	LHLD	SAVEFCB	;restore pointers. note that no
  3478 F0CB 22 43 E7		SHLD	PARAMS	;other dbos calls are allowed.
  3479 F0CE CD 51 F0		CALL	AUTOSEL	;no error will be returned, but the
  3480 F0D1 CD 2D EB		CALL	FINDNXT	;results will be wrong.
  3481 F0D4 C3 E9 E9		JMP	MOVEDIR
  3482 			;
  3483 			;   Function to delete a file by name.
  3484 			;
  3485 F0D7 CD 51 F0	DELFILE	CALL	AUTOSEL	;select proper drive.
  3486 F0DA CD 9C EB		CALL	ERAFILE	;erase the file.
  3487 F0DD C3 01 EB		JMP	STSTATUS;set status and return.
  3488 			;
  3489 			;   Function to execute a sequential read of the specified
  3490 			; record number.
  3491 			;
  3492 F0E0 CD 51 F0	READSEQ	CALL	AUTOSEL	;select proper drive then read.
  3493 F0E3 C3 BC ED		JMP	RDSEQ
  3494 			;
  3495 			;   Function to write the net sequential record.
  3496 			;
  3497 F0E6 CD 51 F0	WRTSEQ	CALL	AUTOSEL	;select proper drive then write.
  3498 F0E9 C3 FE ED		JMP	WTSEQ
  3499 			;
  3500 			;   Create a file function.
  3501 			;
  3502 F0EC CD 72 E9	FCREATE	CALL	CLEARS2	;clear the 's2' byte on all creates.
  3503 F0EF CD 51 F0		CALL	AUTOSEL	;select proper drive and get the next
  3504 F0F2 C3 24 ED		JMP	GETEMPTY;empty directory space.
  3505 			;
  3506 			;   Function to rename a file.
  3507 			;
  3508 F0F5 CD 51 F0	RENFILE	CALL	AUTOSEL	;select proper drive and then switch
  3509 F0F8 CD 16 EC		CALL	CHGNAMES;file names.
  3510 F0FB C3 01 EB		JMP	STSTATUS
  3511 			;
  3512 			;   Function to return the login vector.
  3513 			;
  3514 F0FE 2A AF F1	GETLOG	LHLD	LOGIN
  3515 F101 C3 29 F1		JMP	GETPRM1
  3516 			;
  3517 			;   Function to return the current disk assignment.
  3518 			;
  3519 F104 3A 42 E7	GETCRNT	LDA	ACTIVE
  3520 F107 C3 01 E7		JMP	SETSTAT
  3521 			;
  3522 			;   Function to set the dma address.
  3523 			;
  3524 F10A EB		PUTDMA	XCHG
  3525 F10B 22 B1 F1		SHLD	USERDMA	;save in our space and then get to
  3526 F10E C3 DA E9		JMP	DEFDMA	;the bios with this also.
  3527 			;
  3528 			;   Function to return the allocation vector.
  3529 			;
  3530 F111 2A BF F1	GETALOC	LHLD	ALOCVECT
  3531 F114 C3 29 F1		JMP	GETPRM1
  3532 			;
  3533 			;   Function to return the read-only status vector.
  3534 			;
  3535 F117 2A AD F1	GETROV	LHLD	WRTPRT
  3536 F11A C3 29 F1		JMP	GETPRM1
  3537 			;
  3538 			;   Function to set the file attributes (read-only, system).
  3539 			;
  3540 F11D CD 51 F0	SETATTR	CALL	AUTOSEL	;select proper drive then save attributes.
  3541 F120 CD 3B EC		CALL	SAVEATTR
  3542 F123 C3 01 EB		JMP	STSTATUS
  3543 			;
  3544 			;   Function to return the address of the disk parameter block
  3545 			; for the current drive.
  3546 			;
  3547 F126 2A BB F1	GETPARM	LHLD	DISKPB
  3548 F129 22 45 E7	GETPRM1	SHLD	STATUS
  3549 F12C C9			RET
  3550 			;
  3551 			;   Function to get or set the user number. If (E) was (FF)
  3552 			; then this is a request to return the current user number.
  3553 			; Else set the user number from (E).
  3554 			;
  3555 F12D 3A D6 F1	GETUSER	LDA	EPARAM	;get parameter.
  3556 F130 FE FF		CPI	0FFH	;get user number?
  3557 F132 C2 3B F1		JNZ	SETUSER
  3558 F135 3A 41 E7		LDA	USERNO	;yes, just do it.
  3559 F138 C3 01 E7		JMP	SETSTAT
  3560 F13B E6 1F	SETUSER	ANI	1FH	;no, we should set it instead. keep low
  3561 F13D 32 41 E7		STA	USERNO	;bits (0-4) only.
  3562 F140 C9			RET
  3563 			;
  3564 			;   Function to read a random record from a file.
  3565 			;
  3566 F141 CD 51 F0	RDRANDOM:CALL	AUTOSEL	;select proper drive and read.
  3567 F144 C3 93 EF		JMP	READRAN
  3568 			;
  3569 			;   Function to compute the file size for random files.
  3570 			;
  3571 F147 CD 51 F0	WTRANDOM:CALL	AUTOSEL	;select proper drive and write.
  3572 F14A C3 9C EF		JMP	WRITERAN
  3573 			;
  3574 			;   Function to compute the size of a random file.
  3575 			;
  3576 F14D CD 51 F0	FILESIZE:CALL	AUTOSEL	;select proper drive and check file length
  3577 F150 C3 D2 EF		JMP	RANSIZE
  3578 			;
  3579 			;   Function #37. This allows a program to log off any drives.
  3580 			; On entry, set (DE) to contain a word with bits set for those
  3581 			; drives that are to be logged off. The log-in vector and the
  3582 			; write protect vector will be updated. This must be a M/PM
  3583 			; special function.
  3584 			;
  3585 F153 2A 43 E7	LOGOFF	LHLD	PARAMS	;get drives to log off.
  3586 F156 7D			MOV	A,L	;for each bit that is set, we want
  3587 F157 2F			CMA		;to clear that bit in (LOGIN)
  3588 F158 5F			MOV	E,A	;and (WRTPRT).
  3589 F159 7C			MOV	A,H
  3590 F15A 2F			CMA
  3591 F15B 2A AF F1		LHLD	LOGIN	;reset the login vector.
  3592 F15E A4			ANA	H
  3593 F15F 57			MOV	D,A
  3594 F160 7D			MOV	A,L
  3595 F161 A3			ANA	E
  3596 F162 5F			MOV	E,A
  3597 F163 2A AD F1		LHLD	WRTPRT
  3598 F166 EB			XCHG
  3599 F167 22 AF F1		SHLD	LOGIN	;and save.
  3600 F16A 7D			MOV	A,L	;now do the write protect vector.
  3601 F16B A3			ANA	E
  3602 F16C 6F			MOV	L,A
  3603 F16D 7C			MOV	A,H
  3604 F16E A2			ANA	D
  3605 F16F 67			MOV	H,A
  3606 F170 22 AD F1		SHLD	WRTPRT	;and save. all done.
  3607 F173 C9			RET
  3608 			;
  3609 			;   Get here to return to the user.
  3610 			;
  3611 F174 3A DE F1	GOBACK	LDA	AUTO	;was auto select activated?
  3612 F177 B7			ORA	A
  3613 F178 CA 91 F1		JZ	GOBACK1
  3614 F17B 2A 43 E7		LHLD	PARAMS	;yes, but was a change made?
  3615 F17E 36 00		MVI	M,0	;(* reset first byte of fcb *)
  3616 F180 3A E0 F1		LDA	AUTOFLAG
  3617 F183 B7			ORA	A
  3618 F184 CA 91 F1		JZ	GOBACK1
  3619 F187 77			MOV	M,A	;yes, reset first byte properly.
  3620 F188 3A DF F1		LDA	OLDDRV	;and get the old drive and select it.
  3621 F18B 32 D6 F1		STA	EPARAM
  3622 F18E CD 45 F0		CALL	SETDSK
  3623 F191 2A 0F E7	GOBACK1	LHLD	USRSTACK;reset the users stack pointer.
  3624 F194 F9			SPHL
  3625 F195 2A 45 E7		LHLD	STATUS	;get return status.
  3626 F198 7D			MOV	A,L	;force version 1.4 compatability.
  3627 F199 44			MOV	B,H
  3628 F19A C9			RET		;and go back to user.
  3629 			;
  3630 			;   Function #40. This is a special entry to do random i/o.
  3631 			; For the case where we are writing to unused disk space, this
  3632 			; space will be zeroed out first. This must be a M/PM special
  3633 			; purpose function, because why would any normal program even
  3634 			; care about the previous contents of a sector about to be
  3635 			; written over.
  3636 			;
  3637 F19B CD 51 F0	WTSPECL	CALL	AUTOSEL	;select proper drive.
  3638 F19E 3E 02		MVI	A,2	;use special write mode.
  3639 F1A0 32 D5 F1		STA	MODE
  3640 F1A3 0E 00		MVI	C,0	;set write indicator.
  3641 F1A5 CD 07 EF		CALL	POSITN1	;position the file.
  3642 F1A8 CC 03 EE		CZ	WTSEQ1	;and write (if no errors).
  3643 F1AB C9			RET
  3644 			;
  3645 			;**************************************************************
  3646 			;*
  3647 			;*     BDOS data storage pool.
  3648 			;*
  3649 			;**************************************************************
  3650 			;
  3651 F1AC		EMPTYFCB:DB	0E5H	;empty directory segment indicator.
            E5 
  3652 F1AD		WRTPRT	DW	0	;write protect status for all 16 drives.
            0000 
  3653 F1AF		LOGIN	DW	0	;drive active word (1 bit per drive).
            0000 
  3654 F1B1		USERDMA	DW	080H	;user's dma address (defaults to 80h).
            8000 
  3655 			;
  3656 			;   Scratch areas from parameter block.
  3657 			;
  3658 F1B3		SCRATCH1:DW	0	;relative position within dir segment for file (0-3).
            0000 
  3659 F1B5		SCRATCH2:DW	0	;last selected track number.
            0000 
  3660 F1B7		SCRATCH3:DW	0	;last selected sector number.
            0000 
  3661 			;
  3662 			;   Disk storage areas from parameter block.
  3663 			;
  3664 F1B9		DIRBUF	DW	0	;address of directory buffer to use.
            0000 
  3665 F1BB		DISKPB	DW	0	;contains address of disk parameter block.
            0000 
  3666 F1BD		CHKVECT	DW	0	;address of check vector.
            0000 
  3667 F1BF		ALOCVECT:DW	0	;address of allocation vector (bit map).
            0000 
  3668 			;
  3669 			;   Parameter block returned from the bios.
  3670 			;
  3671 F1C1		SECTORS	DW	0	;sectors per track from bios.
            0000 
  3672 F1C3		BLKSHFT	DB	0	;block shift.
            00 
  3673 F1C4		BLKMASK	DB	0	;block mask.
            00 
  3674 F1C5		EXTMASK	DB	0	;extent mask.
            00 
  3675 F1C6		DSKSIZE	DW	0	;disk size from bios (number of blocks-1).
            0000 
  3676 F1C8		DIRSIZE	DW	0	;directory size.
            0000 
  3677 F1CA		ALLOC0	DW	0	;storage for first bytes of bit map (dir space used).
            0000 
  3678 F1CC		ALLOC1	DW	0
            0000 
  3679 F1CE		OFFSET	DW	0	;first usable track number.
            0000 
  3680 F1D0		XLATE	DW	0	;sector translation table address.
            0000 
  3681 			;
  3682 			;
  3683 F1D2		CLOSEFLG:DB	0	;close flag (=0ffh is extent written ok).
            00 
  3684 F1D3		RDWRTFLG:DB	0	;read/write flag (0ffh=read, 0=write).
            00 
  3685 F1D4		FNDSTAT	DB	0	;filename found status (0=found first entry).
            00 
  3686 F1D5		MODE	DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
            00 
  3687 F1D6		EPARAM	DB	0	;storage for register (E) on entry to bdos.
            00 
  3688 F1D7		RELBLOCK:DB	0	;relative position within fcb of block number written.
            00 
  3689 F1D8		COUNTER	DB	0	;byte counter for directory name searches.
            00 
  3690 F1D9		SAVEFCB	DW	0,0	;save space for address of fcb (for directory searches).
            0000 0000 
  3691 F1DD		BIGDISK	DB	0	;if =0 then disk is > 256 blocks long.
            00 
  3692 F1DE		AUTO	DB	0	;if non-zero, then auto select activated.
            00 
  3693 F1DF		OLDDRV	DB	0	;on auto select, storage for previous drive.
            00 
  3694 F1E0		AUTOFLAG:DB	0	;if non-zero, then auto select changed drives.
            00 
  3695 F1E1		SAVNXT	DB	0	;storage for next record number to access.
            00 
  3696 F1E2		SAVEXT	DB	0	;storage for extent number of file.
            00 
  3697 F1E3		SAVNREC	DW	0	;storage for number of records in file.
            0000 
  3698 F1E5		BLKNMBR	DW	0	;block number (physical sector) used within a file or logical sector.
            0000 
  3699 F1E7		LOGSECT	DW	0	;starting logical (128 byte) sector of block (physical sector).
            0000 
  3700 F1E9		FCBPOS	DB	0	;relative position within buffer for fcb of file of interest.
            00 
  3701 F1EA		FILEPOS	DW	0	;files position within directory (0 to max entries -1).
            0000 
  3702 			;
  3703 			;   Disk directory buffer checksum bytes. One for each of the
  3704 			; 16 possible drives.
  3705 			;
  3706 F1EC		CKSUMTBL:DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            
  3707 			;
  3708 			;   Extra space ?
  3709 			;
  3710 F1FC			DB	0,0,0,0
            00 00 00 00 
            
  3711 			;
  3712 			;**************************************************************
  3713 			;*
  3714 			;*        B I O S   J U M P   T A B L E
  3715 			;*
  3716 			;**************************************************************
  3717 			;
  3718 			;BOOT	JMP	0	;NOTE WE USE FAKE DESTINATIONS
  3719 			;WBOOT	JMP	0
  3720 			;CONST	JMP	0
  3721 			;CONIN	JMP	0
  3722 			;CONOUT	JMP	0
  3723 			;LIST	JMP	0
  3724 			;PUNCH	JMP	0
  3725 			;READER	JMP	0
  3726 			;HOME	JMP	0
  3727 			;SELDSK	JMP	0
  3728 			;SETTRK	JMP	0
  3729 			;SETSEC	JMP	0
  3730 			;SETDMA	JMP	0
  3731 			;READ	JMP	0
  3732 			;WRITE	JMP	0
  3733 			;PRSTAT	JMP	0
  3734 			;SECTRN	JMP	0
  3735 			;
  3736 			;*
  3737 			;******************   E N D   O F   C P / M   *****************
  3738 			;*
  3739     			include cpm816bios.asm
     1 			;	skeletal cbios for first level of CP/M 2.0 alteration
     2 			;
     3      00 3E	msize	equ	62		;cp/m version memory size in kilobytes
     4 			;
     5 			;	"bias" is address offset from 3400h for memory systems
     6 			;	than 16k (referred to as"b" throughout the text)
     7 			;
     8      A8 00	bias	equ	(msize-20)*1024
     9      DC 00	ccp	equ	3400h+bias	;base of ccp
    10      E4 06	bdos	equ	ccp+806h	;base of bdos
    11      F2 00	bios	equ	ccp+1600h	;base of bios
    12      00 04	cdisk	equ	0004h		;current disk number 0=a,... l5=p
    13      00 03	iobyte	equ	0003h		;intel i/o byte
    14 			;
    15 			;	org	bios		;origin of this program
    16      00 2C	nsects	equ	($-ccp)/128	;warm start sector count
    17 			;
    18 			;	jump vector for individual subroutines
    19 			;
    20 F200 C3 84 F2	BOOT	jmp	boot	;cold start
    21 F203 C3 8E F2	WBOOT	jmp	wboot	;warm start
    22 F206 C3 F8 F2	CONST	jmp	const	;console status
    23 F209 C3 FB F2	CONIN	jmp	conin	;console character in
    24 F20C C3 16 F3	CONOUT	jmp	conout	;console character out
    25 F20F C3 1A F3	LIST	jmp	list	;list character out
    26 F212 C3 1E F3	PUNCH	jmp	punch	;punch character out
    27 F215 C3 20 F3	READER	jmp	reader	;reader character out
    28 F218 C3 25 F3	HOME	jmp	home	;move head to home position
    29 F21B C3 2B F3	SELDSK	jmp	seldsk	;select disk
    30 F21E C3 44 F3	SETTRK	jmp	settrk	;set track number
    31 F221 C3 4D F3	SETSEC	jmp	setsec	;set sector number
    32 F224 C3 59 F3	SETDMA	jmp	setdma	;set dma address
    33 F227 C3 5F F3	READ	jmp	read	;read disk
    34 F22A C3 63 F3	WRITE	jmp	write	;write disk
    35 F22D C3 1C F3	PRSTAT	jmp	listst	;return list status
    36 F230 C3 56 F3	SECTRN	jmp	sectran	;sector translate
    37
    38 F233		DCB	dw	track
            67F3 
    39 			;
    40 			;	fixed data tables for four-drive standard
    41 			;	ibm-compatible 8" disks
    42 			;
    43 			;	disk Parameter header for disk 00
    44 F235		dpbase:	dw	0000h, 0000h
            0000 0000 
    45 F239			dw	0000h, 0000h
            0000 0000 
    46 F23D			dw	dirbf, dpblk
            6EF3 75F2 
    47 F241			dw	chk00, all00
            6AF4 EEF3 
    48 			;	disk parameter header for disk 01
    49 F245			dw	0000h, 0000h
            0000 0000 
    50 F249			dw	0000h, 0000h
            0000 0000 
    51 F24D			dw	dirbf, dpblk
            6EF3 75F2 
    52 F251			dw	chk01, all01
            7AF4 0DF4 
    53 			;	disk parameter header for disk 02
    54 F255			dw	0000h, 0000h
            0000 0000 
    55 F259			dw	0000h, 0000h
            0000 0000 
    56 F25D			dw	dirbf, dpblk
            6EF3 75F2 
    57 F261			dw	chk02, all02
            8AF4 2CF4 
    58 			;	disk parameter header for disk 03
    59 F265			dw	0000h, 0000h
            0000 0000 
    60 F269			dw	0000h, 0000h
            0000 0000 
    61 F26D			dw	dirbf, dpblk
            6EF3 75F2 
    62 F271			dw	chk03, all03
            9AF4 4BF4 
    63 			;
    64 			;	sector translate vector
    65 			;trans:	db	 1,  7, 13, 19	;sectors  1,  2,  3,  4
    66 			;	db	25,  5, 11, 17	;sectors  5,  6,  7,  6
    67 			;	db	23,  3,  9, 15	;sectors  9, 10, 11, 12
    68 			;	db	21,  2,  8, 14	;sectors 13, 14, 15, 16
    69 			;	db	20, 26,  6, 12	;sectors 17, 18, 19, 20
    70 			;	db	18, 24,  4, 10	;sectors 21, 22, 23, 24
    71 			;	db	16, 22		;sectors 25, 26
    72 			;
    73 			dpblk:	;disk parameter block, common to all disks
    74 F275			dw	26		;sectors per track
            1A00 
    75 F277			db	3		;block shift factor
            03 
    76 F278			db	7		;block mask
            07 
    77 F279			db	0		;null mask
            00 
    78 F27A			dw	242		;disk size-1
            F200 
    79 F27C			dw	63		;directory max
            3F00 
    80 F27E			db	192		;alloc 0
            C0 
    81 F27F			db	0		;alloc 1
            00 
    82 F280			dw	16		;check size
            1000 
    83 F282			dw	2		;track offset
            0200 
    84 			;
    85 			;	end of fixed tables
    86 			;
    87 			;	individual subroutines to perform each function
    88 			boot:	;simplest case is to just perform parameter initialization
    89 F284 AF			xra	a		;zero in the accum
    90 F285 32 03 00		sta	iobyte		;clear the iobyte
    91 F288 32 04 00		sta	cdisk		;select disk zero
    92 F28B C3 D7 F2		jmp	gocpm		;initialize and go to cp/m
    93 			;
    94 			wboot:	;simplest case is to read the disk until all sectors loaded
    95 F28E 31 80 00		lxi	sp, 80h		;use space below buffer for stack
    96 F291 0E 00		mvi	c, 0		;select disk 0
    97 F293 CD 2B F3		call	seldsk
    98 F296 CD 25 F3		call	home		;go to track 00
    99 			;
   100 F299 06 2C		mvi	b, nsects	;b counts * of sectors to load
   101 F29B 0E 00		mvi	c, 0		;c has the current track number
   102 F29D 16 02		mvi	d, 2		;d has the next sector to read
   103 			;	note that we begin by reading track 0, sector 2 since sector 1
   104 			;	contains the cold start loader, which is skipped in a warm start
   105 F29F 21 00 DC		lxi	h, ccp		;base of cp/m (initial load point)
   106 			load1:	;load	one more sector
   107 F2A2 C5			push	b		;save sector count, current track
   108 F2A3 D5			push	d		;save next sector to read
   109 F2A4 E5			push	h		;save dma address
   110 F2A5 4A			mov	c, d		;get sector address to register C
   111 F2A6 CD 4D F3		call	setsec		;set sector address from register C
   112 F2A9 C1			pop	b		;recall dma address to b, C
   113 F2AA C5			push	b		;replace on stack for later recall
   114 F2AB CD 59 F3		call	setdma		;set dma address from b, C
   115 			;
   116 			;	drive set to 0, track set, sector set, dma address set
   117 F2AE CD 5F F3		call	read
   118 F2B1 FE 00		cpi	00h		;any errors?
   119 F2B3 C2 8E F2		jnz	wboot		;retry the entire boot if an error occurs
   120 			;
   121 			;	no error, move to next sector
   122 F2B6 E1			pop	h		;recall dma address
   123 F2B7 11 80 00		lxi	d, 128		;dma=dma+128
   124 F2BA 19			dad	d		;new dma address is in h, l
   125 F2BB D1			pop	d		;recall sector address
   126 F2BC C1			pop	b	;recall number of sectors remaining, and current trk
   127 F2BD 05			dcr	b		;sectors=sectors-1
   128 F2BE CA D7 F2		jz	gocpm		;transfer to cp/m if all have been loaded
   129 			;
   130 			;	more	sectors remain to load, check for track change
   131 F2C1 14			inr	d
   132 F2C2 7A			mov	a,d		;sector=27?, if so, change tracks
   133 F2C3 FE 1B		cpi	27
   134 F2C5 DA A2 F2		jc	load1		;carry generated if sector<27
   135 			;
   136 			;	end of	current track,	go to next track
   137 F2C8 16 01		mvi	d, 1		;begin with first sector of next track
   138 F2CA 0C			inr	c		;track=track+1
   139 			;
   140 			;	save	register state, and change tracks
   141 F2CB C5			push	b
   142 F2CC D5			push	d
   143 F2CD E5			push	h
   144 F2CE CD 44 F3		call	settrk		;track address set from register c
   145 F2D1 E1			pop	h
   146 F2D2 D1			pop	d
   147 F2D3 C1			pop	b
   148 F2D4 C3 A2 F2		jmp	load1		;for another sector
   149 			;
   150 			;	end of	load operation, set parameters and go to cp/m
   151 			gocpm:
   152 F2D7 3E C3		mvi	a, 0c3h		;c3 is a jmp instruction
   153 F2D9 32 00 00		sta	0		;for jmp to wboot
   154 F2DC 21 03 F2		lxi	h, WBOOT	;wboot entry point
   155 F2DF 22 01 00		shld	1		;set address field for jmp at 0
   156 			;
   157 F2E2 32 05 00		sta	5		;for jmp to bdos
   158 F2E5 21 06 E4		lxi	h, bdos		;bdos entry point
   159 F2E8 22 06 00		shld	6		;address field of Jump at 5 to bdos
   160 			;
   161 F2EB 01 80 00		lxi	b, 80h		;default dma address is 80h
   162 F2EE CD 59 F3		call	setdma
   163 			;
   164 			;	ei			;enable the interrupt system
   165 F2F1 3A 04 00		lda	cdisk		;get current disk number
   166 F2F4 4F			mov	c, a		;send to the ccp
   167 F2F5 C3 00 DC		jmp	ccp		;go to cp/m for further processing
   168 			;
   169 			;
   170 			;	simple i/o handlers (must be filled in by user)
   171 			;	in each case, the entry point is provided, with space reserved
   172 			;	to insert your own code
   173 			;
   174 			const:	;console status, return 0ffh if character ready, 00h if not
   175 			;	ds     10h		;space for status subroutine
   176 F2F8 3E 00		mvi    a, 00h
   177 F2FA C9			ret
   178 			;
   179 			conin:	;console character into register a
   180 			;	ds	10h		;space for input routine
   181 F2FB 3A 15 F3		lda	con
   182 F2FE FE 0D		cpi	13
   183 F300 C2 0A F3		jnz	conin1
   184 F303 AF			xra	a
   185 F304 32 15 F3		sta	con
   186 F307 3E 0A		mvi	a, 10
   187 F309 C9			ret
   188 			conin1:
   189 			;	out	0fch
   190 F30A DB 01		in	1
   191 			;	ani	7fh		;strip parity bit
   192 F30C FE 0A		cpi	10
   193 			;	out	0fdh
   194 F30E C0			rnz
   195 			;	out	0fch
   196 F30F 3E 0D		mvi	a, 13
   197 F311 32 15 F3		sta	con	
   198 			;	out	0fdh
   199 F314 C9			ret
   200 				
   201 F315		con:	ds	1
   202 			;
   203 			conout:	;console character output from register c
   204 F316 79			mov	a, c		;get to accumulator
   205 F317 D3 01		out	1
   206 			;	ds	10h		;space for output routine
   207 F319 C9			ret
   208 			;
   209 			list:	;list character from register c
   210 F31A 79			mov	a, c	  	;character to register a
   211 F31B C9			ret		  	;null subroutine
   212 			;
   213 			listst:	;return list status (0 if not ready, 1 if ready)
   214 F31C AF			xra	a	 	;0 is always ok to return
   215 F31D C9			ret
   216 			;
   217 			punch:	;punch	character from	register C
   218 F31E 79			mov	a, c		;character to register a
   219 F31F C9			ret			;null subroutine
   220 			;
   221 			;
   222 			reader:	;reader character into register a from reader device
   223 F320 3E 1A		mvi    a, 1ah		;enter end of file for now (replace later)
   224 F322 E6 7F		ani    7fh		;remember to strip parity bit
   225 F324 C9			ret
   226 			;
   227 			;
   228 			;	i/o drivers for the disk follow
   229 			;	for now, we will simply store the parameters away for use
   230 			;	in the read and write	subroutines
   231 			;
   232 			home:	;move to the track 00	position of current drive
   233 			;	translate this call into a settrk call with Parameter 00
   234 F325 0E 00		mvi    c, 0		;select track 0
   235 F327 CD 44 F3		call   settrk
   236 F32A C9			ret			;we will move to 00 on first read/write
   237 			;
   238 			seldsk:	;select disk given by register c
   239 F32B 21 00 00		lxi	h, 0000h	;error return code
   240 F32E 79			mov	a, c
   241 F32F 32 6D F3		sta	diskno
   242 F332 FE 04		cpi	4		;must be between 0 and 3
   243 F334 D0			rnc			;no carry if 4, 5,...
   244 			;	disk number is in the proper range
   245 			;	ds	10		;space for disk select
   246 			;	compute proper disk Parameter header address
   247 F335 3A 6D F3		lda	diskno
   248 F338 6F			mov	l, a		;l=disk number 0, 1, 2, 3
   249 F339 26 00		mvi	h, 0		;high order zero
   250 F33B 29			dad	h		;*2
   251 F33C 29			dad	h		;*4
   252 F33D 29			dad	h		;*8
   253 F33E 29			dad	h		;*16 (size of each header)
   254 F33F 11 35 F2		lxi	d, dpbase
   255 F342 19			dad	d		;hl=,dpbase (diskno*16)
   256 F343 C9			ret
   257 			;
   258 			settrk:	;set track given by register c
   259 F344 79			mov	a, c
   260 F345 32 67 F3		sta	track
   261 F348 AF			xra	a
   262 F349 32 68 F3		sta	track+1
   263 			;	ds	10h		;space for track select
   264 F34C C9			ret
   265 			;
   266 			setsec:	;set sector given by register c
   267 F34D 79			mov	a, c
   268 F34E 32 69 F3		sta	sector
   269 F351 AF			xra	a
   270 F352 32 6A F3		sta	sector+1
   271 			;	ds	10h		;space for sector select
   272 F355 C9			ret
   273 			;
   274 			;
   275 			sectran:
   276 				;translate the sector given by bc using the
   277 				;translate table given by de
   278 			;	xchg			;hl=.trans
   279 			;	dad	b		;hl=.trans (sector)
   280 			;	out	0fch
   281 F356 69			mov	l, c		;l=trans (sector)
   282 F357 60			mov	h, b		;hl=trans (sector)
   283 			;	out	0fdh
   284 F358 C9			ret			;with value in hl
   285 			;
   286 			setdma:	;set	dma address given by registers b and c
   287 F359 69			mov	l, c		;low order address
   288 F35A 60			mov	h, b		;high order address
   289 F35B 22 6B F3		shld	dmaad		;save the address
   290 			;	ds	10h		;space for setting the dma address
   291 F35E C9			ret
   292 			;
   293 			read:	;perform read operation (usually this is similar to write
   294 			;	so we will allow space to set up read command, then use
   295 			;	common code in write)
   296 			;	ds	10h		;set up read command
   297 			;	jmp	waitio		;to perform the actual i/o
   298 F35F DB 02		in	2
   299 F361 AF			xra	a
   300 F362 C9			ret
   301 			;
   302 			write:	;perform a write operation
   303 F363 D3 02		out	2
   304 F365 AF			xra	a
   305 F366 C9			ret
   306 			;
   307 			;	ds	10h		;set up write command
   308 			;
   309 			waitio:	;enter	here from read	and write to perform the actual i/o
   310 			;	operation. return a 00h in register a if the operation completes
   311 			;	properly, and 0lh if an error occurs during the read or write
   312 			;
   313 			;	in this case, we have saved the disk number in 'diskno' (0, 1)
   314 			;			the track number in 'track' (0-76)
   315 			;			the sector number in 'sector' (1-26)
   316 			;			the dma address in 'dmaad' (0-65535)
   317 			;	ds	256		;space reserved for i/o drivers
   318 			;	mvi	a, 1		;error condition
   319 			;	ret			;replaced when filled-in
   320 			;
   321 			;	the remainder of the cbios is reserved uninitialized
   322 			;	data area, and does not need to be a Part of the
   323 			;	system	memory image (the space must be available,
   324 			;	however, between"begdat" and"enddat").
   325 			;
   326 F367		track:	ds	2		;two bytes for expansion
   327 F369		sector:	ds	2		;two bytes for expansion
   328 F36B		dmaad:	ds	2		;direct memory address
   329 F36D		diskno:	ds	1		;disk number 0-15
   330 			;
   331 			;	scratch ram area for bdos use
   332      F3 6E	begdat	equ	$	 	;beginning of data area
   333 F36E		dirbf:	ds	128	 	;scratch directory area
   334 F3EE		all00:	ds	31	 	;allocation vector 0
   335 F40D		all01:	ds	31	 	;allocation vector 1
   336 F42C		all02:	ds	31	 	;allocation vector 2
   337 F44B		all03:	ds	31	 	;allocation vector 3
   338 F46A		chk00:	ds	16		;check vector 0
   339 F47A		chk01:	ds	16		;check vector 1
   340 F48A		chk02:	ds	16	 	;check vector 2
   341 F49A		chk03:	ds	16	 	;check vector 3
   342 			;
   343      F4 AA	enddat	equ	$	 	;end of data area
   344      01 3C	datsiz	equ	$-begdat;	;size of data area
   345 				;end
  3740     			end


*******************************************************************************
                                 Symbols table
*******************************************************************************

Names			Types	Values
-----			-----	------
MEM			EQU	0003Eh
IOBYTE			EQU	00003h
TDRIVE			EQU	00004h
ENTRY			EQU	00005h
TFCB			EQU	0005Ch
TBUFF			EQU	00080h
TBASE			EQU	00100h
CNTRLC			EQU	00003h
CNTRLE			EQU	00005h
BS			EQU	00008h
TAB			EQU	00009h
LF			EQU	0000Ah
FF			EQU	0000Ch
CR			EQU	0000Dh
CNTRLP			EQU	00010h
CNTRLR			EQU	00012h
CNTRLS			EQU	00013h
CNTRLU			EQU	00015h
CNTRLX			EQU	00018h
CNTRLZ			EQU	0001Ah
DEL			EQU	0007Fh
NUMCMDS			EQU	00006h
CCPSTACK		EQU	0E3ABh
NFUNCTS			EQU	00029h
STKAREA			EQU	0E741h
msize			EQU	0003Eh
bias			EQU	0A800h
ccp			EQU	0DC00h
bdos			EQU	0E406h
bios			EQU	0F200h
cdisk			EQU	00004h
iobyte			EQU	00003h
nsects			EQU	0002Ch
begdat			EQU	0F36Eh
enddat			EQU	0F4AAh
datsiz			EQU	0013Ch
CBASE			Label	0DC00h
INBUFF			Label	0DC06h
INPOINT			Label	0DC88h
NAMEPNT			Label	0DC8Ah
PRINT			Label	0DC8Ch
PRINTB			Label	0DC92h
CRLF			Label	0DC98h
SPACE			Label	0DCA2h
PLINE			Label	0DCA7h
PLINE2			Label	0DCACh
RESDSK			Label	0DCB8h
DSKSEL			Label	0DCBDh
ENTRY1			Label	0DCC3h
OPEN			Label	0DCCBh
OPENFCB			Label	0DCD0h
CLOSE			Label	0DCDAh
SRCHFST			Label	0DCDFh
SRCHNXT			Label	0DCE4h
SRCHFCB			Label	0DCE9h
DELETE			Label	0DCEFh
ENTRY2			Label	0DCF4h
RDREC			Label	0DCF9h
READFCB			Label	0DCFEh
WRTREC			Label	0DD04h
CREATE			Label	0DD09h
RENAM			Label	0DD0Eh
GETUSR			Label	0DD13h
GETSETUC		Label	0DD15h
SETCDRV			Label	0DD1Ah
MOVECD			Label	0DD29h
UPPER			Label	0DD30h
GETINP			Label	0DD39h
GETINP1			Label	0DD96h
GETINP2			Label	0DDA7h
GETINP3			Label	0DDABh
GETINP4			Label	0DDBAh
CHKCON			Label	0DDC2h
GETDSK			Label	0DDD0h
STDDMA			Label	0DDD5h
DMASET			Label	0DDD8h
DELBATCH		Label	0DDDDh
VERIFY			Label	0DDF5h
VERIFY1			Label	0DDFDh
SYNERR			Label	0DE09h
SYNERR1			Label	0DE0Fh
SYNERR2			Label	0DE22h
CHECK			Label	0DE30h
NONBLANK		Label	0DE4Fh
ADDHL			Label	0DE59h
CONVFST			Label	0DE5Eh
CONVERT			Label	0DE60h
CONVRT1			Label	0DE89h
CONVRT2			Label	0DE90h
CONVRT3			Label	0DE96h
CONVRT4			Label	0DE98h
CONVRT5			Label	0DEA9h
CONVRT6			Label	0DEABh
CONVRT7			Label	0DEAFh
CONVRT8			Label	0DEB9h
GETEXT			Label	0DEC0h
GETEXT1			Label	0DEC8h
GETEXT2			Label	0DED9h
GETEXT3			Label	0DEDBh
GETEXT4			Label	0DEDFh
GETEXT5			Label	0DEE9h
GETEXT6			Label	0DEF0h
GETEXT7			Label	0DEF2h
GETEXT8			Label	0DF01h
GETEXT9			Label	0DF09h
CMDTBL			Label	0DF10h
PATTRN1			Label	0DF28h
SEARCH			Label	0DF2Eh
SEARCH1			Label	0DF33h
SEARCH2			Label	0DF3Ch
SEARCH3			Label	0DF4Fh
SEARCH4			Label	0DF54h
CLEARBUF		Label	0DF58h
COMMAND			Label	0DF5Ch
CMMND1			Label	0DF82h
CMMND2			Label	0DF98h
CMDADR			Label	0DFC1h
HALT			Label	0DFCFh
RDERROR			Label	0DFD9h
RDERR			Label	0DFDFh
NONE			Label	0DFEAh
NOFILE			Label	0DFF0h
DECODE			Label	0DFF8h
DECODE1			Label	0E008h
DECODE2			Label	0E02Ah
DECODE3			Label	0E033h
DECODE4			Label	0E03Ah
MOVE3			Label	0E040h
HL2DE			Label	0E042h
EXTRACT			Label	0E04Bh
DSELECT			Label	0E054h
RESETDR			Label	0E066h
DIRECT			Label	0E077h
DIRECT1			Label	0E088h
DIRECT2			Label	0E08Fh
DIRECT3			Label	0E098h
DIRECT4			Label	0E0CCh
DIRECT5			Label	0E0D4h
DIRECT6			Label	0E0D9h
DRECT63			Label	0E0F7h
DRECT65			Label	0E0F9h
DIRECT7			Label	0E10Eh
DIRECT8			Label	0E10Fh
DIRECT9			Label	0E11Bh
ERASE			Label	0E11Fh
ERASE1			Label	0E142h
YESNO			Label	0E152h
TYPE			Label	0E15Dh
TYPE1			Label	0E174h
TYPE2			Label	0E177h
TYPE3			Label	0E187h
TYPE4			Label	0E1A0h
TYPE5			Label	0E1A7h
SAVE			Label	0E1ADh
SAVE1			Label	0E1D4h
SAVE2			Label	0E1F1h
SAVE3			Label	0E1FBh
SAVE4			Label	0E201h
NOSPACE			Label	0E207h
RENAME			Label	0E210h
RENAME1			Label	0E23Fh
RENAME2			Label	0E259h
RENAME3			Label	0E25Eh
RENAME4			Label	0E26Dh
RENAME5			Label	0E273h
RENAME6			Label	0E279h
EXISTS			Label	0E282h
USER			Label	0E28Eh
UNKNOWN			Label	0E2A5h
UNKWN1			Label	0E2C4h
UNKWN2			Label	0E2CDh
UNKWN3			Label	0E2E1h
UNKWN4			Label	0E301h
UNKWN5			Label	0E330h
UNKWN6			Label	0E33Eh
UNKWN7			Label	0E343h
UNKWN8			Label	0E34Fh
UNKWN9			Label	0E36Bh
UNKWN0			Label	0E371h
BADLOAD			Label	0E37Ah
COMFILE			Label	0E383h
GETBACK			Label	0E386h
GETBACK1		Label	0E389h
BATCH			Label	0E3ABh
BATCHFCB		Label	0E3ACh
FCB			Label	0E3CDh
RTNCODE			Label	0E3EEh
CDRIVE			Label	0E3EFh
CHGDRV			Label	0E3F0h
NBYTES			Label	0E3F1h
PATTRN2			Label	0E400h
FBASE			Label	0E406h
BADSCTR			Label	0E409h
BADSLCT			Label	0E40Bh
RODISK			Label	0E40Dh
ROFILE			Label	0E40Fh
FBASE1			Label	0E411h
FUNCTNS			Label	0E447h
ERROR1			Label	0E499h
ERROR2			Label	0E4A5h
ERROR3			Label	0E4ABh
ERROR4			Label	0E4B1h
ERROR5			Label	0E4B4h
BDOSERR			Label	0E4BAh
BDOSDRV			Label	0E4C6h
BADSEC			Label	0E4CAh
BADSEL			Label	0E4D5h
FILERO			Label	0E4DCh
DISKRO			Label	0E4E1h
PRTERR			Label	0E4E5h
GETCHAR			Label	0E4FBh
GETECHO			Label	0E506h
CHKCHAR			Label	0E514h
CKCONSOL		Label	0E523h
CKCON1			Label	0E542h
CKCON2			Label	0E545h
OUTCHAR			Label	0E548h
OUTCHR1			Label	0E562h
OUTCHR2			Label	0E579h
SHOWIT			Label	0E57Fh
OUTCON			Label	0E590h
OUTCON1			Label	0E596h
BACKUP			Label	0E5A4h
BACKUP1			Label	0E5ACh
NEWLINE			Label	0E5B1h
NEWLN1			Label	0E5B9h
OUTCRLF			Label	0E5C9h
PRTMESG			Label	0E5D3h
RDBUFF			Label	0E5E1h
RDBUF1			Label	0E5EFh
RDBUF2			Label	0E5F1h
RDBUF3			Label	0E616h
RDBUF4			Label	0E626h
RDBUF5			Label	0E637h
RDBUF6			Label	0E648h
RDBUF7			Label	0E64Eh
RDBUF8			Label	0E65Fh
RDBUF9			Label	0E66Bh
RDBUF10			Label	0E670h
RDBUF11			Label	0E678h
RDBUF12			Label	0E68Ah
RDBUF13			Label	0E699h
RDBUF14			Label	0E6A6h
RDBUF15			Label	0E6A9h
RDBUF16			Label	0E6BDh
RDBUF17			Label	0E6C1h
GETCON			Label	0E6C8h
GETRDR			Label	0E6CEh
DIRCIO			Label	0E6D4h
DIRC1			Label	0E6E0h
GETIOB			Label	0E6EDh
SETIOB			Label	0E6F3h
PRTSTR			Label	0E6F8h
GETCSTS			Label	0E6FEh
SETSTAT			Label	0E701h
RTN			Label	0E704h
IOERR1			Label	0E705h
OUTFLAG			Label	0E70Ah
STARTING		Label	0E70Bh
CURPOS			Label	0E70Ch
PRTFLAG			Label	0E70Dh
CHARBUF			Label	0E70Eh
USRSTACK		Label	0E70Fh
USERNO			Label	0E741h
ACTIVE			Label	0E742h
PARAMS			Label	0E743h
STATUS			Label	0E745h
SLCTERR			Label	0E747h
JUMPHL			Label	0E74Ah
DE2HL			Label	0E74Fh
DE2HL1			Label	0E750h
SELECT			Label	0E759h
SELECT1			Label	0E79Dh
HOMEDRV			Label	0E7A1h
DOREAD			Label	0E7B2h
DOWRITE			Label	0E7B8h
IORET			Label	0E7BBh
TRKSEC			Label	0E7C3h
TRKSEC1			Label	0E7D1h
TRKSEC2			Label	0E7E4h
TRKSEC3			Label	0E7FAh
TRKSEC4			Label	0E80Fh
GETBLOCK		Label	0E83Eh
GETBLK1			Label	0E845h
GETBLK2			Label	0E853h
GETBLK3			Label	0E85Ch
EXTBLK			Label	0E85Eh
EXTBLK1			Label	0E871h
COMBLK			Label	0E877h
CHKBLK			Label	0E884h
LOGICAL			Label	0E88Ah
LOGICL1			Label	0E890h
SETEXT			Label	0E8A6h
SETHLDE			Label	0E8AEh
STRDATA			Label	0E8BBh
SETNREC			Label	0E8D2h
STNREC1			Label	0E8DEh
SHIFTR			Label	0E8EAh
SHIFTR1			Label	0E8EBh
CHECKSUM		Label	0E8F7h
CHKSUM1			Label	0E8FDh
SHIFTL			Label	0E904h
SHIFTL1			Label	0E905h
SETBIT			Label	0E90Bh
GETWPRT			Label	0E91Eh
WRTPRTD			Label	0E92Ch
CHKROFL			Label	0E944h
CKROF1			Label	0E947h
CHKWPRT			Label	0E954h
FCB2HL			Label	0E95Eh
ADDA2HL			Label	0E964h
GETS2			Label	0E969h
CLEARS2			Label	0E972h
SETS2B7			Label	0E978h
MOREFLS			Label	0E97Fh
CHKNMBR			Label	0E98Ch
SUBHL			Label	0E995h
SETDIR			Label	0E99Ch
CHECKDIR		Label	0E99Eh
CHKDIR1			Label	0E9C4h
DIRWRITE		Label	0E9C6h
DIRREAD			Label	0E9D4h
DEFDMA			Label	0E9DAh
DIRDMA			Label	0E9E0h
DIRDMA1			Label	0E9E3h
MOVEDIR			Label	0E9E9h
CKFILPOS		Label	0E9F5h
STFILPOS		Label	0E9FEh
NXENTRY			Label	0EA05h
NXENT1			Label	0EA19h
NXENT2			Label	0EA20h
CKBITMAP		Label	0EA35h
CKBMAP1			Label	0EA56h
STBITMAP		Label	0EA5Ch
STBMAP1			Label	0EA64h
SETFILE			Label	0EA6Bh
SETFL1			Label	0EA75h
SETFL2			Label	0EA88h
SETFL3			Label	0EA8Eh
SETFL4			Label	0EA9Dh
BITMAP			Label	0EAA3h
BITMAP1			Label	0EAB1h
BITMAP2			Label	0EAD2h
BITMAP3			Label	0EAF6h
STSTATUS		Label	0EB01h
SAMEXT			Label	0EB07h
FINDFST			Label	0EB18h
FINDNXT			Label	0EB2Dh
FNDNXT1			Label	0EB4Ah
FNDNXT2			Label	0EB53h
FNDNXT3			Label	0EB73h
FNDNXT4			Label	0EB7Ch
FNDNXT5			Label	0EB83h
FNDNXT6			Label	0EB94h
ERAFILE			Label	0EB9Ch
ERAFIL1			Label	0EBA4h
FNDSPACE		Label	0EBBEh
FNDSPA1			Label	0EBC0h
FNDSPA2			Label	0EBD1h
FNDSPA3			Label	0EBECh
FNDSPA4			Label	0EBF4h
FCBSET			Label	0EBFDh
UPDATE			Label	0EC01h
UPDATE1			Label	0EC10h
CHGNAMES		Label	0EC16h
CHGNAM1			Label	0EC27h
SAVEATTR		Label	0EC3Bh
SAVATR1			Label	0EC40h
OPENIT			Label	0EC51h
OPENIT1			Label	0EC5Ah
OPENIT2			Label	0EC8Bh
MOVEWORD		Label	0EC94h
CLOSEIT			Label	0ECA2h
CLOSEIT1		Label	0ECCDh
CLOSEIT2		Label	0ECDBh
CLOSEIT3		Label	0ECE1h
CLOSEIT4		Label	0ECE8h
CLOSEIT5		Label	0ECFDh
CLOSEIT6		Label	0ED17h
CLOSEIT7		Label	0ED1Fh
GETEMPTY		Label	0ED24h
GETMT1			Label	0ED46h
GETNEXT			Label	0ED5Ah
GTNEXT1			Label	0ED83h
GTNEXT2			Label	0ED8Eh
GTNEXT3			Label	0EDACh
GTNEXT4			Label	0EDAFh
GTNEXT5			Label	0EDB6h
RDSEQ			Label	0EDBCh
RDSEQ1			Label	0EDC1h
RDSEQ2			Label	0EDE6h
RDSEQ3			Label	0EDFBh
WTSEQ			Label	0EDFEh
WTSEQ1			Label	0EE03h
WTSEQ2			Label	0EE3Bh
WTSEQ3			Label	0EE48h
WTSEQ4			Label	0EE64h
WTSEQ5			Label	0EE6Ch
WTSEQ6			Label	0EE6Eh
WTSEQ7			Label	0EE8Ch
WTSEQ8			Label	0EE9Ah
WTSEQ9			Label	0EEBBh
WTSEQ10			Label	0EED2h
WTSEQ99			Label	0EEDFh
WTSEQ11			Label	0EEFEh
WTSEQ12			Label	0EF00h
POSITION		Label	0EF03h
POSITN1			Label	0EF07h
POSITN2			Label	0EF47h
POSITN3			Label	0EF7Fh
POSITN4			Label	0EF84h
POSITN5			Label	0EF8Bh
READRAN			Label	0EF93h
WRITERAN		Label	0EF9Ch
COMPRAND		Label	0EFA5h
RANSIZE			Label	0EFD2h
RANSIZ1			Label	0EFE4h
RANSIZ2			Label	0F006h
RANSIZ3			Label	0F00Ch
SETRAN			Label	0F00Eh
LOGINDRV		Label	0F021h
SETDSK			Label	0F045h
AUTOSEL			Label	0F051h
AUTOSL1			Label	0F075h
GETVER			Label	0F07Eh
RSTDSK			Label	0F083h
OPENFIL			Label	0F09Ch
CLOSEFIL		Label	0F0A5h
GETFST			Label	0F0ABh
GETFST1			Label	0F0C2h
GETNXT			Label	0F0C8h
DELFILE			Label	0F0D7h
READSEQ			Label	0F0E0h
WRTSEQ			Label	0F0E6h
FCREATE			Label	0F0ECh
RENFILE			Label	0F0F5h
GETLOG			Label	0F0FEh
GETCRNT			Label	0F104h
PUTDMA			Label	0F10Ah
GETALOC			Label	0F111h
GETROV			Label	0F117h
SETATTR			Label	0F11Dh
GETPARM			Label	0F126h
GETPRM1			Label	0F129h
GETUSER			Label	0F12Dh
SETUSER			Label	0F13Bh
RDRANDOM		Label	0F141h
WTRANDOM		Label	0F147h
FILESIZE		Label	0F14Dh
LOGOFF			Label	0F153h
GOBACK			Label	0F174h
GOBACK1			Label	0F191h
WTSPECL			Label	0F19Bh
EMPTYFCB		Label	0F1ACh
WRTPRT			Label	0F1ADh
LOGIN			Label	0F1AFh
USERDMA			Label	0F1B1h
SCRATCH1		Label	0F1B3h
SCRATCH2		Label	0F1B5h
SCRATCH3		Label	0F1B7h
DIRBUF			Label	0F1B9h
DISKPB			Label	0F1BBh
CHKVECT			Label	0F1BDh
ALOCVECT		Label	0F1BFh
SECTORS			Label	0F1C1h
BLKSHFT			Label	0F1C3h
BLKMASK			Label	0F1C4h
EXTMASK			Label	0F1C5h
DSKSIZE			Label	0F1C6h
DIRSIZE			Label	0F1C8h
ALLOC0			Label	0F1CAh
ALLOC1			Label	0F1CCh
OFFSET			Label	0F1CEh
XLATE			Label	0F1D0h
CLOSEFLG		Label	0F1D2h
RDWRTFLG		Label	0F1D3h
FNDSTAT			Label	0F1D4h
MODE			Label	0F1D5h
EPARAM			Label	0F1D6h
RELBLOCK		Label	0F1D7h
COUNTER			Label	0F1D8h
SAVEFCB			Label	0F1D9h
BIGDISK			Label	0F1DDh
AUTO			Label	0F1DEh
OLDDRV			Label	0F1DFh
AUTOFLAG		Label	0F1E0h
SAVNXT			Label	0F1E1h
SAVEXT			Label	0F1E2h
SAVNREC			Label	0F1E3h
BLKNMBR			Label	0F1E5h
LOGSECT			Label	0F1E7h
FCBPOS			Label	0F1E9h
FILEPOS			Label	0F1EAh
CKSUMTBL		Label	0F1ECh
BOOT			Label	0F200h
WBOOT			Label	0F203h
CONST			Label	0F206h
CONIN			Label	0F209h
CONOUT			Label	0F20Ch
LIST			Label	0F20Fh
PUNCH			Label	0F212h
READER			Label	0F215h
HOME			Label	0F218h
SELDSK			Label	0F21Bh
SETTRK			Label	0F21Eh
SETSEC			Label	0F221h
SETDMA			Label	0F224h
READ			Label	0F227h
WRITE			Label	0F22Ah
PRSTAT			Label	0F22Dh
SECTRN			Label	0F230h
DCB			Label	0F233h
dpbase			Label	0F235h
dpblk			Label	0F275h
boot			Label	0F284h
wboot			Label	0F28Eh
load1			Label	0F2A2h
gocpm			Label	0F2D7h
const			Label	0F2F8h
conin			Label	0F2FBh
conin1			Label	0F30Ah
con			Label	0F315h
conout			Label	0F316h
list			Label	0F31Ah
listst			Label	0F31Ch
punch			Label	0F31Eh
reader			Label	0F320h
home			Label	0F325h
seldsk			Label	0F32Bh
settrk			Label	0F344h
setsec			Label	0F34Dh
sectran			Label	0F356h
setdma			Label	0F359h
read			Label	0F35Fh
write			Label	0F363h
waitio			Label	0F367h
track			Label	0F367h
sector			Label	0F369h
dmaad			Label	0F36Bh
diskno			Label	0F36Dh
dirbf			Label	0F36Eh
all00			Label	0F3EEh
all01			Label	0F40Dh
all02			Label	0F42Ch
all03			Label	0F44Bh
chk00			Label	0F46Ah
chk01			Label	0F47Ah
chk02			Label	0F48Ah
chk03			Label	0F49Ah

Statistics
----------
"Name"	= 0
"EQU"	= 36
"SET"	= 0
Labels	= 513


