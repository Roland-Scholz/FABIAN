cpm22z80.asm:
     1                          ;**************************************************************
     2                          ;*
     3                          ;*             C P / M   version   2 . 2
     4                          ;*
     5                          ;*   Reconstructed from memory image on February 27, 1981
     6                          ;*
     7                          ;*                by Clark A. Calkins
     8                          ;*
     9                          ;**************************************************************
    10                          ;
    11                          ; Set memory limit here. This is the amount of contigeous
    12                          ; ram starting from 0000. CP/M will reside at the end of this space.
    13                          ;
    14                          MEM	EQU	62		;for a 62k system (TS802 TEST - WORKS OK).
    15                          BIOS	EQU	(MEM-7)*1024 + $1600
    16                          ;
    17                          IOBYTE	EQU	3		;i/o definition byte.
    18                          TDRIVE	EQU	4		;current drive name and user number.
    19                          ENTRY	EQU	5		;entry point for the cp/m bdos.
    20                          TFCB	EQU	5CH		;default file control block.
    21                          TBUFF	EQU	80H		;i/o buffer and command line storage.
    22                          TBASE	EQU	100H		;transiant program storage area.
    23                          ;
    24                          ;   Set control character equates.
    25                          ;
    26                          CNTRLC	EQU	3		;control-c
    27                          CNTRLE	EQU	05H		;control-e
    28                          BS	EQU	08H		;backspace
    29                          TAB	EQU	09H		;tab
    30                          LF	EQU	0AH		;line feed
    31                          FF	EQU	0CH		;form feed
    32                          CR	EQU	0DH		;carriage return
    33                          CNTRLP	EQU	10H		;control-p
    34                          CNTRLR	EQU	12H		;control-r
    35                          CNTRLS	EQU	13H		;control-s
    36                          CNTRLU	EQU	15H		;control-u
    37                          CNTRLX	EQU	18H		;control-x
    38                          CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
    39                          DEL	EQU	7FH		;rubout
    40                          ;
    41                          ;   Set origin for CP/M
    42                          ;
    43                          	ORG	(MEM-7)*1024
    44                          ;
    45   000000 c35c03          CBASE:	JP	COMMAND		;execute command processor (ccp).
    46   000003 c35803          	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
    47                          
    48                          ;
    49                          ;   Standard cp/m ccp input buffer. Format is (max length),
    50                          ; (actual length), (char #1), (char #2), (char #3), etc.
    51                          ;
    52   000006 7f              INBUFF:		DB	127		;length of input buffer.
    53   000007 00              		DB	0		;current length of contents.
    54   000008 1b5b324a1b5b481bcopyright:	DB	27, "[2J", 27, "[H", 27, "[1m"
                5b316d          
    55   000013 5a383020        		DB	"Z80 "
    56   000017 1b5b33356d46611b		DB	27, "[35mFa", 27, "[m"
                5b6d            
    57   000021 62756c6f757320  		DB	"bulous "
    58   000028 1b5b33326d42691b		DB	27, "[32mBi", 27, "[m"
                5b6d            
    59   000032 6e61727920      		DB	"nary "
    60   000037 1b5b33366d416e1b		DB	27, "[36mAn", 27, "[m"
                5b6d            
    61   000041 6968696c61746f72		DB	"ihilator",13, 10
                0d0a            
    62   00004b 43502f4d20322e32		DB	"CP/M 2.2 Copyright 1979 (c) by Digital Research"
                20436f7079726967
                6874203139373920
                2863292062792044
                69676974616c2052
                65736561726368  
    63   00007a 00              		DB	0
    64   00007b 0000000000000000		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000      
    65   000088 0800            INPOINT:	DW	INBUFF+2	;input line pointer
    66   00008a 0000            NAMEPNT:	DW	0		;input line pointer used for error message. Points to
    67                          ;			;start of name in error.
    68                          ;
    69                          ;   Routine to print (A) on the console. All registers used.
    70                          ;
    71   00008c 5f              PRINT:	LD	E,A		;setup bdos call.
    72   00008d 0e02            	LD	C,2
    73   00008f c30500          	JP	ENTRY
    74                          ;
    75                          ;   Routine to print (A) on the console and to save (BC).
    76                          ;
    77   000092 c5              PRINTB:	PUSH	BC
    78   000093 cd8c00          	CALL	PRINT
    79   000096 c1              	POP	BC
    80   000097 c9              	RET
    81                          ;
    82                          ;   Routine to send a carriage return, line feed combination
    83                          ; to the console.
    84                          ;
    85   000098 3e0d            CRLF:	LD	A,CR
    86   00009a cd9200          	CALL	PRINTB
    87   00009d 3e0a            	LD	A,LF
    88   00009f c39200          	JP	PRINTB
    89                          ;
    90                          ;   Routine to send one space to the console and save (BC).
    91                          ;
    92   0000a2 3e20            SPACE:	LD	A,' '
    93   0000a4 c39200          	JP	PRINTB
    94                          ;
    95                          ;   Routine to print character string pointed to be (BC) on the
    96                          ; console. It must terminate with a null byte.
    97                          ;
    98   0000a7 c5              PLINE:	PUSH	BC
    99   0000a8 cd9800          	CALL	CRLF
   100   0000ab e1              	POP	HL
   101   0000ac 7e              PLINE2:	LD	A,(HL)
   102   0000ad b7              	OR	A
   103   0000ae c8              	RET	Z
   104   0000af 23              	INC	HL
   105   0000b0 e5              	PUSH	HL
   106   0000b1 cd8c00          	CALL	PRINT
   107   0000b4 e1              	POP	HL
   108   0000b5 c3ac00          	JP	PLINE2
   109                          ;
   110                          ;   Routine to reset the disk system.
   111                          ;
   112   0000b8 0e0d            RESDSK:	LD	C,13
   113   0000ba c30500          	JP	ENTRY
   114                          ;
   115                          ;   Routine to select disk (A).
   116                          ;
   117   0000bd 5f              DSKSEL:	LD	E,A
   118   0000be 0e0e            	LD	C,14
   119   0000c0 c30500          	JP	ENTRY
   120                          ;
   121                          ;   Routine to call bdos and save the return code. The zero
   122                          ; flag is set on a return of 0ffh.
   123                          ;
   124   0000c3 cd0500          ENTRY1:	CALL	ENTRY
   125   0000c6 32ee07          	LD	(RTNCODE),A	;save return code.
   126   0000c9 3c              	INC	A		;set zero if 0ffh returned.
   127   0000ca c9              	RET
   128                          ;
   129                          ;   Routine to open a file. (DE) must point to the FCB.
   130                          ;
   131   0000cb 0e0f            OPEN:	LD	C,15
   132   0000cd c3c300          	JP	ENTRY1
   133                          ;
   134                          ;   Routine to open file at (FCB).
   135                          ;
   136   0000d0 af              OPENFCB:XOR	A		;clear the record number byte at fcb+32
   137   0000d1 32ed07          	LD	(FCB+32),A
   138   0000d4 11cd07          	LD	DE,FCB
   139   0000d7 c3cb00          	JP	OPEN
   140                          ;
   141                          ;   Routine to close a file. (DE) points to FCB.
   142                          ;
   143   0000da 0e10            CLOSE:	LD	C,16
   144   0000dc c3c300          	JP	ENTRY1
   145                          ;
   146                          ;   Routine to search for the first file with ambigueous name
   147                          ; (DE).
   148                          ;
   149   0000df 0e11            SRCHFST:LD	C,17
   150   0000e1 c3c300          	JP	ENTRY1
   151                          ;
   152                          ;   Search for the next ambigeous file name.
   153                          ;
   154   0000e4 0e12            SRCHNXT:LD	C,18
   155   0000e6 c3c300          	JP	ENTRY1
   156                          ;
   157                          ;   Search for file at (FCB).
   158                          ;
   159   0000e9 11cd07          SRCHFCB:LD	DE,FCB
   160   0000ec c3df00          	JP	SRCHFST
   161                          ;
   162                          ;   Routine to delete a file pointed to by (DE).
   163                          ;
   164   0000ef 0e13            DELETE:	LD	C,19
   165   0000f1 c30500          	JP	ENTRY
   166                          ;
   167                          ;   Routine to call the bdos and set the zero flag if a zero
   168                          ; status is returned.
   169                          ;
   170   0000f4 cd0500          ENTRY2:	CALL	ENTRY
   171   0000f7 b7              	OR	A		;set zero flag if appropriate.
   172   0000f8 c9              	RET
   173                          ;
   174                          ;   Routine to read the next record from a sequential file.
   175                          ; (DE) points to the FCB.
   176                          ;
   177   0000f9 0e14            RDREC:	LD	C,20
   178   0000fb c3f400          	JP	ENTRY2
   179                          ;
   180                          ;   Routine to read file at (FCB).
   181                          ;
   182   0000fe 11cd07          READFCB:LD	DE,FCB
   183   000101 c3f900          	JP	RDREC
   184                          ;
   185                          ;   Routine to write the next record of a sequential file.
   186                          ; (DE) points to the FCB.
   187                          ;
   188   000104 0e15            WRTREC:	LD	C,21
   189   000106 c3f400          	JP	ENTRY2
   190                          ;
   191                          ;   Routine to create the file pointed to by (DE).
   192                          ;
   193   000109 0e16            CREATE:	LD	C,22
   194   00010b c3c300          	JP	ENTRY1
   195                          ;
   196                          ;   Routine to rename the file pointed to by (DE). Note that
   197                          ; the new name starts at (DE+16).
   198                          ;
   199   00010e 0e17            RENAM:	LD	C,23
   200   000110 c30500          	JP	ENTRY
   201                          ;
   202                          ;   Get the current user code.
   203                          ;
   204   000113 1eff            GETUSR:	LD	E,0FFH
   205                          ;
   206                          ;   Routne to get or set the current user code.
   207                          ; If (E) is FF then this is a GET, else it is a SET.
   208                          ;
   209   000115 0e20            GETSETUC: LD	C,32
   210   000117 c30500          	JP	ENTRY
   211                          ;
   212                          ;   Routine to set the current drive byte at (TDRIVE).
   213                          ;
   214   00011a cd1301          SETCDRV:CALL	GETUSR		;get user number
   215   00011d 87              	ADD	A,A		;and shift into the upper 4 bits.
   216   00011e 87              	ADD	A,A
   217   00011f 87              	ADD	A,A
   218   000120 87              	ADD	A,A
   219   000121 21ef07          	LD	HL,CDRIVE	;now add in the current drive number.
   220   000124 b6              	OR	(HL)
   221   000125 320400          	LD	(TDRIVE),A	;and save.
   222   000128 c9              	RET
   223                          ;
   224                          ;   Move currently active drive down to (TDRIVE).
   225                          ;
   226   000129 3aef07          MOVECD:	LD	A,(CDRIVE)
   227   00012c 320400          	LD	(TDRIVE),A
   228   00012f c9              	RET
   229                          ;
   230                          ;   Routine to convert (A) into upper case ascii. Only letters
   231                          ; are affected.
   232                          ;
   233   000130 fe61            UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
   234   000132 d8              	RET	C
   235   000133 fe7b            	CP	'{'
   236   000135 d0              	RET	NC
   237   000136 e65f            	AND	5FH		;convert it if found.
   238   000138 c9              	RET
   239                          ;
   240                          ;   Routine to get a line of input. We must check to see if the
   241                          ; user is in (BATCH) mode. If so, then read the input from file
   242                          ; ($$$.SUB). At the end, reset to console input.
   243                          ;
   244   000139 3aab07          GETINP:	LD	A,(BATCH)	;if =0, then use console input.
   245   00013c b7              	OR	A
   246   00013d ca9601          	JP	Z,GETINP1
   247                          ;
   248                          ;   Use the submit file ($$$.sub) which is prepared by a
   249                          ; SUBMIT run. It must be on drive (A) and it will be deleted
   250                          ; if and error occures (like eof).
   251                          ;
   252   000140 3aef07          	LD	A,(CDRIVE)	;select drive 0 if need be.
   253   000143 b7              	OR	A
   254   000144 3e00            	LD	A,0		;always use drive A for submit.
   255   000146 c4bd00          	CALL	NZ,DSKSEL	;select it if required.
   256   000149 11ac07          	LD	DE,BATCHFCB
   257   00014c cdcb00          	CALL	OPEN		;look for it.
   258   00014f ca9601          	JP	Z,GETINP1	;if not there, use normal input.
   259   000152 3abb07          	LD	A,(BATCHFCB+15)	;get last record number+1.
   260   000155 3d              	DEC	A
   261   000156 32cc07          	LD	(BATCHFCB+32),A
   262   000159 11ac07          	LD	DE,BATCHFCB
   263   00015c cdf900          	CALL	RDREC		;read last record.
   264   00015f c29601          	JP	NZ,GETINP1	;quit on end of file.
   265                          ;
   266                          ;   Move this record into input buffer.
   267                          ;
   268   000162 110700          	LD	DE,INBUFF+1
   269   000165 218000          	LD	HL,TBUFF	;data was read into buffer here.
   270   000168 0680            	LD	B,128		;all 128 characters may be used.
   271   00016a cd4204          	CALL	HL2DE		;(HL) to (DE), (B) bytes.
   272   00016d 21ba07          	LD	HL,BATCHFCB+14
   273   000170 3600            	LD	(HL),0		;zero out the 's2' byte.
   274   000172 23              	INC	HL		;and decrement the record count.
   275   000173 35              	DEC	(HL)
   276   000174 11ac07          	LD	DE,BATCHFCB	;close the batch file now.
   277   000177 cdda00          	CALL	CLOSE
   278   00017a ca9601          	JP	Z,GETINP1	;quit on an error.
   279   00017d 3aef07          	LD	A,(CDRIVE)	;re-select previous drive if need be.
   280   000180 b7              	OR	A
   281   000181 c4bd00          	CALL	NZ,DSKSEL	;don't do needless selects.
   282                          ;
   283                          ;   Print line just read on console.
   284                          ;
   285   000184 210800          	LD	HL,INBUFF+2
   286   000187 cdac00          	CALL	PLINE2
   287   00018a cdc201          	CALL	CHKCON		;check console, quit on a key.
   288   00018d caa701          	JP	Z,GETINP2	;jump if no key is pressed.
   289                          ;
   290                          ;   Terminate the submit job on any keyboard input. Delete this
   291                          ; file such that it is not re-started and jump to normal keyboard
   292                          ; input section.
   293                          ;
   294   000190 cddd01          	CALL	DELBATCH	;delete the batch file.
   295   000193 c38203          	JP	CMMND1		;and restart command input.
   296                          ;
   297                          ;   Get here for normal keyboard input. Delete the submit file
   298                          ; incase there was one.
   299                          ;
   300   000196 cddd01          GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
   301   000199 cd1a01          	CALL	SETCDRV		;reset active disk.
   302   00019c 0e0a            	LD	C,10		;get line from console device.
   303   00019e 110600          	LD	DE,INBUFF
   304   0001a1 cd0500          	CALL	ENTRY
   305   0001a4 cd2901          	CALL	MOVECD		;reset current drive (again).
   306                          ;
   307                          ;   Convert input line to upper case.
   308                          ;
   309   0001a7 210700          GETINP2:LD	HL,INBUFF+1
   310   0001aa 46              	LD	B,(HL)		;(B)=character counter.
   311   0001ab 23              GETINP3:INC	HL
   312   0001ac 78              	LD	A,B		;end of the line?
   313   0001ad b7              	OR	A
   314   0001ae caba01          	JP	Z,GETINP4
   315   0001b1 7e              	LD	A,(HL)		;convert to upper case.
   316   0001b2 cd3001          	CALL	UPPER
   317   0001b5 77              	LD	(HL),A
   318   0001b6 05              	DEC	B		;adjust character count.
   319   0001b7 c3ab01          	JP	GETINP3
   320   0001ba 77              GETINP4:LD	(HL),A		;add trailing null.
   321   0001bb 210800          	LD	HL,INBUFF+2
   322   0001be 228800          	LD	(INPOINT),HL	;reset input line pointer.
   323   0001c1 c9              	RET
   324                          ;
   325                          ;   Routine to check the console for a key pressed. The zero
   326                          ; flag is set is none, else the character is returned in (A).
   327                          ;
   328   0001c2 0e0b            CHKCON:	LD	C,11		;check console.
   329   0001c4 cd0500          	CALL	ENTRY
   330   0001c7 b7              	OR	A
   331   0001c8 c8              	RET	Z		;return if nothing.
   332   0001c9 0e01            	LD	C,1		;else get character.
   333   0001cb cd0500          	CALL	ENTRY
   334   0001ce b7              	OR	A		;clear zero flag and return.
   335   0001cf c9              	RET
   336                          ;
   337                          ;   Routine to get the currently active drive number.
   338                          ;
   339   0001d0 0e19            GETDSK:	LD	C,25
   340   0001d2 c30500          	JP	ENTRY
   341                          ;
   342                          ;   Set the stabdard dma address.
   343                          ;
   344   0001d5 118000          STDDMA:	LD	DE,TBUFF
   345                          ;
   346                          ;   Routine to set the dma address to (DE).
   347                          ;
   348   0001d8 0e1a            DMASET:	LD	C,26
   349   0001da c30500          	JP	ENTRY
   350                          ;
   351                          ;  Delete the batch file created by SUBMIT.
   352                          ;
   353   0001dd 21ab07          DELBATCH: LD	HL,BATCH	;is batch active?
   354   0001e0 7e              	LD	A,(HL)
   355   0001e1 b7              	OR	A
   356   0001e2 c8              	RET	Z
   357   0001e3 3600            	LD	(HL),0		;yes, de-activate it.
   358   0001e5 af              	XOR	A
   359   0001e6 cdbd00          	CALL	DSKSEL		;select drive 0 for sure.
   360   0001e9 11ac07          	LD	DE,BATCHFCB	;and delete this file.
   361   0001ec cdef00          	CALL	DELETE
   362   0001ef 3aef07          	LD	A,(CDRIVE)	;reset current drive.
   363   0001f2 c3bd00          	JP	DSKSEL
   364                          ;
   365                          ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
   366                          ; the same or we halt....
   367                          ;
   368   0001f5 112803          VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
   369   0001f8 210008          	LD	HL,PATTRN2	;ditto, but how could they be different?
   370   0001fb 0606            	LD	B,6		;6 bytes each.
   371   0001fd 1a              VERIFY1:LD	A,(DE)
   372   0001fe be              	CP	(HL)
   373   0001ff c2cf03          	JP	NZ,HALT		;jump to halt routine.
   374   000202 13              	INC	DE
   375   000203 23              	INC	HL
   376   000204 05              	DEC	B
   377   000205 c2fd01          	JP	NZ,VERIFY1
   378   000208 c9              	RET
   379                          ;
   380                          ;   Print back file name with a '?' to indicate a syntax error.
   381                          ;
   382   000209 cd9800          SYNERR:	CALL	CRLF		;end current line.
   383   00020c 2a8a00          	LD	HL,(NAMEPNT)	;this points to name in error.
   384   00020f 7e              SYNERR1:LD	A,(HL)		;print it until a space or null is found.
   385   000210 fe20            	CP	' '
   386   000212 ca2202          	JP	Z,SYNERR2
   387   000215 b7              	OR	A
   388   000216 ca2202          	JP	Z,SYNERR2
   389   000219 e5              	PUSH	HL
   390   00021a cd8c00          	CALL	PRINT
   391   00021d e1              	POP	HL
   392   00021e 23              	INC	HL
   393   00021f c30f02          	JP	SYNERR1
   394   000222 3e3f            SYNERR2:LD	A,'?'		;add trailing '?'.
   395   000224 cd8c00          	CALL	PRINT
   396   000227 cd9800          	CALL	CRLF
   397   00022a cddd01          	CALL	DELBATCH	;delete any batch file.
   398   00022d c38203          	JP	CMMND1		;and restart from console input.
   399                          ;
   400                          ;   Check character at (DE) for legal command input. Note that the
   401                          ; zero flag is set if the character is a delimiter.
   402                          ;
   403   000230 1a              CHECK:	LD	A,(DE)
   404   000231 b7              	OR	A
   405   000232 c8              	RET	Z
   406   000233 fe20            	CP	' '		;control characters are not legal here.
   407   000235 da0902          	JP	C,SYNERR
   408   000238 c8              	RET	Z		;check for valid delimiter.
   409   000239 fe3d            	CP	'='
   410   00023b c8              	RET	Z
   411   00023c fe5f            	CP	'_'
   412   00023e c8              	RET	Z
   413   00023f fe2e            	CP	'.'
   414   000241 c8              	RET	Z
   415   000242 fe3a            	CP	':'
   416   000244 c8              	RET	Z
   417   000245 fe3b            	CP	';'
   418   000247 c8              	RET	Z
   419   000248 fe3c            	CP	'<'
   420   00024a c8              	RET	Z
   421   00024b fe3e            	CP	'>'
   422   00024d c8              	RET	Z
   423   00024e c9              	RET
   424                          ;
   425                          ;   Get the next non-blank character from (DE).
   426                          ;
   427   00024f 1a              NONBLANK: LD	A,(DE)
   428   000250 b7              	OR	A		;string ends with a null.
   429   000251 c8              	RET	Z
   430   000252 fe20            	CP	' '
   431   000254 c0              	RET	NZ
   432   000255 13              	INC	DE
   433   000256 c34f02          	JP	NONBLANK
   434                          ;
   435                          ;   Add (HL)=(HL)+(A)
   436                          ;
   437   000259 85              ADDHL:	ADD	A,L
   438   00025a 6f              	LD	L,A
   439   00025b d0              	RET	NC		;take care of any carry.
   440   00025c 24              	INC	H
   441   00025d c9              	RET
   442                          ;
   443                          ;   Convert the first name in (FCB).
   444                          ;
   445   00025e 3e00            CONVFST:LD	A,0
   446                          ;
   447                          ;   Format a file name (convert * to '?', etc.). On return,
   448                          ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
   449                          ; the position within the fcb for the name (either 0 or 16).
   450                          ;
   451   000260 21cd07          CONVERT:LD	HL,FCB
   452   000263 cd5902          	CALL	ADDHL
   453   000266 e5              	PUSH	HL
   454   000267 e5              	PUSH	HL
   455   000268 af              	XOR	A
   456   000269 32f007          	LD	(CHGDRV),A	;initialize drive change flag.
   457   00026c 2a8800          	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
   458   00026f eb              	EX	DE,HL
   459   000270 cd4f02          	CALL	NONBLANK	;get next non-blank character.
   460   000273 eb              	EX	DE,HL
   461   000274 228a00          	LD	(NAMEPNT),HL	;save pointer here for any error message.
   462   000277 eb              	EX	DE,HL
   463   000278 e1              	POP	HL
   464   000279 1a              	LD	A,(DE)		;get first character.
   465   00027a b7              	OR	A
   466   00027b ca8902          	JP	Z,CONVRT1
   467   00027e de40            	SBC	A,'A'-1		;might be a drive name, convert to binary.
   468   000280 47              	LD	B,A		;and save.
   469   000281 13              	INC	DE		;check next character for a ':'.
   470   000282 1a              	LD	A,(DE)
   471   000283 fe3a            	CP	':'
   472   000285 ca9002          	JP	Z,CONVRT2
   473   000288 1b              	DEC	DE		;nope, move pointer back to the start of the line.
   474   000289 3aef07          CONVRT1:LD	A,(CDRIVE)
   475   00028c 77              	LD	(HL),A
   476   00028d c39602          	JP	CONVRT3
   477   000290 78              CONVRT2:LD	A,B
   478   000291 32f007          	LD	(CHGDRV),A	;set change in drives flag.
   479   000294 70              	LD	(HL),B
   480   000295 13              	INC	DE
   481                          ;
   482                          ;   Convert the basic file name.
   483                          ;
   484   000296 0608            CONVRT3:LD	B,08H
   485   000298 cd3002          CONVRT4:CALL	CHECK
   486   00029b cab902          	JP	Z,CONVRT8
   487   00029e 23              	INC	HL
   488   00029f fe2a            	CP	'*'		;note that an '*' will fill the remaining
   489   0002a1 c2a902          	JP	NZ,CONVRT5	;field with '?'.
   490   0002a4 363f            	LD	(HL),'?'
   491   0002a6 c3ab02          	JP	CONVRT6
   492   0002a9 77              CONVRT5:LD	(HL),A
   493   0002aa 13              	INC	DE
   494   0002ab 05              CONVRT6:DEC	B
   495   0002ac c29802          	JP	NZ,CONVRT4
   496   0002af cd3002          CONVRT7:CALL	CHECK		;get next delimiter.
   497   0002b2 cac002          	JP	Z,GETEXT
   498   0002b5 13              	INC	DE
   499   0002b6 c3af02          	JP	CONVRT7
   500   0002b9 23              CONVRT8:INC	HL		;blank fill the file name.
   501   0002ba 3620            	LD	(HL),' '
   502   0002bc 05              	DEC	B
   503   0002bd c2b902          	JP	NZ,CONVRT8
   504                          ;
   505                          ;   Get the extension and convert it.
   506                          ;
   507   0002c0 0603            GETEXT:	LD	B,03H
   508   0002c2 fe2e            	CP	'.'
   509   0002c4 c2e902          	JP	NZ,GETEXT5
   510   0002c7 13              	INC	DE
   511   0002c8 cd3002          GETEXT1:CALL	CHECK
   512   0002cb cae902          	JP	Z,GETEXT5
   513   0002ce 23              	INC	HL
   514   0002cf fe2a            	CP	'*'
   515   0002d1 c2d902          	JP	NZ,GETEXT2
   516   0002d4 363f            	LD	(HL),'?'
   517   0002d6 c3db02          	JP	GETEXT3
   518   0002d9 77              GETEXT2:LD	(HL),A
   519   0002da 13              	INC	DE
   520   0002db 05              GETEXT3:DEC	B
   521   0002dc c2c802          	JP	NZ,GETEXT1
   522   0002df cd3002          GETEXT4:CALL	CHECK
   523   0002e2 caf002          	JP	Z,GETEXT6
   524   0002e5 13              	INC	DE
   525   0002e6 c3df02          	JP	GETEXT4
   526   0002e9 23              GETEXT5:INC	HL
   527   0002ea 3620            	LD	(HL),' '
   528   0002ec 05              	DEC	B
   529   0002ed c2e902          	JP	NZ,GETEXT5
   530   0002f0 0603            GETEXT6:LD	B,3
   531   0002f2 23              GETEXT7:INC	HL
   532   0002f3 3600            	LD	(HL),0
   533   0002f5 05              	DEC	B
   534   0002f6 c2f202          	JP	NZ,GETEXT7
   535   0002f9 eb              	EX	DE,HL
   536   0002fa 228800          	LD	(INPOINT),HL	;save input line pointer.
   537   0002fd e1              	POP	HL
   538                          ;
   539                          ;   Check to see if this is an ambigeous file name specification.
   540                          ; Set the (A) register to non zero if it is.
   541                          ;
   542   0002fe 010b00          	LD	BC,11		;set name length.
   543   000301 23              GETEXT8:INC	HL
   544   000302 7e              	LD	A,(HL)
   545   000303 fe3f            	CP	'?'		;any question marks?
   546   000305 c20903          	JP	NZ,GETEXT9
   547   000308 04              	INC	B		;count them.
   548   000309 0d              GETEXT9:DEC	C
   549   00030a c20103          	JP	NZ,GETEXT8
   550   00030d 78              	LD	A,B
   551   00030e b7              	OR	A
   552   00030f c9              	RET
   553                          ;
   554                          ;   CP/M command table. Note commands can be either 3 or 4 characters long.
   555                          ;
   556                          NUMCMDS EQU	6		;number of commands
   557   000310 44495220        CMDTBL:	DB	"DIR "
   558   000314 45524120        	DB	"ERA "
   559   000318 54595045        	DB	"TYPE"
   560   00031c 53415645        	DB	"SAVE"
   561   000320 52454e20        	DB	"REN "
   562   000324 55534552        	DB	"USER"
   563                          ;
   564                          ;   The following six bytes must agree with those at (PATTRN2)
   565                          ; or cp/m will HALT. Why?
   566                          ;
   567   000328 001600000000    PATTRN1:DB	0,22,0,0,0,0	;(* serial number bytes *).
   568                          ;
   569                          ;   Search the command table for a match with what has just
   570                          ; been entered. If a match is found, then we jump to the
   571                          ; proper section. Else jump to (UNKNOWN).
   572                          ; On return, the (C) register is set to the command number
   573                          ; that matched (or NUMCMDS+1 if no match).
   574                          ;
   575   00032e 211003          SEARCH:	LD	HL,CMDTBL
   576   000331 0e00            	LD	C,0
   577   000333 79              SEARCH1:LD	A,C
   578   000334 fe06            	CP	NUMCMDS		;this commands exists.
   579   000336 d0              	RET	NC
   580   000337 11ce07          	LD	DE,FCB+1	;check this one.
   581   00033a 0604            	LD	B,4		;max command length.
   582   00033c 1a              SEARCH2:LD	A,(DE)
   583   00033d be              	CP	(HL)
   584   00033e c24f03          	JP	NZ,SEARCH3	;not a match.
   585   000341 13              	INC	DE
   586   000342 23              	INC	HL
   587   000343 05              	DEC	B
   588   000344 c23c03          	JP	NZ,SEARCH2
   589   000347 1a              	LD	A,(DE)		;allow a 3 character command to match.
   590   000348 fe20            	CP	' '
   591   00034a c25403          	JP	NZ,SEARCH4
   592   00034d 79              	LD	A,C		;set return register for this command.
   593   00034e c9              	RET
   594   00034f 23              SEARCH3:INC	HL
   595   000350 05              	DEC	B
   596   000351 c24f03          	JP	NZ,SEARCH3
   597   000354 0c              SEARCH4:INC	C
   598   000355 c33303          	JP	SEARCH1
   599                          ;
   600                          ;   Set the input buffer to empty and then start the command
   601                          ; processor (ccp).
   602                          ;
   603   000358 af              CLEARBUF: XOR	A
   604   000359 320700          	LD	(INBUFF+1),A	;second byte is actual length.
   605                          ;
   606                          ;**************************************************************
   607                          ;*
   608                          ;*
   609                          ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
   610                          ;*
   611                          ;**************************************************************
   612                          ;*
   613                          COMMAND:
   614   00035c 31ab07          	LD	SP,CCPSTACK	;setup stack area.
   615   00035f c5              	PUSH	BC		;note that (C) should be equal to:
   616   000360 79              	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
   617   000361 1f              	RRA			;and 'dddd' is the drive number.
   618   000362 1f              	RRA
   619   000363 1f              	RRA
   620   000364 1f              	RRA
   621   000365 e60f            	AND	0FH		;isolate the user number.
   622   000367 5f              	LD	E,A
   623   000368 cd1501          	CALL	GETSETUC	;and set it.
   624   00036b cdb800          	CALL	RESDSK		;reset the disk system.
   625   00036e 32ab07          	LD	(BATCH),A	;clear batch mode flag.
   626   000371 c1              	POP	BC
   627   000372 79              	LD	A,C
   628   000373 e60f            	AND	0FH		;isolate the drive number.
   629   000375 32ef07          	LD	(CDRIVE),A	;and save.
   630   000378 cdbd00          	CALL	DSKSEL		;...and select.
   631   00037b 3a0700          	LD	A,(INBUFF+1)
   632   00037e b7              	OR	A		;anything in input buffer already?
   633   00037f c29803          	JP	NZ,CMMND2	;yes, we just process it.
   634                          ;
   635                          ;   Entry point to get a command line from the console.
   636                          ;
   637   000382 31ab07          CMMND1:	LD	SP,CCPSTACK	;set stack straight.
   638   000385 cd9800          	CALL	CRLF		;start a new line on the screen.
   639   000388 cdd001          	CALL	GETDSK		;get current drive.
   640   00038b c661            	ADD	A,'a'
   641   00038d cd8c00          	CALL	PRINT		;print current drive.
   642   000390 3e3e            	LD	A,'>'
   643   000392 cd8c00          	CALL	PRINT		;and add prompt.
   644   000395 cd3901          	CALL	GETINP		;get line from user.
   645                          ;
   646                          ;   Process command line here.
   647                          ;
   648   000398 118000          CMMND2:	LD	DE,TBUFF
   649   00039b cdd801          	CALL	DMASET		;set standard dma address.
   650   00039e cdd001          	CALL	GETDSK
   651   0003a1 32ef07          	LD	(CDRIVE),A	;set current drive.
   652   0003a4 cd5e02          	CALL	CONVFST		;convert name typed in.
   653   0003a7 c40902          	CALL	NZ,SYNERR	;wild cards are not allowed.
   654   0003aa 3af007          	LD	A,(CHGDRV)	;if a change in drives was indicated,
   655   0003ad b7              	OR	A		;then treat this as an unknown command
   656   0003ae c2a506          	JP	NZ,UNKNOWN	;which gets executed.
   657   0003b1 cd2e03          	CALL	SEARCH		;else search command table for a match.
   658                          ;
   659                          ;   Note that an unknown command returns
   660                          ; with (A) pointing to the last address
   661                          ; in our table which is (UNKNOWN).
   662                          ;
   663   0003b4 21c103          	LD	HL,CMDADR	;now, look thru our address table for command (A).
   664   0003b7 5f              	LD	E,A		;set (DE) to command number.
   665   0003b8 1600            	LD	D,0
   666   0003ba 19              	ADD	HL,DE
   667   0003bb 19              	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
   668   0003bc 7e              	LD	A,(HL)		;now pick out this address.
   669   0003bd 23              	INC	HL
   670   0003be 66              	LD	H,(HL)
   671   0003bf 6f              	LD	L,A
   672   0003c0 e9              	JP	(HL)		;now execute it.
   673                          ;
   674                          ;   CP/M command address table.
   675                          ;
   676   0003c1 77041f055d05ad05CMDADR:	DW	DIRECT,ERASE,TYPE,SAVE
   677   0003c9 10068e06a506    	DW	RENAME,USER,UNKNOWN
   678                          ;
   679                          ;   Halt the system. Reason for this is unknown at present.
   680                          ;
   681   0003cf 21f376          HALT:	LD	HL,76F3H	;'DI HLT' instructions.
   682   0003d2 220000          	LD	(CBASE),HL
   683   0003d5 210000          	LD	HL,CBASE
   684   0003d8 e9              	JP	(HL)
   685                          ;
   686                          ;   Read error while TYPEing a file.
   687                          ;
   688   0003d9 01df03          RDERROR:LD	BC,RDERR
   689   0003dc c3a700          	JP	PLINE
   690   0003df 5265616420657272RDERR:	DB	"Read error",0
                6f7200          
   691                          ;
   692                          ;   Required file was not located.
   693                          ;
   694   0003ea 01f003          NONE:	LD	BC,NOFILE
   695   0003ed c3a700          	JP	PLINE
   696   0003f0 4e6f2066696c6500NOFILE:	DB	"No file",0
   697                          ;
   698                          ;   Decode a command of the form 'A>filename number{ filename}.
   699                          ; Note that a drive specifier is not allowed on the first file
   700                          ; name. On return, the number is in register (A). Any error
   701                          ; causes 'filename?' to be printed and the command is aborted.
   702                          ;
   703   0003f8 cd5e02          DECODE:	CALL	CONVFST		;convert filename.
   704   0003fb 3af007          	LD	A,(CHGDRV)	;do not allow a drive to be specified.
   705   0003fe b7              	OR	A
   706   0003ff c20902          	JP	NZ,SYNERR
   707   000402 21ce07          	LD	HL,FCB+1	;convert number now.
   708   000405 010b00          	LD	BC,11		;(B)=sum register, (C)=max digit count.
   709   000408 7e              DECODE1:LD	A,(HL)
   710   000409 fe20            	CP	' '		;a space terminates the numeral.
   711   00040b ca3304          	JP	Z,DECODE3
   712   00040e 23              	INC	HL
   713   00040f d630            	SUB	'0'		;make binary from ascii.
   714   000411 fe0a            	CP	10		;legal digit?
   715   000413 d20902          	JP	NC,SYNERR
   716   000416 57              	LD	D,A		;yes, save it in (D).
   717   000417 78              	LD	A,B		;compute (B)=(B)*10 and check for overflow.
   718   000418 e6e0            	AND	0E0H
   719   00041a c20902          	JP	NZ,SYNERR
   720   00041d 78              	LD	A,B
   721   00041e 07              	RLCA
   722   00041f 07              	RLCA
   723   000420 07              	RLCA			;(A)=(B)*8
   724   000421 80              	ADD	A,B		;.......*9
   725   000422 da0902          	JP	C,SYNERR
   726   000425 80              	ADD	A,B		;.......*10
   727   000426 da0902          	JP	C,SYNERR
   728   000429 82              	ADD	A,D		;add in new digit now.
   729   00042a da0902          DECODE2:JP	C,SYNERR
   730   00042d 47              	LD	B,A		;and save result.
   731   00042e 0d              	DEC	C		;only look at 11 digits.
   732   00042f c20804          	JP	NZ,DECODE1
   733   000432 c9              	RET
   734   000433 7e              DECODE3:LD	A,(HL)		;spaces must follow (why?).
   735   000434 fe20            	CP	' '
   736   000436 c20902          	JP	NZ,SYNERR
   737   000439 23              	INC	HL
   738   00043a 0d              DECODE4:DEC	C
   739   00043b c23304          	JP	NZ,DECODE3
   740   00043e 78              	LD	A,B		;set (A)=the numeric value entered.
   741   00043f c9              	RET
   742                          ;
   743                          ;   Move 3 bytes from (HL) to (DE). Note that there is only
   744                          ; one reference to this at (A2D5h).
   745                          ;
   746   000440 0603            MOVE3:	LD	B,3
   747                          ;
   748                          ;   Move (B) bytes from (HL) to (DE).
   749                          ;
   750   000442 7e              HL2DE:	LD	A,(HL)
   751   000443 12              	LD	(DE),A
   752   000444 23              	INC	HL
   753   000445 13              	INC	DE
   754   000446 05              	DEC	B
   755   000447 c24204          	JP	NZ,HL2DE
   756   00044a c9              	RET
   757                          ;
   758                          ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
   759                          ;
   760   00044b 218000          EXTRACT:LD	HL,TBUFF
   761   00044e 81              	ADD	A,C
   762   00044f cd5902          	CALL	ADDHL
   763   000452 7e              	LD	A,(HL)
   764   000453 c9              	RET
   765                          ;
   766                          ;  Check drive specified. If it means a change, then the new
   767                          ; drive will be selected. In any case, the drive byte of the
   768                          ; fcb will be set to null (means use current drive).
   769                          ;
   770   000454 af              DSELECT:XOR	A		;null out first byte of fcb.
   771   000455 32cd07          	LD	(FCB),A
   772   000458 3af007          	LD	A,(CHGDRV)	;a drive change indicated?
   773   00045b b7              	OR	A
   774   00045c c8              	RET	Z
   775   00045d 3d              	DEC	A		;yes, is it the same as the current drive?
   776   00045e 21ef07          	LD	HL,CDRIVE
   777   000461 be              	CP	(HL)
   778   000462 c8              	RET	Z
   779   000463 c3bd00          	JP	DSKSEL		;no. Select it then.
   780                          ;
   781                          ;   Check the drive selection and reset it to the previous
   782                          ; drive if it was changed for the preceeding command.
   783                          ;
   784   000466 3af007          RESETDR:LD	A,(CHGDRV)	;drive change indicated?
   785   000469 b7              	OR	A
   786   00046a c8              	RET	Z
   787   00046b 3d              	DEC	A		;yes, was it a different drive?
   788   00046c 21ef07          	LD	HL,CDRIVE
   789   00046f be              	CP	(HL)
   790   000470 c8              	RET	Z
   791   000471 3aef07          	LD	A,(CDRIVE)	;yes, re-select our old drive.
   792   000474 c3bd00          	JP	DSKSEL
   793                          ;
   794                          ;**************************************************************
   795                          ;*
   796                          ;*           D I R E C T O R Y   C O M M A N D
   797                          ;*
   798                          ;**************************************************************
   799                          ;
   800   000477 cd5e02          DIRECT:	CALL	CONVFST		;convert file name.
   801   00047a cd5404          	CALL	DSELECT		;select indicated drive.
   802   00047d 21ce07          	LD	HL,FCB+1	;was any file indicated?
   803   000480 7e              	LD	A,(HL)
   804   000481 fe20            	CP	' '
   805   000483 c28f04          	JP	NZ,DIRECT2
   806   000486 060b            	LD	B,11		;no. Fill field with '?' - same as *.*.
   807   000488 363f            DIRECT1:LD	(HL),'?'
   808   00048a 23              	INC	HL
   809   00048b 05              	DEC	B
   810   00048c c28804          	JP	NZ,DIRECT1
   811   00048f 1e00            DIRECT2:LD	E,0		;set initial cursor position.
   812   000491 d5              	PUSH	DE
   813   000492 cde900          	CALL	SRCHFCB		;get first file name.
   814   000495 ccea03          	CALL	Z,NONE		;none found at all?
   815   000498 ca1b05          DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
   816   00049b 3aee07          	LD	A,(RTNCODE)	;get file's position in segment (0-3).
   817   00049e 0f              	RRCA
   818   00049f 0f              	RRCA
   819   0004a0 0f              	RRCA
   820   0004a1 e660            	AND	60H		;(A)=position*32
   821   0004a3 4f              	LD	C,A
   822   0004a4 3e0a            	LD	A,10
   823   0004a6 cd4b04          	CALL	EXTRACT		;extract the tenth entry in fcb.
   824   0004a9 17              	RLA			;check system file status bit.
   825   0004aa da0f05          	JP	C,DIRECT8	;we don't list them.
   826   0004ad d1              	POP	DE
   827   0004ae 7b              	LD	A,E		;bump name count.
   828   0004af 1c              	INC	E
   829   0004b0 d5              	PUSH	DE
   830   0004b1 e603            	AND	03H		;at end of line?
   831   0004b3 f5              	PUSH	AF
   832   0004b4 c2cc04          	JP	NZ,DIRECT4
   833   0004b7 cd9800          	CALL	CRLF		;yes, end this line and start another.
   834   0004ba c5              	PUSH	BC
   835   0004bb cdd001          	CALL	GETDSK		;start line with ('A:').
   836   0004be c1              	POP	BC
   837   0004bf c641            	ADD	A,'A'
   838   0004c1 cd9200          	CALL	PRINTB
   839   0004c4 3e3a            	LD	A,':'
   840   0004c6 cd9200          	CALL	PRINTB
   841   0004c9 c3d404          	JP	DIRECT5
   842   0004cc cda200          DIRECT4:CALL	SPACE		;add seperator between file names.
   843   0004cf 3e3a            	LD	A,':'
   844   0004d1 cd9200          	CALL	PRINTB
   845   0004d4 cda200          DIRECT5:CALL	SPACE
   846   0004d7 0601            	LD	B,1		;'extract' each file name character at a time.
   847   0004d9 78              DIRECT6:LD	A,B
   848   0004da cd4b04          	CALL	EXTRACT
   849   0004dd e67f            	AND	7FH		;strip bit 7 (status bit).
   850   0004df fe20            	CP	' '		;are we at the end of the name?
   851   0004e1 c2f904          	JP	NZ,DRECT65
   852   0004e4 f1              	POP	AF		;yes, don't print spaces at the end of a line.
   853   0004e5 f5              	PUSH	AF
   854   0004e6 fe03            	CP	3
   855   0004e8 c2f704          	JP	NZ,DRECT63
   856   0004eb 3e09            	LD	A,9		;first check for no extension.
   857   0004ed cd4b04          	CALL	EXTRACT
   858   0004f0 e67f            	AND	7FH
   859   0004f2 fe20            	CP	' '
   860   0004f4 ca0e05          	JP	Z,DIRECT7	;don't print spaces.
   861   0004f7 3e20            DRECT63:LD	A,' '		;else print them.
   862   0004f9 cd9200          DRECT65:CALL	PRINTB
   863   0004fc 04              	INC	B		;bump to next character psoition.
   864   0004fd 78              	LD	A,B
   865   0004fe fe0c            	CP	12		;end of the name?
   866   000500 d20e05          	JP	NC,DIRECT7
   867   000503 fe09            	CP	9		;nope, starting extension?
   868   000505 c2d904          	JP	NZ,DIRECT6
   869   000508 cda200          	CALL	SPACE		;yes, add seperating space.
   870   00050b c3d904          	JP	DIRECT6
   871   00050e f1              DIRECT7:POP	AF		;get the next file name.
   872   00050f cdc201          DIRECT8:CALL	CHKCON		;first check console, quit on anything.
   873   000512 c21b05          	JP	NZ,DIRECT9
   874   000515 cde400          	CALL	SRCHNXT		;get next name.
   875   000518 c39804          	JP	DIRECT3		;and continue with our list.
   876   00051b d1              DIRECT9:POP	DE		;restore the stack and return to command level.
   877   00051c c38607          	JP	GETBACK
   878                          ;
   879                          ;**************************************************************
   880                          ;*
   881                          ;*                E R A S E   C O M M A N D
   882                          ;*
   883                          ;**************************************************************
   884                          ;
   885   00051f cd5e02          ERASE:	CALL	CONVFST		;convert file name.
   886   000522 fe0b            	CP	11		;was '*.*' entered?
   887   000524 c24205          	JP	NZ,ERASE1
   888   000527 015205          	LD	BC,YESNO	;yes, ask for confirmation.
   889   00052a cda700          	CALL	PLINE
   890   00052d cd3901          	CALL	GETINP
   891   000530 210700          	LD	HL,INBUFF+1
   892   000533 35              	DEC	(HL)		;must be exactly 'y'.
   893   000534 c28203          	JP	NZ,CMMND1
   894   000537 23              	INC	HL
   895   000538 7e              	LD	A,(HL)
   896   000539 fe59            	CP	'Y'
   897   00053b c28203          	JP	NZ,CMMND1
   898   00053e 23              	INC	HL
   899   00053f 228800          	LD	(INPOINT),HL	;save input line pointer.
   900   000542 cd5404          ERASE1:	CALL	DSELECT		;select desired disk.
   901   000545 11cd07          	LD	DE,FCB
   902   000548 cdef00          	CALL	DELETE		;delete the file.
   903   00054b 3c              	INC	A
   904   00054c ccea03          	CALL	Z,NONE		;not there?
   905   00054f c38607          	JP	GETBACK		;return to command level now.
   906   000552 416c6c2028792f6eYESNO:	DB	"All (y/n)?",0
                293f00          
   907                          ;
   908                          ;**************************************************************
   909                          ;*
   910                          ;*            T Y P E   C O M M A N D
   911                          ;*
   912                          ;**************************************************************
   913                          ;
   914   00055d cd5e02          TYPE:	CALL	CONVFST		;convert file name.
   915   000560 c20902          	JP	NZ,SYNERR	;wild cards not allowed.
   916   000563 cd5404          	CALL	DSELECT		;select indicated drive.
   917   000566 cdd000          	CALL	OPENFCB		;open the file.
   918   000569 caa705          	JP	Z,TYPE5		;not there?
   919   00056c cd9800          	CALL	CRLF		;ok, start a new line on the screen.
   920   00056f 21f107          	LD	HL,NBYTES	;initialize byte counter.
   921   000572 36ff            	LD	(HL),0FFH	;set to read first sector.
   922   000574 21f107          TYPE1:	LD	HL,NBYTES
   923   000577 7e              TYPE2:	LD	A,(HL)		;have we written the entire sector?
   924   000578 fe80            	CP	128
   925   00057a da8705          	JP	C,TYPE3
   926   00057d e5              	PUSH	HL		;yes, read in the next one.
   927   00057e cdfe00          	CALL	READFCB
   928   000581 e1              	POP	HL
   929   000582 c2a005          	JP	NZ,TYPE4	;end or error?
   930   000585 af              	XOR	A		;ok, clear byte counter.
   931   000586 77              	LD	(HL),A
   932   000587 34              TYPE3:	INC	(HL)		;count this byte.
   933   000588 218000          	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
   934   00058b cd5902          	CALL	ADDHL
   935   00058e 7e              	LD	A,(HL)
   936   00058f fe1a            	CP	CNTRLZ		;end of file mark?
   937   000591 ca8607          	JP	Z,GETBACK
   938   000594 cd8c00          	CALL	PRINT		;no, print it.
   939   000597 cdc201          	CALL	CHKCON		;check console, quit if anything ready.
   940   00059a c28607          	JP	NZ,GETBACK
   941   00059d c37405          	JP	TYPE1
   942                          ;
   943                          ;   Get here on an end of file or read error.
   944                          ;
   945   0005a0 3d              TYPE4:	DEC	A		;read error?
   946   0005a1 ca8607          	JP	Z,GETBACK
   947   0005a4 cdd903          	CALL	RDERROR		;yes, print message.
   948   0005a7 cd6604          TYPE5:	CALL	RESETDR		;and reset proper drive
   949   0005aa c30902          	JP	SYNERR		;now print file name with problem.
   950                          ;
   951                          ;**************************************************************
   952                          ;*
   953                          ;*            S A V E   C O M M A N D
   954                          ;*
   955                          ;**************************************************************
   956                          ;
   957   0005ad cdf803          SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
   958   0005b0 f5              	PUSH	AF		;save number of pages to write.
   959   0005b1 cd5e02          	CALL	CONVFST		;convert file name.
   960   0005b4 c20902          	JP	NZ,SYNERR	;wild cards not allowed.
   961   0005b7 cd5404          	CALL	DSELECT		;select specified drive.
   962   0005ba 11cd07          	LD	DE,FCB		;now delete this file.
   963   0005bd d5              	PUSH	DE
   964   0005be cdef00          	CALL	DELETE
   965   0005c1 d1              	POP	DE
   966   0005c2 cd0901          	CALL	CREATE		;and create it again.
   967   0005c5 cafb05          	JP	Z,SAVE3		;can't create?
   968   0005c8 af              	XOR	A		;clear record number byte.
   969   0005c9 32ed07          	LD	(FCB+32),A
   970   0005cc f1              	POP	AF		;convert pages to sectors.
   971   0005cd 6f              	LD	L,A
   972   0005ce 2600            	LD	H,0
   973   0005d0 29              	ADD	HL,HL		;(HL)=number of sectors to write.
   974   0005d1 110001          	LD	DE,TBASE	;and we start from here.
   975   0005d4 7c              SAVE1:	LD	A,H		;done yet?
   976   0005d5 b5              	OR	L
   977   0005d6 caf105          	JP	Z,SAVE2
   978   0005d9 2b              	DEC	HL		;nope, count this and compute the start
   979   0005da e5              	PUSH	HL		;of the next 128 byte sector.
   980   0005db 218000          	LD	HL,128
   981   0005de 19              	ADD	HL,DE
   982   0005df e5              	PUSH	HL		;save it and set the transfer address.
   983   0005e0 cdd801          	CALL	DMASET
   984   0005e3 11cd07          	LD	DE,FCB		;write out this sector now.
   985   0005e6 cd0401          	CALL	WRTREC
   986   0005e9 d1              	POP	DE		;reset (DE) to the start of the last sector.
   987   0005ea e1              	POP	HL		;restore sector count.
   988   0005eb c2fb05          	JP	NZ,SAVE3	;write error?
   989   0005ee c3d405          	JP	SAVE1
   990                          ;
   991                          ;   Get here after writing all of the file.
   992                          ;
   993   0005f1 11cd07          SAVE2:	LD	DE,FCB		;now close the file.
   994   0005f4 cdda00          	CALL	CLOSE
   995   0005f7 3c              	INC	A		;did it close ok?
   996   0005f8 c20106          	JP	NZ,SAVE4
   997                          ;
   998                          ;   Print out error message (no space).
   999                          ;
  1000   0005fb 010706          SAVE3:	LD	BC,NOSPACE
  1001   0005fe cda700          	CALL	PLINE
  1002   000601 cdd501          SAVE4:	CALL	STDDMA		;reset the standard dma address.
  1003   000604 c38607          	JP	GETBACK
  1004   000607 4e6f207370616365NOSPACE:DB	"No space",0
                00              
  1005                          ;
  1006                          ;**************************************************************
  1007                          ;*
  1008                          ;*           R E N A M E   C O M M A N D
  1009                          ;*
  1010                          ;**************************************************************
  1011                          ;
  1012   000610 cd5e02          RENAME:	CALL	CONVFST		;convert first file name.
  1013   000613 c20902          	JP	NZ,SYNERR	;wild cards not allowed.
  1014   000616 3af007          	LD	A,(CHGDRV)	;remember any change in drives specified.
  1015   000619 f5              	PUSH	AF
  1016   00061a cd5404          	CALL	DSELECT		;and select this drive.
  1017   00061d cde900          	CALL	SRCHFCB		;is this file present?
  1018   000620 c27906          	JP	NZ,RENAME6	;yes, print error message.
  1019   000623 21cd07          	LD	HL,FCB		;yes, move this name into second slot.
  1020   000626 11dd07          	LD	DE,FCB+16
  1021   000629 0610            	LD	B,16
  1022   00062b cd4204          	CALL	HL2DE
  1023   00062e 2a8800          	LD	HL,(INPOINT)	;get input pointer.
  1024   000631 eb              	EX	DE,HL
  1025   000632 cd4f02          	CALL	NONBLANK	;get next non blank character.
  1026   000635 fe3d            	CP	'='		;only allow an '=' or '_' seperator.
  1027   000637 ca3f06          	JP	Z,RENAME1
  1028   00063a fe5f            	CP	'_'
  1029   00063c c27306          	JP	NZ,RENAME5
  1030   00063f eb              RENAME1:EX	DE,HL
  1031   000640 23              	INC	HL		;ok, skip seperator.
  1032   000641 228800          	LD	(INPOINT),HL	;save input line pointer.
  1033   000644 cd5e02          	CALL	CONVFST		;convert this second file name now.
  1034   000647 c27306          	JP	NZ,RENAME5	;again, no wild cards.
  1035   00064a f1              	POP	AF		;if a drive was specified, then it
  1036   00064b 47              	LD	B,A		;must be the same as before.
  1037   00064c 21f007          	LD	HL,CHGDRV
  1038   00064f 7e              	LD	A,(HL)
  1039   000650 b7              	OR	A
  1040   000651 ca5906          	JP	Z,RENAME2
  1041   000654 b8              	CP	B
  1042   000655 70              	LD	(HL),B
  1043   000656 c27306          	JP	NZ,RENAME5	;they were different, error.
  1044   000659 70              RENAME2:LD	(HL),B		;	reset as per the first file specification.
  1045   00065a af              	XOR	A
  1046   00065b 32cd07          	LD	(FCB),A		;clear the drive byte of the fcb.
  1047   00065e cde900          RENAME3:CALL	SRCHFCB		;and go look for second file.
  1048   000661 ca6d06          	JP	Z,RENAME4	;doesn't exist?
  1049   000664 11cd07          	LD	DE,FCB
  1050   000667 cd0e01          	CALL	RENAM		;ok, rename the file.
  1051   00066a c38607          	JP	GETBACK
  1052                          ;
  1053                          ;   Process rename errors here.
  1054                          ;
  1055   00066d cdea03          RENAME4:CALL	NONE		;file not there.
  1056   000670 c38607          	JP	GETBACK
  1057   000673 cd6604          RENAME5:CALL	RESETDR		;bad command format.
  1058   000676 c30902          	JP	SYNERR
  1059   000679 018206          RENAME6:LD	BC,EXISTS	;destination file already exists.
  1060   00067c cda700          	CALL	PLINE
  1061   00067f c38607          	JP	GETBACK
  1062   000682 46696c6520657869EXISTS:	DB	"File exists",0
                73747300        
  1063                          ;
  1064                          ;**************************************************************
  1065                          ;*
  1066                          ;*             U S E R   C O M M A N D
  1067                          ;*
  1068                          ;**************************************************************
  1069                          ;
  1070   00068e cdf803          USER:	CALL	DECODE		;get numeric value following command.
  1071   000691 fe10            	CP	16		;legal user number?
  1072   000693 d20902          	JP	NC,SYNERR
  1073   000696 5f              	LD	E,A		;yes but is there anything else?
  1074   000697 3ace07          	LD	A,(FCB+1)
  1075   00069a fe20            	CP	' '
  1076   00069c ca0902          	JP	Z,SYNERR	;yes, that is not allowed.
  1077   00069f cd1501          	CALL	GETSETUC	;ok, set user code.
  1078   0006a2 c38907          	JP	GETBACK1
  1079                          ;
  1080                          ;**************************************************************
  1081                          ;*
  1082                          ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
  1083                          ;*
  1084                          ;**************************************************************
  1085                          ;
  1086   0006a5 cdf501          UNKNOWN:CALL	VERIFY		;check for valid system (why?).
  1087   0006a8 3ace07          	LD	A,(FCB+1)	;anything to execute?
  1088   0006ab fe20            	CP	' '
  1089   0006ad c2c406          	JP	NZ,UNKWN1
  1090   0006b0 3af007          	LD	A,(CHGDRV)	;nope, only a drive change?
  1091   0006b3 b7              	OR	A
  1092   0006b4 ca8907          	JP	Z,GETBACK1	;neither???
  1093   0006b7 3d              	DEC	A
  1094   0006b8 32ef07          	LD	(CDRIVE),A	;ok, store new drive.
  1095   0006bb cd2901          	CALL	MOVECD		;set (TDRIVE) also.
  1096   0006be cdbd00          	CALL	DSKSEL		;and select this drive.
  1097   0006c1 c38907          	JP	GETBACK1	;then return.
  1098                          ;
  1099                          ;   Here a file name was typed. Prepare to execute it.
  1100                          ;
  1101   0006c4 11d607          UNKWN1:	LD	DE,FCB+9	;an extension specified?
  1102   0006c7 1a              	LD	A,(DE)
  1103   0006c8 fe20            	CP	' '
  1104   0006ca c20902          	JP	NZ,SYNERR	;yes, not allowed.
  1105   0006cd d5              UNKWN2:	PUSH	DE
  1106   0006ce cd5404          	CALL	DSELECT		;select specified drive.
  1107   0006d1 d1              	POP	DE
  1108   0006d2 218307          	LD	HL,COMFILE	;set the extension to 'COM'.
  1109   0006d5 cd4004          	CALL	MOVE3
  1110   0006d8 cdd000          	CALL	OPENFCB		;and open this file.
  1111   0006db ca6b07          	JP	Z,UNKWN9	;not present?
  1112                          ;
  1113                          ;   Load in the program.
  1114                          ;
  1115   0006de 210001          	LD	HL,TBASE	;store the program starting here.
  1116   0006e1 e5              UNKWN3:	PUSH	HL
  1117   0006e2 eb              	EX	DE,HL
  1118   0006e3 cdd801          	CALL	DMASET		;set transfer address.
  1119   0006e6 11cd07          	LD	DE,FCB		;and read the next record.
  1120   0006e9 cdf900          	CALL	RDREC
  1121   0006ec c20107          	JP	NZ,UNKWN4	;end of file or read error?
  1122   0006ef e1              	POP	HL		;nope, bump pointer for next sector.
  1123   0006f0 118000          	LD	DE,128
  1124   0006f3 19              	ADD	HL,DE
  1125   0006f4 110000          	LD	DE,CBASE	;enough room for the whole file?
  1126   0006f7 7d              	LD	A,L
  1127   0006f8 93              	SUB	E
  1128   0006f9 7c              	LD	A,H
  1129   0006fa 9a              	SBC	A,D
  1130   0006fb d27107          	JP	NC,UNKWN0	;no, it can't fit.
  1131   0006fe c3e106          	JP	UNKWN3
  1132                          ;
  1133                          ;   Get here after finished reading.
  1134                          ;
  1135   000701 e1              UNKWN4:	POP	HL
  1136   000702 3d              	DEC	A		;normal end of file?
  1137   000703 c27107          	JP	NZ,UNKWN0
  1138   000706 cd6604          	CALL	RESETDR		;yes, reset previous drive.
  1139   000709 cd5e02          	CALL	CONVFST		;convert the first file name that follows
  1140   00070c 21f007          	LD	HL,CHGDRV	;command name.
  1141   00070f e5              	PUSH	HL
  1142   000710 7e              	LD	A,(HL)		;set drive code in default fcb.
  1143   000711 32cd07          	LD	(FCB),A
  1144   000714 3e10            	LD	A,16		;put second name 16 bytes later.
  1145   000716 cd6002          	CALL	CONVERT		;convert second file name.
  1146   000719 e1              	POP	HL
  1147   00071a 7e              	LD	A,(HL)		;and set the drive for this second file.
  1148   00071b 32dd07          	LD	(FCB+16),A
  1149   00071e af              	XOR	A		;clear record byte in fcb.
  1150   00071f 32ed07          	LD	(FCB+32),A
  1151   000722 115c00          	LD	DE,TFCB		;move it into place at(005Ch).
  1152   000725 21cd07          	LD	HL,FCB
  1153   000728 0621            	LD	B,33
  1154   00072a cd4204          	CALL	HL2DE
  1155   00072d 210800          	LD	HL,INBUFF+2	;now move the remainder of the input
  1156   000730 7e              UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
  1157   000731 b7              	OR	A		;or a null.
  1158   000732 ca3e07          	JP	Z,UNKWN6
  1159   000735 fe20            	CP	' '
  1160   000737 ca3e07          	JP	Z,UNKWN6
  1161   00073a 23              	INC	HL
  1162   00073b c33007          	JP	UNKWN5
  1163                          ;
  1164                          ;   Do the line move now. It ends in a null byte.
  1165                          ;
  1166   00073e 0600            UNKWN6:	LD	B,0		;keep a character count.
  1167   000740 118100          	LD	DE,TBUFF+1	;data gets put here.
  1168   000743 7e              UNKWN7:	LD	A,(HL)		;move it now.
  1169   000744 12              	LD	(DE),A
  1170   000745 b7              	OR	A
  1171   000746 ca4f07          	JP	Z,UNKWN8
  1172   000749 04              	INC	B
  1173   00074a 23              	INC	HL
  1174   00074b 13              	INC	DE
  1175   00074c c34307          	JP	UNKWN7
  1176   00074f 78              UNKWN8:	LD	A,B		;now store the character count.
  1177   000750 328000          	LD	(TBUFF),A
  1178   000753 cd9800          	CALL	CRLF		;clean up the screen.
  1179   000756 cdd501          	CALL	STDDMA		;set standard transfer address.
  1180   000759 cd1a01          	CALL	SETCDRV		;reset current drive.
  1181   00075c cd0001          	CALL	TBASE		;and execute the program.
  1182                          ;
  1183                          ;   Transiant programs return here (or reboot).
  1184                          ;
  1185   00075f 31ab07          	LD	SP,BATCH	;set stack first off.
  1186   000762 cd2901          	CALL	MOVECD		;move current drive into place (TDRIVE).
  1187   000765 cdbd00          	CALL	DSKSEL		;and reselect it.
  1188   000768 c38203          	JP	CMMND1		;back to comand mode.
  1189                          ;
  1190                          ;   Get here if some error occured.
  1191                          ;
  1192   00076b cd6604          UNKWN9:	CALL	RESETDR		;inproper format.
  1193   00076e c30902          	JP	SYNERR
  1194   000771 017a07          UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
  1195   000774 cda700          	CALL	PLINE
  1196   000777 c38607          	JP	GETBACK
  1197   00077a 426164206c6f6164BADLOAD:DB	"Bad load",0
                00              
  1198   000783 434f4d          COMFILE:DB	"COM"		;command file extension.
  1199                          ;
  1200                          ;   Get here to return to command level. We will reset the
  1201                          ; previous active drive and then either return to command
  1202                          ; level directly or print error message and then return.
  1203                          ;
  1204   000786 cd6604          GETBACK:CALL	RESETDR		;reset previous drive.
  1205   000789 cd5e02          GETBACK1: CALL	CONVFST		;convert first name in (FCB).
  1206   00078c 3ace07          	LD	A,(FCB+1)	;if this was just a drive change request,
  1207   00078f d620            	SUB	' '		;make sure it was valid.
  1208   000791 21f007          	LD	HL,CHGDRV
  1209   000794 b6              	OR	(HL)
  1210   000795 c20902          	JP	NZ,SYNERR
  1211   000798 c38203          	JP	CMMND1		;ok, return to command level.
  1212                          ;
  1213                          ;   ccp stack area.
  1214                          ;
  1215   00079b 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
  1216                          CCPSTACK EQU	$	;end of ccp stack area.
  1217                          ;
  1218                          ;   Batch (or SUBMIT) processing information storage.
  1219                          ;
  1220   0007ab 00              BATCH:	DB	0		;batch mode flag (0=not active).
  1221   0007ac 0024242420202020BATCHFCB: DB	0,"$$$     SUB",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                2053554200000000
                0000000000000000
                0000000000000000
                00              
  1222                          ;
  1223                          ;   File control block setup by the CCP.
  1224                          ;
  1225   0007cd 0020202020202020FCB:	DB	0,"           ",0,0,0,0,0,"           ",0,0,0,0,0
                2020202000000000
                0020202020202020
                2020202000000000
                00              
  1226   0007ee 00              RTNCODE:DB	0		;status returned from bdos call.
  1227   0007ef 00              CDRIVE:	DB	0		;currently active drive.
  1228   0007f0 00              CHGDRV:	DB	0		;change in drives flag (0=no change).
  1229   0007f1 0000            NBYTES:	DW	0		;byte counter used by TYPE.
  1230                          ;
  1231                          ;   Room for expansion?
  1232                          ;
  1233   0007f3 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000      
  1234                          ;
  1235                          ;   Note that the following six bytes must match those at
  1236                          ; (PATTRN1) or cp/m will HALT. Why?
  1237                          ;
  1238   000800 001600000000    PATTRN2:DB	0,22,0,0,0,0	;(* serial number bytes *).
  1239                          ;
  1240                          ;**************************************************************
  1241                          ;*
  1242                          ;*                    B D O S   E N T R Y
  1243                          ;*
  1244                          ;**************************************************************
  1245                          ;
  1246   000806 c31108          FBASE:	JP	FBASE1
  1247                          ;
  1248                          ;   Bdos error table.
  1249                          ;
  1250   000809 9908            BADSCTR:DW	ERROR1		;bad sector on read or write.
  1251   00080b a508            BADSLCT:DW	ERROR2		;bad disk select.
  1252   00080d ab08            RODISK:	DW	ERROR3		;disk is read only.
  1253   00080f b108            ROFILE:	DW	ERROR4		;file is read only.
  1254                          ;
  1255                          ;   Entry into bdos. (DE) or (E) are the parameters passed. The
  1256                          ; function number desired is in register (C).
  1257                          ;
  1258   000811 eb              FBASE1:	EX	DE,HL		;save the (DE) parameters.
  1259   000812 22430b          	LD	(PARAMS),HL
  1260   000815 eb              	EX	DE,HL
  1261   000816 7b              	LD	A,E		;and save register (E) in particular.
  1262   000817 32d615          	LD	(EPARAM),A
  1263   00081a 210000          	LD	HL,0
  1264   00081d 22450b          	LD	(STATUS),HL	;clear return status.
  1265   000820 39              	ADD	HL,SP
  1266   000821 220f0b          	LD	(USRSTACK),HL	;save users stack pointer.
  1267   000824 31410b          	LD	SP,STKAREA	;and set our own.
  1268   000827 af              	XOR	A		;clear auto select storage space.
  1269   000828 32e015          	LD	(AUTOFLAG),A
  1270   00082b 32de15          	LD	(AUTO),A
  1271   00082e 217415          	LD	HL,GOBACK	;set return address.
  1272   000831 e5              	PUSH	HL
  1273   000832 79              	LD	A,C		;get function number.
  1274   000833 fe29            	CP	NFUNCTS		;valid function number?
  1275   000835 d0              	RET	NC
  1276   000836 4b              	LD	C,E		;keep single register function here.
  1277   000837 214708          	LD	HL,FUNCTNS	;now look thru the function table.
  1278   00083a 5f              	LD	E,A
  1279   00083b 1600            	LD	D,0		;(DE)=function number.
  1280   00083d 19              	ADD	HL,DE
  1281   00083e 19              	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
  1282   00083f 5e              	LD	E,(HL)
  1283   000840 23              	INC	HL
  1284   000841 56              	LD	D,(HL)		;now (DE)=address for this function.
  1285   000842 2a430b          	LD	HL,(PARAMS)	;retrieve parameters.
  1286   000845 eb              	EX	DE,HL		;now (DE) has the original parameters.
  1287   000846 e9              	JP	(HL)		;execute desired function.
  1288                          ;
  1289                          ;   BDOS function jump table.
  1290                          ;
  1291                          NFUNCTS EQU	41		;number of functions in followin table.
  1292                          ;
  1293   000847 03f2c80a9009ce0aFUNCTNS:DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
                12f20ff2d40aed0a
  1294   000857 f30af80ae109fe0a	DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
                7e14831445149c14
  1295   000867 a514ab14c814d714	DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
                e014e614ec14    
  1296   000875 f514fe1404150a15	DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
                11152c0d17151d15
  1297   000885 26152d1541154715	DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
                4d150e145315040b
  1298   000895 040b9b15        	DW	RTN,WTSPECL
  1299                          ;
  1300                          ;   Bdos error message section.
  1301                          ;
  1302   000899 21ca08          ERROR1:	LD	HL,BADSEC	;bad sector message.
  1303   00089c cde508          	CALL	PRTERR		;print it and get a 1 char responce.
  1304   00089f fe03            	CP	CNTRLC		;re-boot request (control-c)?
  1305   0008a1 ca0000          	JP	Z,0		;yes.
  1306   0008a4 c9              	RET			;no, return to retry i/o function.
  1307                          ;
  1308   0008a5 21d508          ERROR2:	LD	HL,BADSEL	;bad drive selected.
  1309   0008a8 c3b408          	JP	ERROR5
  1310                          ;
  1311   0008ab 21e108          ERROR3:	LD	HL,DISKRO	;disk is read only.
  1312   0008ae c3b408          	JP	ERROR5
  1313                          ;
  1314   0008b1 21dc08          ERROR4:	LD	HL,FILERO	;file is read only.
  1315                          ;
  1316   0008b4 cde508          ERROR5:	CALL	PRTERR
  1317   0008b7 c30000          	JP	0		;always reboot on these errors.
  1318                          ;
  1319   0008ba 42646f7320457272BDOSERR:DB	"Bdos Err On "
                204f6e20        
  1320   0008c6 203a2024        BDOSDRV:DB	" : $"
  1321   0008ca 4261642053656374BADSEC:	DB	"Bad Sector$"
                6f7224          
  1322   0008d5 53656c65637424  BADSEL:	DB	"Select$"
  1323   0008dc 46696c6520      FILERO:	DB	"File "
  1324   0008e1 522f4f24        DISKRO:	DB	"R/O$"
  1325                          ;
  1326                          ;   Print bdos error message.
  1327                          ;
  1328   0008e5 e5              PRTERR:	PUSH	HL		;save second message pointer.
  1329   0008e6 cdc909          	CALL	OUTCRLF		;send (cr)(lf).
  1330   0008e9 3a420b          	LD	A,(ACTIVE)	;get active drive.
  1331   0008ec c641            	ADD	A,'A'		;make ascii.
  1332   0008ee 32c608          	LD	(BDOSDRV),A	;and put in message.
  1333   0008f1 01ba08          	LD	BC,BDOSERR	;and print it.
  1334   0008f4 cdd309          	CALL	PRTMESG
  1335   0008f7 c1              	POP	BC		;print second message line now.
  1336   0008f8 cdd309          	CALL	PRTMESG
  1337                          ;
  1338                          ;   Get an input character. We will check our 1 character
  1339                          ; buffer first. This may be set by the console status routine.
  1340                          ;
  1341   0008fb 210e0b          GETCHAR:LD	HL,CHARBUF	;check character buffer.
  1342   0008fe 7e              	LD	A,(HL)		;anything present already?
  1343   0008ff 3600            	LD	(HL),0		;...either case clear it.
  1344   000901 b7              	OR	A
  1345   000902 c0              	RET	NZ		;yes, use it.
  1346   000903 c309f2          	JP	CONIN		;nope, go get a character responce.
  1347                          ;
  1348                          ;   Input and echo a character.
  1349                          ;
  1350   000906 cdfb08          GETECHO:CALL	GETCHAR		;input a character.
  1351   000909 cd1409          	CALL	CHKCHAR		;carriage control?
  1352   00090c d8              	RET	C		;no, a regular control char so don't echo.
  1353   00090d f5              	PUSH	AF		;ok, save character now.
  1354   00090e 4f              	LD	C,A
  1355   00090f cd9009          	CALL	OUTCON		;and echo it.
  1356   000912 f1              	POP	AF		;get character and return.
  1357   000913 c9              	RET
  1358                          ;
  1359                          ;   Check character in (A). Set the zero flag on a carriage
  1360                          ; control character and the carry flag on any other control
  1361                          ; character.
  1362                          ;
  1363   000914 fe0d            CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
  1364   000916 c8              	RET	Z		;or a tab.
  1365   000917 fe0a            	CP	LF
  1366   000919 c8              	RET	Z
  1367   00091a fe09            	CP	TAB
  1368   00091c c8              	RET	Z
  1369   00091d fe08            	CP	BS
  1370   00091f c8              	RET	Z
  1371   000920 fe20            	CP	' '		;other control char? Set carry flag.
  1372   000922 c9              	RET
  1373                          ;
  1374                          ;   Check the console during output. Halt on a control-s, then
  1375                          ; reboot on a control-c. If anything else is ready, clear the
  1376                          ; zero flag and return (the calling routine may want to do
  1377                          ; something).
  1378                          ;
  1379   000923 3a0e0b          CKCONSOL: LD	A,(CHARBUF)	;check buffer.
  1380   000926 b7              	OR	A		;if anything, just return without checking.
  1381   000927 c24509          	JP	NZ,CKCON2
  1382   00092a cd06f2          	CALL	CONST		;nothing in buffer. Check console.
  1383   00092d e601            	AND	01H		;look at bit 0.
  1384   00092f c8              	RET	Z		;return if nothing.
  1385   000930 cd09f2          	CALL	CONIN		;ok, get it.
  1386   000933 fe13            	CP	CNTRLS		;if not control-s, return with zero cleared.
  1387   000935 c24209          	JP	NZ,CKCON1
  1388   000938 cd09f2          	CALL	CONIN		;halt processing until another char
  1389   00093b fe03            	CP	CNTRLC		;is typed. Control-c?
  1390   00093d ca0000          	JP	Z,0		;yes, reboot now.
  1391   000940 af              	XOR	A		;no, just pretend nothing was ever ready.
  1392   000941 c9              	RET
  1393   000942 320e0b          CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
  1394   000945 3e01            CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
  1395   000947 c9              	RET
  1396                          ;
  1397                          ;   Output (C) to the screen. If the printer flip-flop flag
  1398                          ; is set, we will send character to printer also. The console
  1399                          ; will be checked in the process.
  1400                          ;
  1401   000948 3a0a0b          OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
  1402   00094b b7              	OR	A		;anything and we won't generate output.
  1403   00094c c26209          	JP	NZ,OUTCHR1
  1404   00094f c5              	PUSH	BC
  1405   000950 cd2309          	CALL	CKCONSOL	;check console (we don't care whats there).
  1406   000953 c1              	POP	BC
  1407   000954 c5              	PUSH	BC
  1408   000955 cd0cf2          	CALL	CONOUT		;output (C) to the screen.
  1409   000958 c1              	POP	BC
  1410   000959 c5              	PUSH	BC
  1411   00095a 3a0d0b          	LD	A,(PRTFLAG)	;check printer flip-flop flag.
  1412   00095d b7              	OR	A
  1413   00095e c40ff2          	CALL	NZ,LIST		;print it also if non-zero.
  1414   000961 c1              	POP	BC
  1415   000962 79              OUTCHR1:LD	A,C		;update cursors position.
  1416   000963 210c0b          	LD	HL,CURPOS
  1417   000966 fe7f            	CP	DEL		;rubouts don't do anything here.
  1418   000968 c8              	RET	Z
  1419   000969 34              	INC	(HL)		;bump line pointer.
  1420   00096a fe20            	CP	' '		;and return if a normal character.
  1421   00096c d0              	RET	NC
  1422   00096d 35              	DEC	(HL)		;restore and check for the start of the line.
  1423   00096e 7e              	LD	A,(HL)
  1424   00096f b7              	OR	A
  1425   000970 c8              	RET	Z		;ingnore control characters at the start of the line.
  1426   000971 79              	LD	A,C
  1427   000972 fe08            	CP	BS		;is it a backspace?
  1428   000974 c27909          	JP	NZ,OUTCHR2
  1429   000977 35              	DEC	(HL)		;yes, backup pointer.
  1430   000978 c9              	RET
  1431   000979 fe0a            OUTCHR2:CP	LF		;is it a line feed?
  1432   00097b c0              	RET	NZ		;ignore anything else.
  1433   00097c 3600            	LD	(HL),0		;reset pointer to start of line.
  1434   00097e c9              	RET
  1435                          ;
  1436                          ;   Output (A) to the screen. If it is a control character
  1437                          ; (other than carriage control), use ^x format.
  1438                          ;
  1439   00097f 79              SHOWIT:	LD	A,C
  1440   000980 cd1409          	CALL	CHKCHAR		;check character.
  1441   000983 d29009          	JP	NC,OUTCON	;not a control, use normal output.
  1442   000986 f5              	PUSH	AF
  1443   000987 0e5e            	LD	C,'^'		;for a control character, preceed it with '^'.
  1444   000989 cd4809          	CALL	OUTCHAR
  1445   00098c f1              	POP	AF
  1446   00098d f640            	OR	'@'		;and then use the letter equivelant.
  1447   00098f 4f              	LD	C,A
  1448                          ;
  1449                          ;   Function to output (C) to the console device and expand tabs
  1450                          ; if necessary.
  1451                          ;
  1452   000990 79              OUTCON:	LD	A,C
  1453   000991 fe09            	CP	TAB		;is it a tab?
  1454   000993 c24809          	JP	NZ,OUTCHAR	;use regular output.
  1455   000996 0e20            OUTCON1:LD	C,' '		;yes it is, use spaces instead.
  1456   000998 cd4809          	CALL	OUTCHAR
  1457   00099b 3a0c0b          	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
  1458                          
  1459   00099e e607            	AND	07H		;position.
  1460   0009a0 c29609          	JP	NZ,OUTCON1
  1461   0009a3 c9              	RET
  1462                          ;
  1463                          ;   Echo a backspace character. Erase the prevoius character
  1464                          ; on the screen.
  1465                          ;
  1466   0009a4 cdac09          BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
  1467   0009a7 0e20            	LD	C,' '		;then blank that character.
  1468   0009a9 cd0cf2          	CALL	CONOUT
  1469   0009ac 0e08            BACKUP1:LD	C,BS		;then back space once more.
  1470   0009ae c30cf2          	JP	CONOUT
  1471                          ;
  1472                          ;   Signal a deleted line. Print a '#' at the end and start
  1473                          ; over.
  1474                          ;
  1475   0009b1 0e23            NEWLINE:LD	C,'#'
  1476   0009b3 cd4809          	CALL	OUTCHAR		;print this.
  1477   0009b6 cdc909          	CALL	OUTCRLF		;start new line.
  1478   0009b9 3a0c0b          NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
  1479   0009bc 210b0b          	LD	HL,STARTING
  1480   0009bf be              	CP	(HL)
  1481   0009c0 d0              	RET	NC		;there yet?
  1482   0009c1 0e20            	LD	C,' '
  1483   0009c3 cd4809          	CALL	OUTCHAR		;nope, keep going.
  1484   0009c6 c3b909          	JP	NEWLN1
  1485                          ;
  1486                          ;   Output a (cr) (lf) to the console device (screen).
  1487                          ;
  1488   0009c9 0e0d            OUTCRLF:LD	C,CR
  1489   0009cb cd4809          	CALL	OUTCHAR
  1490   0009ce 0e0a            	LD	C,LF
  1491   0009d0 c34809          	JP	OUTCHAR
  1492                          ;
  1493                          ;   Print message pointed to by (BC). It will end with a '$'.
  1494                          ;
  1495   0009d3 0a              PRTMESG:LD	A,(BC)		;check for terminating character.
  1496   0009d4 fe24            	CP	'$'
  1497   0009d6 c8              	RET	Z
  1498   0009d7 03              	INC	BC
  1499   0009d8 c5              	PUSH	BC		;otherwise, bump pointer and print it.
  1500   0009d9 4f              	LD	C,A
  1501   0009da cd9009          	CALL	OUTCON
  1502   0009dd c1              	POP	BC
  1503   0009de c3d309          	JP	PRTMESG
  1504                          ;
  1505                          ;   Function to execute a buffered read.
  1506                          ;
  1507   0009e1 3a0c0b          RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
  1508   0009e4 320b0b          	LD	(STARTING),A
  1509   0009e7 2a430b          	LD	HL,(PARAMS)	;get the maximum buffer space.
  1510   0009ea 4e              	LD	C,(HL)
  1511   0009eb 23              	INC	HL		;point to first available space.
  1512   0009ec e5              	PUSH	HL		;and save.
  1513   0009ed 0600            	LD	B,0		;keep a character count.
  1514   0009ef c5              RDBUF1:	PUSH	BC
  1515   0009f0 e5              	PUSH	HL
  1516   0009f1 cdfb08          RDBUF2:	CALL	GETCHAR		;get the next input character.
  1517   0009f4 e67f            	AND	7FH		;strip bit 7.
  1518   0009f6 e1              	POP	HL		;reset registers.
  1519   0009f7 c1              	POP	BC
  1520   0009f8 fe0d            	CP	CR		;en of the line?
  1521   0009fa cac10a          	JP	Z,RDBUF17
  1522   0009fd fe0a            	CP	LF
  1523   0009ff cac10a          	JP	Z,RDBUF17
  1524   000a02 fe08            	CP	BS		;how about a backspace?
  1525   000a04 c2160a          	JP	NZ,RDBUF3
  1526   000a07 78              	LD	A,B		;yes, but ignore at the beginning of the line.
  1527   000a08 b7              	OR	A
  1528   000a09 caef09          	JP	Z,RDBUF1
  1529   000a0c 05              	DEC	B		;ok, update counter.
  1530   000a0d 3a0c0b          	LD	A,(CURPOS)	;if we backspace to the start of the line,
  1531   000a10 320a0b          	LD	(OUTFLAG),A	;treat as a cancel (control-x).
  1532   000a13 c3700a          	JP	RDBUF10
  1533   000a16 fe7f            RDBUF3:	CP	DEL		;user typed a rubout?
  1534   000a18 c2260a          	JP	NZ,RDBUF4
  1535   000a1b 78              	LD	A,B		;ignore at the start of the line.
  1536   000a1c b7              	OR	A
  1537   000a1d caef09          	JP	Z,RDBUF1
  1538   000a20 7e              	LD	A,(HL)		;ok, echo the prevoius character.
  1539   000a21 05              	DEC	B		;and reset pointers (counters).
  1540   000a22 2b              	DEC	HL
  1541   000a23 c3a90a          	JP	RDBUF15
  1542   000a26 fe05            RDBUF4:	CP	CNTRLE		;physical end of line?
  1543   000a28 c2370a          	JP	NZ,RDBUF5
  1544   000a2b c5              	PUSH	BC		;yes, do it.
  1545   000a2c e5              	PUSH	HL
  1546   000a2d cdc909          	CALL	OUTCRLF
  1547   000a30 af              	XOR	A		;and update starting position.
  1548   000a31 320b0b          	LD	(STARTING),A
  1549   000a34 c3f109          	JP	RDBUF2
  1550   000a37 fe10            RDBUF5:	CP	CNTRLP		;control-p?
  1551   000a39 c2480a          	JP	NZ,RDBUF6
  1552   000a3c e5              	PUSH	HL		;yes, flip the print flag filp-flop byte.
  1553   000a3d 210d0b          	LD	HL,PRTFLAG
  1554   000a40 3e01            	LD	A,1		;PRTFLAG=1-PRTFLAG
  1555   000a42 96              	SUB	(HL)
  1556   000a43 77              	LD	(HL),A
  1557   000a44 e1              	POP	HL
  1558   000a45 c3ef09          	JP	RDBUF1
  1559   000a48 fe18            RDBUF6:	CP	CNTRLX		;control-x (cancel)?
  1560   000a4a c25f0a          	JP	NZ,RDBUF8
  1561   000a4d e1              	POP	HL
  1562   000a4e 3a0b0b          RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
  1563   000a51 210c0b          	LD	HL,CURPOS
  1564   000a54 be              	CP	(HL)
  1565   000a55 d2e109          	JP	NC,RDBUFF	;done yet?
  1566   000a58 35              	DEC	(HL)		;no, decrement pointer and output back up one space.
  1567   000a59 cda409          	CALL	BACKUP
  1568   000a5c c34e0a          	JP	RDBUF7
  1569   000a5f fe15            RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
  1570   000a61 c26b0a          	JP	NZ,RDBUF9
  1571   000a64 cdb109          	CALL	NEWLINE		;start a new line.
  1572   000a67 e1              	POP	HL
  1573   000a68 c3e109          	JP	RDBUFF
  1574   000a6b fe12            RDBUF9:	CP	CNTRLR		;control-r?
  1575   000a6d c2a60a          	JP	NZ,RDBUF14
  1576   000a70 c5              RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
  1577   000a71 cdb109          	CALL	NEWLINE
  1578   000a74 c1              	POP	BC
  1579   000a75 e1              	POP	HL
  1580   000a76 e5              	PUSH	HL
  1581   000a77 c5              	PUSH	BC
  1582   000a78 78              RDBUF11:LD	A,B		;done whole line yet?
  1583   000a79 b7              	OR	A
  1584   000a7a ca8a0a          	JP	Z,RDBUF12
  1585   000a7d 23              	INC	HL		;nope, get next character.
  1586   000a7e 4e              	LD	C,(HL)
  1587   000a7f 05              	DEC	B		;count it.
  1588   000a80 c5              	PUSH	BC
  1589   000a81 e5              	PUSH	HL
  1590   000a82 cd7f09          	CALL	SHOWIT		;and display it.
  1591   000a85 e1              	POP	HL
  1592   000a86 c1              	POP	BC
  1593   000a87 c3780a          	JP	RDBUF11
  1594   000a8a e5              RDBUF12:PUSH	HL		;done with line. If we were displaying
  1595   000a8b 3a0a0b          	LD	A,(OUTFLAG)	;then update cursor position.
  1596   000a8e b7              	OR	A
  1597   000a8f caf109          	JP	Z,RDBUF2
  1598   000a92 210c0b          	LD	HL,CURPOS	;because this line is shorter, we must
  1599   000a95 96              	SUB	(HL)		;back up the cursor (not the screen however)
  1600   000a96 320a0b          	LD	(OUTFLAG),A	;some number of positions.
  1601   000a99 cda409          RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
  1602   000a9c 210a0b          	LD	HL,OUTFLAG	;zero, the screen will not be changed.
  1603   000a9f 35              	DEC	(HL)
  1604   000aa0 c2990a          	JP	NZ,RDBUF13
  1605   000aa3 c3f109          	JP	RDBUF2		;now just get the next character.
  1606                          ;
  1607                          ;   Just a normal character, put this in our buffer and echo.
  1608                          ;
  1609   000aa6 23              RDBUF14:INC	HL
  1610   000aa7 77              	LD	(HL),A		;store character.
  1611   000aa8 04              	INC	B		;and count it.
  1612   000aa9 c5              RDBUF15:PUSH	BC
  1613   000aaa e5              	PUSH	HL
  1614   000aab 4f              	LD	C,A		;echo it now.
  1615   000aac cd7f09          	CALL	SHOWIT
  1616   000aaf e1              	POP	HL
  1617   000ab0 c1              	POP	BC
  1618   000ab1 7e              	LD	A,(HL)		;was it an abort request?
  1619   000ab2 fe03            	CP	CNTRLC		;control-c abort?
  1620   000ab4 78              	LD	A,B
  1621   000ab5 c2bd0a          	JP	NZ,RDBUF16
  1622   000ab8 fe01            	CP	1		;only if at start of line.
  1623   000aba ca0000          	JP	Z,0
  1624   000abd b9              RDBUF16:CP	C		;nope, have we filled the buffer?
  1625   000abe daef09          	JP	C,RDBUF1
  1626   000ac1 e1              RDBUF17:POP	HL		;yes end the line and return.
  1627   000ac2 70              	LD	(HL),B
  1628   000ac3 0e0d            	LD	C,CR
  1629   000ac5 c34809          	JP	OUTCHAR		;output (cr) and return.
  1630                          ;
  1631                          ;   Function to get a character from the console device.
  1632                          ;
  1633   000ac8 cd0609          GETCON:	CALL	GETECHO		;get and echo.
  1634   000acb c3010b          	JP	SETSTAT		;save status and return.
  1635                          ;
  1636                          ;   Function to get a character from the tape reader device.
  1637                          ;
  1638   000ace cd15f2          GETRDR:	CALL	READER		;get a character from reader, set status and return.
  1639   000ad1 c3010b          	JP	SETSTAT
  1640                          ;
  1641                          ;  Function to perform direct console i/o. If (C) contains (FF)
  1642                          ; then this is an input request. If (C) contains (FE) then
  1643                          ; this is a status request. Otherwise we are to output (C).
  1644                          ;
  1645   000ad4 79              DIRCIO:	LD	A,C		;test for (FF).
  1646   000ad5 3c              	INC	A
  1647   000ad6 cae00a          	JP	Z,DIRC1
  1648   000ad9 3c              	INC	A		;test for (FE).
  1649   000ada ca06f2          	JP	Z,CONST
  1650   000add c30cf2          	JP	CONOUT		;just output (C).
  1651   000ae0 cd06f2          DIRC1:	CALL	CONST		;this is an input request.
  1652   000ae3 b7              	OR	A
  1653   000ae4 ca9115          	JP	Z,GOBACK1	;not ready? Just return (directly).
  1654   000ae7 cd09f2          	CALL	CONIN		;yes, get character.
  1655   000aea c3010b          	JP	SETSTAT		;set status and return.
  1656                          ;
  1657                          ;   Function to return the i/o byte.
  1658                          ;
  1659   000aed 3a0300          GETIOB:	LD	A,(IOBYTE)
  1660   000af0 c3010b          	JP	SETSTAT
  1661                          ;
  1662                          ;   Function to set the i/o byte.
  1663                          ;
  1664   000af3 210300          SETIOB:	LD	HL,IOBYTE
  1665   000af6 71              	LD	(HL),C
  1666   000af7 c9              	RET
  1667                          ;
  1668                          ;   Function to print the character string pointed to by (DE)
  1669                          ; on the console device. The string ends with a '$'.
  1670                          ;
  1671   000af8 eb              PRTSTR:	EX	DE,HL
  1672   000af9 4d              	LD	C,L
  1673   000afa 44              	LD	B,H		;now (BC) points to it.
  1674   000afb c3d309          	JP	PRTMESG
  1675                          ;
  1676                          ;   Function to interigate the console device.
  1677                          ;
  1678   000afe cd2309          GETCSTS:CALL	CKCONSOL
  1679                          ;
  1680                          ;   Get here to set the status and return to the cleanup
  1681                          ; section. Then back to the user.
  1682                          ;
  1683   000b01 32450b          SETSTAT:LD	(STATUS),A
  1684   000b04 c9              RTN:	RET
  1685                          ;
  1686                          ;   Set the status to 1 (read or write error code).
  1687                          ;
  1688   000b05 3e01            IOERR1:	LD	A,1
  1689   000b07 c3010b          	JP	SETSTAT
  1690                          ;
  1691   000b0a 00              OUTFLAG:DB	0		;output flag (non zero means no output).
  1692   000b0b 02              STARTING: DB	2		;starting position for cursor.
  1693   000b0c 00              CURPOS:	DB	0		;cursor position (0=start of line).
  1694   000b0d 00              PRTFLAG:DB	0		;printer flag (control-p toggle). List if non zero.
  1695   000b0e 00              CHARBUF:DB	0		;single input character buffer.
  1696                          ;
  1697                          ;   Stack area for BDOS calls.
  1698                          ;
  1699   000b0f 0000            USRSTACK: DW	0		;save users stack pointer here.
  1700                          ;
  1701   000b11 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                0000000000000000
  1702   000b29 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                0000000000000000
  1703                          STKAREA EQU	$		;end of stack area.
  1704                          ;
  1705   000b41 00              USERNO:	DB	0		;current user number.
  1706   000b42 00              ACTIVE:	DB	0		;currently active drive.
  1707   000b43 0000            PARAMS:	DW	0		;save (DE) parameters here on entry.
  1708   000b45 0000            STATUS:	DW	0		;status returned from bdos function.
  1709                          ;
  1710                          ;   Select error occured, jump to error routine.
  1711                          ;
  1712   000b47 210b08          SLCTERR:LD	HL,BADSLCT
  1713                          ;
  1714                          ;   Jump to (HL) indirectly.
  1715                          ;
  1716   000b4a 5e              JUMPHL:	LD	E,(HL)
  1717   000b4b 23              	INC	HL
  1718   000b4c 56              	LD	D,(HL)		;now (DE) contain the desired address.
  1719   000b4d eb              	EX	DE,HL
  1720   000b4e e9              	JP	(HL)
  1721                          ;
  1722                          ;   Block move. (DE) to (HL), (C) bytes total.
  1723                          ;
  1724   000b4f 0c              DE2HL:	INC	C		;is count down to zero?
  1725   000b50 0d              DE2HL1:	DEC	C
  1726   000b51 c8              	RET	Z		;yes, we are done.
  1727   000b52 1a              	LD	A,(DE)		;no, move one more byte.
  1728   000b53 77              	LD	(HL),A
  1729   000b54 13              	INC	DE
  1730   000b55 23              	INC	HL
  1731   000b56 c3500b          	JP	DE2HL1		;and repeat.
  1732                          ;
  1733                          ;   Select the desired drive.
  1734                          ;
  1735   000b59 3a420b          SELECT:	LD	A,(ACTIVE)	;get active disk.
  1736   000b5c 4f              	LD	C,A
  1737   000b5d cd1bf2          	CALL	SELDSK		;select it.
  1738   000b60 7c              	LD	A,H		;valid drive?
  1739   000b61 b5              	OR	L		;valid drive?
  1740   000b62 c8              	RET	Z		;return if not.
  1741                          ;
  1742                          ;   Here, the BIOS returned the address of the parameter block
  1743                          ; in (HL). We will extract the necessary pointers and save them.
  1744                          ;
  1745   000b63 5e              	LD	E,(HL)		;yes, get address of translation table into (DE).
  1746   000b64 23              	INC	HL
  1747   000b65 56              	LD	D,(HL)
  1748   000b66 23              	INC	HL
  1749   000b67 22b315          	LD	(SCRATCH1),HL	;save pointers to scratch areas.
  1750   000b6a 23              	INC	HL
  1751   000b6b 23              	INC	HL
  1752   000b6c 22b515          	LD	(SCRATCH2),HL	;ditto.
  1753   000b6f 23              	INC	HL
  1754   000b70 23              	INC	HL
  1755   000b71 22b715          	LD	(SCRATCH3),HL	;ditto.
  1756   000b74 23              	INC	HL
  1757   000b75 23              	INC	HL
  1758   000b76 eb              	EX	DE,HL		;now save the translation table address.
  1759   000b77 22d015          	LD	(XLATE),HL
  1760   000b7a 21b915          	LD	HL,DIRBUF	;put the next 8 bytes here.
  1761   000b7d 0e08            	LD	C,8		;they consist of the directory buffer
  1762   000b7f cd4f0b          	CALL	DE2HL		;pointer, parameter block pointer,
  1763   000b82 2abb15          	LD	HL,(DISKPB)	;check and allocation vectors.
  1764   000b85 eb              	EX	DE,HL
  1765   000b86 21c115          	LD	HL,SECTORS	;move parameter block into our ram.
  1766   000b89 0e0f            	LD	C,15		;it is 15 bytes long.
  1767   000b8b cd4f0b          	CALL	DE2HL
  1768   000b8e 2ac615          	LD	HL,(DSKSIZE)	;check disk size.
  1769   000b91 7c              	LD	A,H		;more than 256 blocks on this?
  1770   000b92 21dd15          	LD	HL,BIGDISK
  1771   000b95 36ff            	LD	(HL),0FFH	;set to samll.
  1772   000b97 b7              	OR	A
  1773   000b98 ca9d0b          	JP	Z,SELECT1
  1774   000b9b 3600            	LD	(HL),0		;wrong, set to large.
  1775   000b9d 3eff            SELECT1:LD	A,0FFH		;clear the zero flag.
  1776   000b9f b7              	OR	A
  1777   000ba0 c9              	RET
  1778                          ;
  1779                          ;   Routine to home the disk track head and clear pointers.
  1780                          ;
  1781   000ba1 cd18f2          HOMEDRV:CALL	HOME		;home the head.
  1782   000ba4 af              	XOR	A
  1783   000ba5 2ab515          	LD	HL,(SCRATCH2)	;set our track pointer also.
  1784   000ba8 77              	LD	(HL),A
  1785   000ba9 23              	INC	HL
  1786   000baa 77              	LD	(HL),A
  1787   000bab 2ab715          	LD	HL,(SCRATCH3)	;and our sector pointer.
  1788   000bae 77              	LD	(HL),A
  1789   000baf 23              	INC	HL
  1790   000bb0 77              	LD	(HL),A
  1791   000bb1 c9              	RET
  1792                          ;
  1793                          ;   Do the actual disk read and check the error return status.
  1794                          ;
  1795   000bb2 cd27f2          DOREAD:	CALL	READ
  1796   000bb5 c3bb0b          	JP	IORET
  1797                          ;
  1798                          ;   Do the actual disk write and handle any bios error.
  1799                          ;
  1800   000bb8 cd2af2          DOWRITE:CALL	WRITE
  1801   000bbb b7              IORET:	OR	A
  1802   000bbc c8              	RET	Z		;return unless an error occured.
  1803   000bbd 210908          	LD	HL,BADSCTR	;bad read/write on this sector.
  1804   000bc0 c34a0b          	JP	JUMPHL
  1805                          ;
  1806                          ;   Routine to select the track and sector that the desired
  1807                          ; block number falls in.
  1808                          ;
  1809   000bc3 2aea15          TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
  1810   000bc6 0e02            	LD	C,2		;in directory and compute sector #.
  1811   000bc8 cdea0c          	CALL	SHIFTR		;sector #=file-position/4.
  1812   000bcb 22e515          	LD	(BLKNMBR),HL	;save this as the block number of interest.
  1813   000bce 22ec15          	LD	(CKSUMTBL),HL	;what's it doing here too?
  1814                          ;
  1815                          ;   if the sector number has already been set (BLKNMBR), enter
  1816                          ; at this point.
  1817                          ;
  1818   000bd1 21e515          TRKSEC1:LD	HL,BLKNMBR
  1819   000bd4 4e              	LD	C,(HL)		;move sector number into (BC).
  1820   000bd5 23              	INC	HL
  1821   000bd6 46              	LD	B,(HL)
  1822   000bd7 2ab715          	LD	HL,(SCRATCH3)	;get current sector number and
  1823   000bda 5e              	LD	E,(HL)		;move this into (DE).
  1824   000bdb 23              	INC	HL
  1825   000bdc 56              	LD	D,(HL)
  1826   000bdd 2ab515          	LD	HL,(SCRATCH2)	;get current track number.
  1827   000be0 7e              	LD	A,(HL)		;and this into (HL).
  1828   000be1 23              	INC	HL
  1829   000be2 66              	LD	H,(HL)
  1830   000be3 6f              	LD	L,A
  1831   000be4 79              TRKSEC2:LD	A,C		;is desired sector before current one?
  1832   000be5 93              	SUB	E
  1833   000be6 78              	LD	A,B
  1834   000be7 9a              	SBC	A,D
  1835   000be8 d2fa0b          	JP	NC,TRKSEC3
  1836   000beb e5              	PUSH	HL		;yes, decrement sectors by one track.
  1837   000bec 2ac115          	LD	HL,(SECTORS)	;get sectors per track.
  1838   000bef 7b              	LD	A,E
  1839   000bf0 95              	SUB	L
  1840   000bf1 5f              	LD	E,A
  1841   000bf2 7a              	LD	A,D
  1842   000bf3 9c              	SBC	A,H
  1843   000bf4 57              	LD	D,A		;now we have backed up one full track.
  1844   000bf5 e1              	POP	HL
  1845   000bf6 2b              	DEC	HL		;adjust track counter.
  1846   000bf7 c3e40b          	JP	TRKSEC2
  1847   000bfa e5              TRKSEC3:PUSH	HL		;desired sector is after current one.
  1848   000bfb 2ac115          	LD	HL,(SECTORS)	;get sectors per track.
  1849   000bfe 19              	ADD	HL,DE		;bump sector pointer to next track.
  1850   000bff da0f0c          	JP	C,TRKSEC4
  1851   000c02 79              	LD	A,C		;is desired sector now before current one?
  1852   000c03 95              	SUB	L
  1853   000c04 78              	LD	A,B
  1854   000c05 9c              	SBC	A,H
  1855   000c06 da0f0c          	JP	C,TRKSEC4
  1856   000c09 eb              	EX	DE,HL		;not yes, increment track counter
  1857   000c0a e1              	POP	HL		;and continue until it is.
  1858   000c0b 23              	INC	HL
  1859   000c0c c3fa0b          	JP	TRKSEC3
  1860                          ;
  1861                          ;   here we have determined the track number that contains the
  1862                          ; desired sector.
  1863                          ;
  1864   000c0f e1              TRKSEC4:POP	HL		;get track number (HL).
  1865   000c10 c5              	PUSH	BC
  1866   000c11 d5              	PUSH	DE
  1867   000c12 e5              	PUSH	HL
  1868   000c13 eb              	EX	DE,HL
  1869   000c14 2ace15          	LD	HL,(OFFSET)	;adjust for first track offset.
  1870   000c17 19              	ADD	HL,DE
  1871   000c18 44              	LD	B,H
  1872   000c19 4d              	LD	C,L
  1873   000c1a cd1ef2          	CALL	SETTRK		;select this track.
  1874   000c1d d1              	POP	DE		;reset current track pointer.
  1875   000c1e 2ab515          	LD	HL,(SCRATCH2)
  1876   000c21 73              	LD	(HL),E
  1877   000c22 23              	INC	HL
  1878   000c23 72              	LD	(HL),D
  1879   000c24 d1              	POP	DE
  1880   000c25 2ab715          	LD	HL,(SCRATCH3)	;reset the first sector on this track.
  1881   000c28 73              	LD	(HL),E
  1882   000c29 23              	INC	HL
  1883   000c2a 72              	LD	(HL),D
  1884   000c2b c1              	POP	BC
  1885   000c2c 79              	LD	A,C		;now subtract the desired one.
  1886   000c2d 93              	SUB	E		;to make it relative (1-# sectors/track).
  1887   000c2e 4f              	LD	C,A
  1888   000c2f 78              	LD	A,B
  1889   000c30 9a              	SBC	A,D
  1890   000c31 47              	LD	B,A
  1891   000c32 2ad015          	LD	HL,(XLATE)	;translate this sector according to this table.
  1892   000c35 eb              	EX	DE,HL
  1893   000c36 cd30f2          	CALL	SECTRN		;let the bios translate it.
  1894   000c39 4d              	LD	C,L
  1895   000c3a 44              	LD	B,H
  1896   000c3b c321f2          	JP	SETSEC		;and select it.
  1897                          ;
  1898                          ;   Compute block number from record number (SAVNREC) and
  1899                          ; extent number (SAVEXT).
  1900                          ;
  1901   000c3e 21c315          GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
  1902   000c41 4e              	LD	C,(HL)		;note that this is base 2 log of ratio.
  1903   000c42 3ae315          	LD	A,(SAVNREC)	;get record number.
  1904   000c45 b7              GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
  1905   000c46 1f              	RRA
  1906   000c47 0d              	DEC	C
  1907   000c48 c2450c          	JP	NZ,GETBLK1
  1908   000c4b 47              	LD	B,A		;save result in (B).
  1909   000c4c 3e08            	LD	A,8
  1910   000c4e 96              	SUB	(HL)
  1911   000c4f 4f              	LD	C,A		;compute (C)=8-BLKSHFT.
  1912   000c50 3ae215          	LD	A,(SAVEXT)
  1913   000c53 0d              GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
  1914   000c54 ca5c0c          	JP	Z,GETBLK3
  1915   000c57 b7              	OR	A
  1916   000c58 17              	RLA
  1917   000c59 c3530c          	JP	GETBLK2
  1918   000c5c 80              GETBLK3:ADD	A,B
  1919   000c5d c9              	RET
  1920                          ;
  1921                          ;   Routine to extract the (BC) block byte from the fcb pointed
  1922                          ; to by (PARAMS). If this is a big-disk, then these are 16 bit
  1923                          ; block numbers, else they are 8 bit numbers.
  1924                          ; Number is returned in (HL).
  1925                          ;
  1926   000c5e 2a430b          EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
  1927   000c61 111000          	LD	DE,16		;block numbers start 16 bytes into fcb.
  1928   000c64 19              	ADD	HL,DE
  1929   000c65 09              	ADD	HL,BC
  1930   000c66 3add15          	LD	A,(BIGDISK)	;are we using a big-disk?
  1931   000c69 b7              	OR	A
  1932   000c6a ca710c          	JP	Z,EXTBLK1
  1933   000c6d 6e              	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
  1934   000c6e 2600            	LD	H,0
  1935   000c70 c9              	RET
  1936   000c71 09              EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
  1937   000c72 5e              	LD	E,(HL)
  1938   000c73 23              	INC	HL
  1939   000c74 56              	LD	D,(HL)
  1940   000c75 eb              	EX	DE,HL		;return in (HL).
  1941   000c76 c9              	RET
  1942                          ;
  1943                          ;   Compute block number.
  1944                          ;
  1945   000c77 cd3e0c          COMBLK:	CALL	GETBLOCK
  1946   000c7a 4f              	LD	C,A
  1947   000c7b 0600            	LD	B,0
  1948   000c7d cd5e0c          	CALL	EXTBLK
  1949   000c80 22e515          	LD	(BLKNMBR),HL
  1950   000c83 c9              	RET
  1951                          ;
  1952                          ;   Check for a zero block number (unused).
  1953                          ;
  1954   000c84 2ae515          CHKBLK:	LD	HL,(BLKNMBR)
  1955   000c87 7d              	LD	A,L		;is it zero?
  1956   000c88 b4              	OR	H
  1957   000c89 c9              	RET
  1958                          ;
  1959                          ;   Adjust physical block (BLKNMBR) and convert to logical
  1960                          ; sector (LOGSECT). This is the starting sector of this block.
  1961                          ; The actual sector of interest is then added to this and the
  1962                          ; resulting sector number is stored back in (BLKNMBR). This
  1963                          ; will still have to be adjusted for the track number.
  1964                          ;
  1965   000c8a 3ac315          LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
  1966   000c8d 2ae515          	LD	HL,(BLKNMBR)	;get physical sector desired.
  1967   000c90 29              LOGICL1:ADD	HL,HL		;compute logical sector number.
  1968   000c91 3d              	DEC	A		;note logical sectors are 128 bytes long.
  1969   000c92 c2900c          	JP	NZ,LOGICL1
  1970   000c95 22e715          	LD	(LOGSECT),HL	;save logical sector.
  1971   000c98 3ac415          	LD	A,(BLKMASK)	;get block mask.
  1972   000c9b 4f              	LD	C,A
  1973   000c9c 3ae315          	LD	A,(SAVNREC)	;get next sector to access.
  1974   000c9f a1              	AND	C		;extract the relative position within physical block.
  1975   000ca0 b5              	OR	L		;and add it too logical sector.
  1976   000ca1 6f              	LD	L,A
  1977   000ca2 22e515          	LD	(BLKNMBR),HL	;and store.
  1978   000ca5 c9              	RET
  1979                          ;
  1980                          ;   Set (HL) to point to extent byte in fcb.
  1981                          ;
  1982   000ca6 2a430b          SETEXT:	LD	HL,(PARAMS)
  1983   000ca9 110c00          	LD	DE,12		;it is the twelth byte.
  1984   000cac 19              	ADD	HL,DE
  1985   000cad c9              	RET
  1986                          ;
  1987                          ;   Set (HL) to point to record count byte in fcb and (DE) to
  1988                          ; next record number byte.
  1989                          ;
  1990   000cae 2a430b          SETHLDE:LD	HL,(PARAMS)
  1991   000cb1 110f00          	LD	DE,15		;record count byte (#15).
  1992   000cb4 19              	ADD	HL,DE
  1993   000cb5 eb              	EX	DE,HL
  1994   000cb6 211100          	LD	HL,17		;next record number (#32).
  1995   000cb9 19              	ADD	HL,DE
  1996   000cba c9              	RET
  1997                          ;
  1998                          ;   Save current file data from fcb.
  1999                          ;
  2000   000cbb cdae0c          STRDATA:CALL	SETHLDE
  2001   000cbe 7e              	LD	A,(HL)		;get and store record count byte.
  2002   000cbf 32e315          	LD	(SAVNREC),A
  2003   000cc2 eb              	EX	DE,HL
  2004   000cc3 7e              	LD	A,(HL)		;get and store next record number byte.
  2005   000cc4 32e115          	LD	(SAVNXT),A
  2006   000cc7 cda60c          	CALL	SETEXT		;point to extent byte.
  2007   000cca 3ac515          	LD	A,(EXTMASK)	;get extent mask.
  2008   000ccd a6              	AND	(HL)
  2009   000cce 32e215          	LD	(SAVEXT),A	;and save extent here.
  2010   000cd1 c9              	RET
  2011                          ;
  2012                          ;   Set the next record to access. If (MODE) is set to 2, then
  2013                          ; the last record byte (SAVNREC) has the correct number to access.
  2014                          ; For sequential access, (MODE) will be equal to 1.
  2015                          ;
  2016   000cd2 cdae0c          SETNREC:CALL	SETHLDE
  2017   000cd5 3ad515          	LD	A,(MODE)	;get sequential flag (=1).
  2018   000cd8 fe02            	CP	2		;a 2 indicates that no adder is needed.
  2019   000cda c2de0c          	JP	NZ,STNREC1
  2020   000cdd af              	XOR	A		;clear adder (random access?).
  2021   000cde 4f              STNREC1:LD	C,A
  2022   000cdf 3ae315          	LD	A,(SAVNREC)	;get last record number.
  2023   000ce2 81              	ADD	A,C		;increment record count.
  2024   000ce3 77              	LD	(HL),A		;and set fcb's next record byte.
  2025   000ce4 eb              	EX	DE,HL
  2026   000ce5 3ae115          	LD	A,(SAVNXT)	;get next record byte from storage.
  2027   000ce8 77              	LD	(HL),A		;and put this into fcb as number of records used.
  2028   000ce9 c9              	RET
  2029                          ;
  2030                          ;   Shift (HL) right (C) bits.
  2031                          ;
  2032   000cea 0c              SHIFTR:	INC	C
  2033   000ceb 0d              SHIFTR1:DEC	C
  2034   000cec c8              	RET	Z
  2035   000ced 7c              	LD	A,H
  2036   000cee b7              	OR	A
  2037   000cef 1f              	RRA
  2038   000cf0 67              	LD	H,A
  2039   000cf1 7d              	LD	A,L
  2040   000cf2 1f              	RRA
  2041   000cf3 6f              	LD	L,A
  2042   000cf4 c3eb0c          	JP	SHIFTR1
  2043                          ;
  2044                          ;   Compute the check-sum for the directory buffer. Return
  2045                          ; integer sum in (A).
  2046                          ;
  2047   000cf7 0e80            CHECKSUM:	LD	C,128		;length of buffer.
  2048   000cf9 2ab915          		LD	HL,(DIRBUF)	;get its location.
  2049   000cfc af              		XOR	A		;clear summation byte.
  2050   000cfd 86              CHKSUM1:	ADD	A, (HL)		;and compute sum ignoring carries.
  2051   000cfe 23              		INC	HL
  2052   000cff 0d              		DEC	C
  2053   000d00 c2fd0c          		JP	NZ,CHKSUM1
  2054   000d03 c9              		RET
  2055                          ;
  2056                          ;   Shift (HL) left (C) bits.
  2057                          ;
  2058   000d04 0c              SHIFTL:		INC	C
  2059   000d05 0d              SHIFTL1:	DEC	C
  2060   000d06 c8              		RET	Z
  2061   000d07 29              		ADD	HL,HL		;shift left 1 bit.
  2062   000d08 c3050d          		JP	SHIFTL1
  2063                          ;
  2064                          ;   Routine to set a bit in a 16 bit value contained in (BC).
  2065                          ; The bit set depends on the current drive selection.
  2066                          ;
  2067   000d0b c5              SETBIT:	PUSH	BC		;save 16 bit word.
  2068   000d0c 3a420b          	LD	A,(ACTIVE)	;get active drive.
  2069   000d0f 4f              	LD	C,A
  2070   000d10 210100          	LD	HL,1
  2071   000d13 cd040d          	CALL	SHIFTL		;shift bit 0 into place.
  2072   000d16 c1              	POP	BC		;now 'or' this with the original word.
  2073   000d17 79              	LD	A,C
  2074   000d18 b5              	OR	L
  2075   000d19 6f              	LD	L,A		;low byte done, do high byte.
  2076   000d1a 78              	LD	A,B
  2077   000d1b b4              	OR	H
  2078   000d1c 67              	LD	H,A
  2079   000d1d c9              	RET
  2080                          ;
  2081                          ;   Extract the write protect status bit for the current drive.
  2082                          ; The result is returned in (A), bit 0.
  2083                          ;
  2084   000d1e 2aad15          GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
  2085   000d21 3a420b          	LD	A,(ACTIVE)	;which drive is current?
  2086   000d24 4f              	LD	C,A
  2087   000d25 cdea0c          	CALL	SHIFTR		;shift status such that bit 0 is the
  2088   000d28 7d              	LD	A,L		;one of interest for this drive.
  2089   000d29 e601            	AND	01H		;and isolate it.
  2090   000d2b c9              	RET
  2091                          ;
  2092                          ;   Function to write protect the current disk.
  2093                          ;
  2094   000d2c 21ad15          WRTPRTD:LD	HL,WRTPRT	;point to status word.
  2095   000d2f 4e              	LD	C,(HL)		;set (BC) equal to the status.
  2096   000d30 23              	INC	HL
  2097   000d31 46              	LD	B,(HL)
  2098   000d32 cd0b0d          	CALL	SETBIT		;and set this bit according to current drive.
  2099   000d35 22ad15          	LD	(WRTPRT),HL	;then save.
  2100   000d38 2ac815          	LD	HL,(DIRSIZE)	;now save directory size limit.
  2101   000d3b 23              	INC	HL		;remember the last one.
  2102   000d3c eb              	EX	DE,HL
  2103   000d3d 2ab315          	LD	HL,(SCRATCH1)	;and store it here.
  2104   000d40 73              	LD	(HL),E		;put low byte.
  2105   000d41 23              	INC	HL
  2106   000d42 72              	LD	(HL),D		;then high byte.
  2107   000d43 c9              	RET
  2108                          ;
  2109                          ;   Check for a read only file.
  2110                          ;
  2111   000d44 cd5e0d          CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
  2112   000d47 110900          CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
  2113   000d4a 19              	ADD	HL,DE
  2114   000d4b 7e              	LD	A,(HL)
  2115   000d4c 17              	RLA
  2116   000d4d d0              	RET	NC		;return if ok.
  2117   000d4e 210f08          	LD	HL,ROFILE	;else, print error message and terminate.
  2118   000d51 c34a0b          	JP	JUMPHL
  2119                          ;
  2120                          ;   Check the write protect status of the active disk.
  2121                          ;
  2122   000d54 cd1e0d          CHKWPRT:CALL	GETWPRT
  2123   000d57 c8              	RET	Z		;return if ok.
  2124   000d58 210d08          	LD	HL,RODISK	;else print message and terminate.
  2125   000d5b c34a0b          	JP	JUMPHL
  2126                          ;
  2127                          ;   Routine to set (HL) pointing to the proper entry in the
  2128                          ; directory buffer.
  2129                          ;
  2130   000d5e 2ab915          FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
  2131   000d61 3ae915          	LD	A,(FCBPOS)	;relative position of file.
  2132                          ;
  2133                          ;   Routine to add (A) to (HL).
  2134                          ;
  2135   000d64 85              ADDA2HL:ADD	A,L
  2136   000d65 6f              	LD	L,A
  2137   000d66 d0              	RET	NC
  2138   000d67 24              	INC	H		;take care of any carry.
  2139   000d68 c9              	RET
  2140                          ;
  2141                          ;   Routine to get the 's2' byte from the fcb supplied in
  2142                          ; the initial parameter specification.
  2143                          ;
  2144   000d69 2a430b          GETS2:	LD	HL,(PARAMS)	;get address of fcb.
  2145   000d6c 110e00          	LD	DE,14		;relative position of 's2'.
  2146   000d6f 19              	ADD	HL,DE
  2147   000d70 7e              	LD	A,(HL)		;extract this byte.
  2148   000d71 c9              	RET
  2149                          ;
  2150                          ;   Clear the 's2' byte in the fcb.
  2151                          ;
  2152   000d72 cd690d          CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
  2153   000d75 3600            	LD	(HL),0		;now clear it.
  2154   000d77 c9              	RET
  2155                          ;
  2156                          ;   Set bit 7 in the 's2' byte of the fcb.
  2157                          ;
  2158   000d78 cd690d          SETS2B7:CALL	GETS2		;get the byte.
  2159   000d7b f680            	OR	80H		;and set bit 7.
  2160   000d7d 77              	LD	(HL),A		;then store.
  2161   000d7e c9              	RET
  2162                          ;
  2163                          ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
  2164                          ; the difference. This checks to see if there are more file
  2165                          ; names in the directory. We are at (FILEPOS) and there are
  2166                          ; (SCRATCH1) of them to check.
  2167                          ;
  2168   000d7f 2aea15          MOREFLS:LD	HL,(FILEPOS)	;we are here.
  2169   000d82 eb              	EX	DE,HL
  2170   000d83 2ab315          	LD	HL,(SCRATCH1)	;and don't go past here.
  2171   000d86 7b              	LD	A,E		;compute difference but don't keep.
  2172   000d87 96              	SUB	(HL)
  2173   000d88 23              	INC	HL
  2174   000d89 7a              	LD	A,D
  2175   000d8a 9e              	SBC	A,(HL)		;set carry if no more names.
  2176   000d8b c9              	RET
  2177                          ;
  2178                          ;   Call this routine to prevent (SCRATCH1) from being greater
  2179                          ; than (FILEPOS).
  2180                          ;
  2181   000d8c cd7f0d          CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
  2182   000d8f d8              	RET	C
  2183   000d90 13              	INC	DE		;yes, reset it to (FILEPOS).
  2184   000d91 72              	LD	(HL),D
  2185   000d92 2b              	DEC	HL
  2186   000d93 73              	LD	(HL),E
  2187   000d94 c9              	RET
  2188                          ;
  2189                          ;   Compute (HL)=(DE)-(HL)
  2190                          ;
  2191   000d95 7b              SUBHL:	LD	A,E		;compute difference.
  2192   000d96 95              	SUB	L
  2193   000d97 6f              	LD	L,A		;store low byte.
  2194   000d98 7a              	LD	A,D
  2195   000d99 9c              	SBC	A,H
  2196   000d9a 67              	LD	H,A		;and then high byte.
  2197   000d9b c9              	RET
  2198                          ;
  2199                          ;   Set the directory checksum byte.
  2200                          ;
  2201   000d9c 0eff            SETDIR:	LD	C,0FFH
  2202                          ;
  2203                          ;   Routine to set or compare the directory checksum byte. If
  2204                          ; (C)=0ffh, then this will set the checksum byte. Else the byte
  2205                          ; will be checked. If the check fails (the disk has been changed),
  2206                          ; then this disk will be write protected.
  2207                          ;
  2208   000d9e 2aec15          CHECKDIR: LD	HL,(CKSUMTBL)
  2209   000da1 eb              	EX	DE,HL
  2210   000da2 2acc15          	LD	HL,(ALLOC1)
  2211   000da5 cd950d          	CALL	SUBHL
  2212   000da8 d0              	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
  2213   000da9 c5              	PUSH	BC
  2214   000daa cdf70c          	CALL	CHECKSUM	;else compute checksum.
  2215   000dad 2abd15          	LD	HL,(CHKVECT)	;get address of checksum table.
  2216   000db0 eb              	EX	DE,HL
  2217   000db1 2aec15          	LD	HL,(CKSUMTBL)
  2218   000db4 19              	ADD	HL,DE		;set (HL) to point to byte for this drive.
  2219   000db5 c1              	POP	BC
  2220   000db6 0c              	INC	C		;set or check ?
  2221   000db7 cac40d          	JP	Z,CHKDIR1
  2222   000dba be              	CP	(HL)		;check them.
  2223   000dbb c8              	RET	Z		;return if they are the same.
  2224   000dbc cd7f0d          	CALL	MOREFLS		;not the same, do we care?
  2225   000dbf d0              	RET	NC
  2226   000dc0 cd2c0d          	CALL	WRTPRTD		;yes, mark this as write protected.
  2227   000dc3 c9              	RET
  2228   000dc4 77              CHKDIR1:LD	(HL),A		;just set the byte.
  2229   000dc5 c9              	RET
  2230                          ;
  2231                          ;   Do a write to the directory of the current disk.
  2232                          ;
  2233   000dc6 cd9c0d          DIRWRITE: CALL	SETDIR		;set checksum byte.
  2234   000dc9 cde00d          	CALL	DIRDMA		;set directory dma address.
  2235   000dcc 0e01            	LD	C,1		;tell the bios to actually write.
  2236   000dce cdb80b          	CALL	DOWRITE		;then do the write.
  2237   000dd1 c3da0d          	JP	DEFDMA
  2238                          ;
  2239                          ;   Read from the directory.
  2240                          ;
  2241   000dd4 cde00d          DIRREAD:CALL	DIRDMA		;set the directory dma address.
  2242   000dd7 cdb20b          	CALL	DOREAD		;and read it.
  2243                          ;
  2244                          ;   Routine to set the dma address to the users choice.
  2245                          ;
  2246   000dda 21b115          DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
  2247   000ddd c3e30d          	JP	DIRDMA1
  2248                          ;
  2249                          ;   Routine to set the dma address for directory work.
  2250                          ;
  2251   000de0 21b915          DIRDMA:	LD	HL,DIRBUF
  2252                          ;
  2253                          ;   Set the dma address. On entry, (HL) points to
  2254                          ; word containing the desired dma address.
  2255                          ;
  2256   000de3 4e              DIRDMA1:LD	C,(HL)
  2257   000de4 23              	INC	HL
  2258   000de5 46              	LD	B,(HL)		;setup (BC) and go to the bios to set it.
  2259   000de6 c324f2          	JP	SETDMA
  2260                          ;
  2261                          ;   Move the directory buffer into user's dma space.
  2262                          ;
  2263   000de9 2ab915          MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
  2264   000dec eb              	EX	DE,HL
  2265   000ded 2ab115          	LD	HL,(USERDMA)	; put it here.
  2266   000df0 0e80            	LD	C,128		;this is its length.
  2267   000df2 c34f0b          	JP	DE2HL		;move it now and return.
  2268                          ;
  2269                          ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
  2270                          ;
  2271   000df5 21ea15          CKFILPOS: LD	HL,FILEPOS
  2272   000df8 7e              	LD	A,(HL)
  2273   000df9 23              	INC	HL
  2274   000dfa be              	CP	(HL)		;are both bytes the same?
  2275   000dfb c0              	RET	NZ
  2276   000dfc 3c              	INC	A		;yes, but are they each 0ffh?
  2277   000dfd c9              	RET
  2278                          ;
  2279                          ;   Set location (FILEPOS) to 0ffffh.
  2280                          ;
  2281   000dfe 21ffff          STFILPOS: LD	HL,0FFFFH
  2282   000e01 22ea15          	LD	(FILEPOS),HL
  2283   000e04 c9              	RET
  2284                          ;
  2285                          ;   Move on to the next file position within the current
  2286                          ; directory buffer. If no more exist, set pointer to 0ffffh
  2287                          ; and the calling routine will check for this. Enter with (C)
  2288                          ; equal to 0ffh to cause the checksum byte to be set, else we
  2289                          ; will check this disk and set write protect if checksums are
  2290                          ; not the same (applies only if another directory sector must
  2291                          ; be read).
  2292                          ;
  2293   000e05 2ac815          NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
  2294   000e08 eb              	EX	DE,HL
  2295   000e09 2aea15          	LD	HL,(FILEPOS)	;get current count.
  2296   000e0c 23              	INC	HL		;go on to the next one.
  2297   000e0d 22ea15          	LD	(FILEPOS),HL
  2298   000e10 cd950d          	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
  2299   000e13 d2190e          	JP	NC,NXENT1	;is there more room left?
  2300   000e16 c3fe0d          	JP	STFILPOS	;no. Set this flag and return.
  2301   000e19 3aea15          NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
  2302   000e1c e603            	AND	03H		;only look within this sector (only 4 entries fit).
  2303   000e1e 0605            	LD	B,5		;convert to relative position (32 bytes each).
  2304   000e20 87              NXENT2:	ADD	A,A		;note that this is not efficient code.
  2305   000e21 05              	DEC	B		;5 'ADD A's would be better.
  2306   000e22 c2200e          	JP	NZ,NXENT2
  2307   000e25 32e915          	LD	(FCBPOS),A	;save it as position of fcb.
  2308   000e28 b7              	OR	A
  2309   000e29 c0              	RET	NZ		;return if we are within buffer.
  2310   000e2a c5              	PUSH	BC
  2311   000e2b cdc30b          	CALL	TRKSEC		;we need the next directory sector.
  2312   000e2e cdd40d          	CALL	DIRREAD
  2313   000e31 c1              	POP	BC
  2314   000e32 c39e0d          	JP	CHECKDIR
  2315                          ;
  2316                          ;   Routine to to get a bit from the disk space allocation
  2317                          ; map. It is returned in (A), bit position 0. On entry to here,
  2318                          ; set (BC) to the block number on the disk to check.
  2319                          ; On return, (D) will contain the original bit position for
  2320                          ; this block number and (HL) will point to the address for it.
  2321                          ;
  2322   000e35 79              CKBITMAP: LD	A,C		;determine bit number of interest.
  2323   000e36 e607            	AND	07H		;compute (D)=(E)=(C and 7)+1.
  2324   000e38 3c              	INC	A
  2325   000e39 5f              	LD	E,A		;save particular bit number.
  2326   000e3a 57              	LD	D,A
  2327                          ;
  2328                          ;   compute (BC)=(BC)/8.
  2329                          ;
  2330   000e3b 79              	LD	A,C
  2331   000e3c 0f              	RRCA			;now shift right 3 bits.
  2332   000e3d 0f              	RRCA
  2333   000e3e 0f              	RRCA
  2334   000e3f e61f            	AND	1FH		;and clear bits 7,6,5.
  2335   000e41 4f              	LD	C,A
  2336   000e42 78              	LD	A,B
  2337   000e43 87              	ADD	A,A		;now shift (B) into bits 7,6,5.
  2338   000e44 87              	ADD	A,A
  2339   000e45 87              	ADD	A,A
  2340   000e46 87              	ADD	A,A
  2341   000e47 87              	ADD	A,A
  2342   000e48 b1              	OR	C		;and add in (C).
  2343   000e49 4f              	LD	C,A		;ok, (C) ha been completed.
  2344   000e4a 78              	LD	A,B		;is there a better way of doing this?
  2345   000e4b 0f              	RRCA
  2346   000e4c 0f              	RRCA
  2347   000e4d 0f              	RRCA
  2348   000e4e e61f            	AND	1FH
  2349   000e50 47              	LD	B,A		;and now (B) is completed.
  2350                          ;
  2351                          ;   use this as an offset into the disk space allocation
  2352                          ; table.
  2353                          ;
  2354   000e51 2abf15          	LD	HL,(ALOCVECT)
  2355   000e54 09              	ADD	HL,BC
  2356   000e55 7e              	LD	A,(HL)		;now get correct byte.
  2357   000e56 07              CKBMAP1:RLCA			;get correct bit into position 0.
  2358   000e57 1d              	DEC	E
  2359   000e58 c2560e          	JP	NZ,CKBMAP1
  2360   000e5b c9              	RET
  2361                          ;
  2362                          ;   Set or clear the bit map such that block number (BC) will be marked
  2363                          ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
  2364                          ; 1 then it will be set (don't use anyother values).
  2365                          ;
  2366   000e5c d5              STBITMAP: PUSH	DE
  2367   000e5d cd350e          	CALL	CKBITMAP	;get the byte of interest.
  2368   000e60 e6fe            	AND	0FEH		;clear the affected bit.
  2369   000e62 c1              	POP	BC
  2370   000e63 b1              	OR	C		;and now set it acording to (C).
  2371                          ;
  2372                          ;  entry to restore the original bit position and then store
  2373                          ; in table. (A) contains the value, (D) contains the bit
  2374                          ; position (1-8), and (HL) points to the address within the
  2375                          ; space allocation table for this byte.
  2376                          ;
  2377   000e64 0f              STBMAP1:RRCA			;restore original bit position.
  2378   000e65 15              	DEC	D
  2379   000e66 c2640e          	JP	NZ,STBMAP1
  2380   000e69 77              	LD	(HL),A		;and stor byte in table.
  2381   000e6a c9              	RET
  2382                          ;
  2383                          ;   Set/clear space used bits in allocation map for this file.
  2384                          ; On entry, (C)=1 to set the map and (C)=0 to clear it.
  2385                          ;
  2386   000e6b cd5e0d          SETFILE:CALL	FCB2HL		;get address of fcb
  2387   000e6e 111000          	LD	DE,16
  2388   000e71 19              	ADD	HL,DE		;get to block number bytes.
  2389   000e72 c5              	PUSH	BC
  2390   000e73 0e11            	LD	C,17		;check all 17 bytes (max) of table.
  2391   000e75 d1              SETFL1:	POP	DE
  2392   000e76 0d              	DEC	C		;done all bytes yet?
  2393   000e77 c8              	RET	Z
  2394   000e78 d5              	PUSH	DE
  2395   000e79 3add15          	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
  2396   000e7c b7              	OR	A
  2397   000e7d ca880e          	JP	Z,SETFL2
  2398   000e80 c5              	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
  2399   000e81 e5              	PUSH	HL
  2400   000e82 4e              	LD	C,(HL)		;get low byte from table, always
  2401   000e83 0600            	LD	B,0		;set high byte to zero.
  2402   000e85 c38e0e          	JP	SETFL3
  2403   000e88 0d              SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
  2404   000e89 c5              	PUSH	BC
  2405   000e8a 4e              	LD	C,(HL)		;now get both the low and high bytes.
  2406   000e8b 23              	INC	HL
  2407   000e8c 46              	LD	B,(HL)
  2408   000e8d e5              	PUSH	HL
  2409   000e8e 79              SETFL3:	LD	A,C		;block used?
  2410   000e8f b0              	OR	B
  2411   000e90 ca9d0e          	JP	Z,SETFL4
  2412   000e93 2ac615          	LD	HL,(DSKSIZE)	;is this block number within the
  2413   000e96 7d              	LD	A,L		;space on the disk?
  2414   000e97 91              	SUB	C
  2415   000e98 7c              	LD	A,H
  2416   000e99 98              	SBC	A,B
  2417   000e9a d45c0e          	CALL	NC,STBITMAP	;yes, set the proper bit.
  2418   000e9d e1              SETFL4:	POP	HL		;point to next block number in fcb.
  2419   000e9e 23              	INC	HL
  2420   000e9f c1              	POP	BC
  2421   000ea0 c3750e          	JP	SETFL1
  2422                          ;
  2423                          ;   Construct the space used allocation bit map for the active
  2424                          ; drive. If a file name starts with '$' and it is under the
  2425                          ; current user number, then (STATUS) is set to minus 1. Otherwise
  2426                          ; it is not set at all.
  2427                          ;
  2428   000ea3 2ac615          BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
  2429   000ea6 0e03            	LD	C,3
  2430   000ea8 cdea0c          	CALL	SHIFTR		;(HL)=(HL)/8.
  2431   000eab 23              	INC	HL		;at lease 1 byte.
  2432   000eac 44              	LD	B,H
  2433   000ead 4d              	LD	C,L		;set (BC) to the allocation table length.
  2434                          ;
  2435                          ;   Initialize the bitmap for this drive. Right now, the first
  2436                          ; two bytes are specified by the disk parameter block. However
  2437                          ; a patch could be entered here if it were necessary to setup
  2438                          ; this table in a special mannor. For example, the bios could
  2439                          ; determine locations of 'bad blocks' and set them as already
  2440                          ; 'used' in the map.
  2441                          ;
  2442   000eae 2abf15          	LD	HL,(ALOCVECT)	;now zero out the table now.
  2443   000eb1 3600            BITMAP1:LD	(HL),0
  2444   000eb3 23              	INC	HL
  2445   000eb4 0b              	DEC	BC
  2446   000eb5 78              	LD	A,B
  2447   000eb6 b1              	OR	C
  2448   000eb7 c2b10e          	JP	NZ,BITMAP1
  2449   000eba 2aca15          	LD	HL,(ALLOC0)	;get initial space used by directory.
  2450   000ebd eb              	EX	DE,HL
  2451   000ebe 2abf15          	LD	HL,(ALOCVECT)	;and put this into map.
  2452   000ec1 73              	LD	(HL),E
  2453   000ec2 23              	INC	HL
  2454   000ec3 72              	LD	(HL),D
  2455                          ;
  2456                          ;   End of initialization portion.
  2457                          ;
  2458   000ec4 cda10b          	CALL	HOMEDRV		;now home the drive.
  2459   000ec7 2ab315          	LD	HL,(SCRATCH1)
  2460   000eca 3603            	LD	(HL),3		;force next directory request to read
  2461   000ecc 23              	INC	HL		;in a sector.
  2462   000ecd 3600            	LD	(HL),0
  2463   000ecf cdfe0d          	CALL	STFILPOS	;clear initial file position also.
  2464   000ed2 0eff            BITMAP2:LD	C,0FFH		;read next file name in directory
  2465   000ed4 cd050e          	CALL	NXENTRY		;and set checksum byte.
  2466   000ed7 cdf50d          	CALL	CKFILPOS	;is there another file?
  2467   000eda c8              	RET	Z
  2468   000edb cd5e0d          	CALL	FCB2HL		;yes, get its address.
  2469   000ede 3ee5            	LD	A,0E5H
  2470   000ee0 be              	CP	(HL)		;empty file entry?
  2471   000ee1 cad20e          	JP	Z,BITMAP2
  2472   000ee4 3a410b          	LD	A,(USERNO)	;no, correct user number?
  2473   000ee7 be              	CP	(HL)
  2474   000ee8 c2f60e          	JP	NZ,BITMAP3
  2475   000eeb 23              	INC	HL
  2476   000eec 7e              	LD	A,(HL)		;yes, does name start with a '$'?
  2477   000eed d624            	SUB	'$'
  2478   000eef c2f60e          	JP	NZ,BITMAP3
  2479   000ef2 3d              	DEC	A		;yes, set atatus to minus one.
  2480   000ef3 32450b          	LD	(STATUS),A
  2481   000ef6 0e01            BITMAP3:LD	C,1		;now set this file's space as used in bit map.
  2482   000ef8 cd6b0e          	CALL	SETFILE
  2483   000efb cd8c0d          	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
  2484   000efe c3d20e          	JP	BITMAP2
  2485                          ;
  2486                          ;   Set the status (STATUS) and return.
  2487                          ;
  2488   000f01 3ad415          STSTATUS: LD	A,(FNDSTAT)
  2489   000f04 c3010b          	JP	SETSTAT
  2490                          ;
  2491                          ;   Check extents in (A) and (C). Set the zero flag if they
  2492                          ; are the same. The number of 16k chunks of disk space that
  2493                          ; the directory extent covers is expressad is (EXTMASK+1).
  2494                          ; No registers are modified.
  2495                          ;
  2496   000f07 c5              SAMEXT:	PUSH	BC
  2497   000f08 f5              	PUSH	AF
  2498   000f09 3ac515          	LD	A,(EXTMASK)	;get extent mask and use it to
  2499   000f0c 2f              	CPL			;to compare both extent numbers.
  2500   000f0d 47              	LD	B,A		;save resulting mask here.
  2501   000f0e 79              	LD	A,C		;mask first extent and save in (C).
  2502   000f0f a0              	AND	B
  2503   000f10 4f              	LD	C,A
  2504   000f11 f1              	POP	AF		;now mask second extent and compare
  2505   000f12 a0              	AND	B		;with the first one.
  2506   000f13 91              	SUB	C
  2507   000f14 e61f            	AND	1FH		;(* only check buts 0-4 *)
  2508   000f16 c1              	POP	BC		;the zero flag is set if they are the same.
  2509   000f17 c9              	RET			;restore (BC) and return.
  2510                          ;
  2511                          ;   Search for the first occurence of a file name. On entry,
  2512                          ; register (C) should contain the number of bytes of the fcb
  2513                          ; that must match.
  2514                          ;
  2515   000f18 3eff            FINDFST:LD	A,0FFH
  2516   000f1a 32d415          	LD	(FNDSTAT),A
  2517   000f1d 21d815          	LD	HL,COUNTER	;save character count.
  2518   000f20 71              	LD	(HL),C
  2519   000f21 2a430b          	LD	HL,(PARAMS)	;get filename to match.
  2520   000f24 22d915          	LD	(SAVEFCB),HL	;and save.
  2521   000f27 cdfe0d          	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
  2522   000f2a cda10b          	CALL	HOMEDRV		;home the drive.
  2523                          ;
  2524                          ;   Entry to locate the next occurence of a filename within the
  2525                          ; directory. The disk is not expected to have been changed. If
  2526                          ; it was, then it will be write protected.
  2527                          ;
  2528   000f2d 0e00            FINDNXT:LD	C,0		;write protect the disk if changed.
  2529   000f2f cd050e          	CALL	NXENTRY		;get next filename entry in directory.
  2530   000f32 cdf50d          	CALL	CKFILPOS	;is file position = 0ffffh?
  2531   000f35 ca940f          	JP	Z,FNDNXT6	;yes, exit now then.
  2532   000f38 2ad915          	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
  2533   000f3b eb              	EX	DE,HL
  2534   000f3c 1a              	LD	A,(DE)
  2535   000f3d fee5            	CP	0E5H		;empty directory entry?
  2536   000f3f ca4a0f          	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
  2537   000f42 d5              	PUSH	DE
  2538   000f43 cd7f0d          	CALL	MOREFLS		;more files in directory?
  2539   000f46 d1              	POP	DE
  2540   000f47 d2940f          	JP	NC,FNDNXT6	;no more. Exit now.
  2541   000f4a cd5e0d          FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
  2542   000f4d 3ad815          	LD	A,(COUNTER)	;get number of bytes (characters) to check.
  2543   000f50 4f              	LD	C,A
  2544   000f51 0600            	LD	B,0		;initialize byte position counter.
  2545   000f53 79              FNDNXT2:LD	A,C		;are we done with the compare?
  2546   000f54 b7              	OR	A
  2547   000f55 ca830f          	JP	Z,FNDNXT5
  2548   000f58 1a              	LD	A,(DE)		;no, check next byte.
  2549   000f59 fe3f            	CP	'?'		;don't care about this character?
  2550   000f5b ca7c0f          	JP	Z,FNDNXT4
  2551   000f5e 78              	LD	A,B		;get bytes position in fcb.
  2552   000f5f fe0d            	CP	13		;don't care about the thirteenth byte either.
  2553   000f61 ca7c0f          	JP	Z,FNDNXT4
  2554   000f64 fe0c            	CP	12		;extent byte?
  2555   000f66 1a              	LD	A,(DE)
  2556   000f67 ca730f          	JP	Z,FNDNXT3
  2557   000f6a 96              	SUB	(HL)		;otherwise compare characters.
  2558   000f6b e67f            	AND	7FH
  2559   000f6d c22d0f          	JP	NZ,FINDNXT	;not the same, check next entry.
  2560   000f70 c37c0f          	JP	FNDNXT4		;so far so good, keep checking.
  2561   000f73 c5              FNDNXT3:PUSH	BC		;check the extent byte here.
  2562   000f74 4e              	LD	C,(HL)
  2563   000f75 cd070f          	CALL	SAMEXT
  2564   000f78 c1              	POP	BC
  2565   000f79 c22d0f          	JP	NZ,FINDNXT	;not the same, look some more.
  2566                          ;
  2567                          ;   So far the names compare. Bump pointers to the next byte
  2568                          ; and continue until all (C) characters have been checked.
  2569                          ;
  2570   000f7c 13              FNDNXT4:INC	DE		;bump pointers.
  2571   000f7d 23              	INC	HL
  2572   000f7e 04              	INC	B
  2573   000f7f 0d              	DEC	C		;adjust character counter.
  2574   000f80 c3530f          	JP	FNDNXT2
  2575   000f83 3aea15          FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
  2576   000f86 e603            	AND	03H
  2577   000f88 32450b          	LD	(STATUS),A
  2578   000f8b 21d415          	LD	HL,FNDSTAT
  2579   000f8e 7e              	LD	A,(HL)
  2580   000f8f 17              	RLA
  2581   000f90 d0              	RET	NC
  2582   000f91 af              	XOR	A
  2583   000f92 77              	LD	(HL),A
  2584   000f93 c9              	RET
  2585                          ;
  2586                          ;   Filename was not found. Set appropriate status.
  2587                          ;
  2588   000f94 cdfe0d          FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
  2589   000f97 3eff            	LD	A,0FFH		;say not located.
  2590   000f99 c3010b          	JP	SETSTAT
  2591                          ;
  2592                          ;   Erase files from the directory. Only the first byte of the
  2593                          ; fcb will be affected. It is set to (E5).
  2594                          ;
  2595   000f9c cd540d          ERAFILE:CALL	CHKWPRT		;is disk write protected?
  2596   000f9f 0e0c            	LD	C,12		;only compare file names.
  2597   000fa1 cd180f          	CALL	FINDFST		;get first file name.
  2598   000fa4 cdf50d          ERAFIL1:CALL	CKFILPOS	;any found?
  2599   000fa7 c8              	RET	Z		;nope, we must be done.
  2600   000fa8 cd440d          	CALL	CHKROFL		;is file read only?
  2601   000fab cd5e0d          	CALL	FCB2HL		;nope, get address of fcb and
  2602   000fae 36e5            	LD	(HL),0E5H	;set first byte to 'empty'.
  2603   000fb0 0e00            	LD	C,0		;clear the space from the bit map.
  2604   000fb2 cd6b0e          	CALL	SETFILE
  2605   000fb5 cdc60d          	CALL	DIRWRITE	;now write the directory sector back out.
  2606   000fb8 cd2d0f          	CALL	FINDNXT		;find the next file name.
  2607   000fbb c3a40f          	JP	ERAFIL1		;and repeat process.
  2608                          ;
  2609                          ;   Look through the space allocation map (bit map) for the
  2610                          ; next available block. Start searching at block number (BC-1).
  2611                          ; The search procedure is to look for an empty block that is
  2612                          ; before the starting block. If not empty, look at a later
  2613                          ; block number. In this way, we return the closest empty block
  2614                          ; on either side of the 'target' block number. This will speed
  2615                          ; access on random devices. For serial devices, this should be
  2616                          ; changed to look in the forward direction first and then start
  2617                          ; at the front and search some more.
  2618                          ;
  2619                          ;   On return, (DE)= block number that is empty and (HL) =0
  2620                          ; if no empry block was found.
  2621                          ;
  2622   000fbe 50              FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
  2623   000fbf 59              	LD	E,C
  2624                          ;
  2625                          ;   Look before target block. Registers (BC) are used as the lower
  2626                          ; pointer and (DE) as the upper pointer.
  2627                          ;
  2628   000fc0 79              FNDSPA1:LD	A,C		;is block 0 specified?
  2629   000fc1 b0              	OR	B
  2630   000fc2 cad10f          	JP	Z,FNDSPA2
  2631   000fc5 0b              	DEC	BC		;nope, check previous block.
  2632   000fc6 d5              	PUSH	DE
  2633   000fc7 c5              	PUSH	BC
  2634   000fc8 cd350e          	CALL	CKBITMAP
  2635   000fcb 1f              	RRA			;is this block empty?
  2636   000fcc d2ec0f          	JP	NC,FNDSPA3	;yes. use this.
  2637                          ;
  2638                          ;   Note that the above logic gets the first block that it finds
  2639                          ; that is empty. Thus a file could be written 'backward' making
  2640                          ; it very slow to access. This could be changed to look for the
  2641                          ; first empty block and then continue until the start of this
  2642                          ; empty space is located and then used that starting block.
  2643                          ; This should help speed up access to some files especially on
  2644                          ; a well used disk with lots of fairly small 'holes'.
  2645                          ;
  2646   000fcf c1              	POP	BC		;nope, check some more.
  2647   000fd0 d1              	POP	DE
  2648                          ;
  2649                          ;   Now look after target block.
  2650                          ;
  2651   000fd1 2ac615          FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
  2652   000fd4 7b              	LD	A,E
  2653   000fd5 95              	SUB	L
  2654   000fd6 7a              	LD	A,D
  2655   000fd7 9c              	SBC	A,H
  2656   000fd8 d2f40f          	JP	NC,FNDSPA4
  2657   000fdb 13              	INC	DE		;yes, move on to next one.
  2658   000fdc c5              	PUSH	BC
  2659   000fdd d5              	PUSH	DE
  2660   000fde 42              	LD	B,D
  2661   000fdf 4b              	LD	C,E
  2662   000fe0 cd350e          	CALL	CKBITMAP	;check it.
  2663   000fe3 1f              	RRA			;empty?
  2664   000fe4 d2ec0f          	JP	NC,FNDSPA3
  2665   000fe7 d1              	POP	DE		;nope, continue searching.
  2666   000fe8 c1              	POP	BC
  2667   000fe9 c3c00f          	JP	FNDSPA1
  2668                          ;
  2669                          ;   Empty block found. Set it as used and return with (HL)
  2670                          ; pointing to it (true?).
  2671                          ;
  2672   000fec 17              FNDSPA3:RLA			;reset byte.
  2673   000fed 3c              	INC	A		;and set bit 0.
  2674   000fee cd640e          	CALL	STBMAP1		;update bit map.
  2675   000ff1 e1              	POP	HL		;set return registers.
  2676   000ff2 d1              	POP	DE
  2677   000ff3 c9              	RET
  2678                          ;
  2679                          ;   Free block was not found. If (BC) is not zero, then we have
  2680                          ; not checked all of the disk space.
  2681                          ;
  2682   000ff4 79              FNDSPA4:LD	A,C
  2683   000ff5 b0              	OR	B
  2684   000ff6 c2c00f          	JP	NZ,FNDSPA1
  2685   000ff9 210000          	LD	HL,0		;set 'not found' status.
  2686   000ffc c9              	RET
  2687                          ;
  2688                          ;   Move a complete fcb entry into the directory and write it.
  2689                          ;
  2690   000ffd 0e00            FCBSET:	LD	C,0
  2691   000fff 1e20            	LD	E,32		;length of each entry.
  2692                          ;
  2693                          ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
  2694                          ; fcb in directory starting at relative byte (C). This updated
  2695                          ; directory buffer is then written to the disk.
  2696                          ;
  2697   001001 d5              UPDATE:	PUSH	DE
  2698   001002 0600            	LD	B,0		;set (BC) to relative byte position.
  2699   001004 2a430b          	LD	HL,(PARAMS)	;get address of fcb.
  2700   001007 09              	ADD	HL,BC		;compute starting byte.
  2701   001008 eb              	EX	DE,HL
  2702   001009 cd5e0d          	CALL	FCB2HL		;get address of fcb to update in directory.
  2703   00100c c1              	POP	BC		;set (C) to number of bytes to change.
  2704   00100d cd4f0b          	CALL	DE2HL
  2705   001010 cdc30b          UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
  2706   001013 c3c60d          	JP	DIRWRITE	;then write this sector out.
  2707                          ;
  2708                          ;   Routine to change the name of all files on the disk with a
  2709                          ; specified name. The fcb contains the current name as the
  2710                          ; first 12 characters and the new name 16 bytes into the fcb.
  2711                          ;
  2712   001016 cd540d          CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
  2713   001019 0e0c            	LD	C,12		;match first 12 bytes of fcb only.
  2714   00101b cd180f          	CALL	FINDFST		;get first name.
  2715   00101e 2a430b          	LD	HL,(PARAMS)	;get address of fcb.
  2716   001021 7e              	LD	A,(HL)		;get user number.
  2717   001022 111000          	LD	DE,16		;move over to desired name.
  2718   001025 19              	ADD	HL,DE
  2719   001026 77              	LD	(HL),A		;keep same user number.
  2720   001027 cdf50d          CHGNAM1:CALL	CKFILPOS	;any matching file found?
  2721   00102a c8              	RET	Z		;no, we must be done.
  2722   00102b cd440d          	CALL	CHKROFL		;check for read only file.
  2723   00102e 0e10            	LD	C,16		;start 16 bytes into fcb.
  2724   001030 1e0c            	LD	E,12		;and update the first 12 bytes of directory.
  2725   001032 cd0110          	CALL	UPDATE
  2726   001035 cd2d0f          	CALL	FINDNXT		;get te next file name.
  2727   001038 c32710          	JP	CHGNAM1		;and continue.
  2728                          ;
  2729                          ;   Update a files attributes. The procedure is to search for
  2730                          ; every file with the same name as shown in fcb (ignoring bit 7)
  2731                          ; and then to update it (which includes bit 7). No other changes
  2732                          ; are made.
  2733                          ;
  2734   00103b 0e0c            SAVEATTR: LD	C,12		;match first 12 bytes.
  2735   00103d cd180f          	CALL	FINDFST		;look for first filename.
  2736   001040 cdf50d          SAVATR1:CALL	CKFILPOS	;was one found?
  2737   001043 c8              	RET	Z		;nope, we must be done.
  2738   001044 0e00            	LD	C,0		;yes, update the first 12 bytes now.
  2739   001046 1e0c            	LD	E,12
  2740   001048 cd0110          	CALL	UPDATE		;update filename and write directory.
  2741   00104b cd2d0f          	CALL	FINDNXT		;and get the next file.
  2742   00104e c34010          	JP	SAVATR1		;then continue until done.
  2743                          ;
  2744                          ;  Open a file (name specified in fcb).
  2745                          ;
  2746   001051 0e0f            OPENIT:	LD	C,15		;compare the first 15 bytes.
  2747   001053 cd180f          	CALL	FINDFST		;get the first one in directory.
  2748   001056 cdf50d          	CALL	CKFILPOS	;any at all?
  2749   001059 c8              	RET	Z
  2750   00105a cda60c          OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
  2751   00105d 7e              	LD	A,(HL)		;and get it.
  2752   00105e f5              	PUSH	AF		;save it and address.
  2753   00105f e5              	PUSH	HL
  2754   001060 cd5e0d          	CALL	FCB2HL		;point to fcb in directory.
  2755   001063 eb              	EX	DE,HL
  2756   001064 2a430b          	LD	HL,(PARAMS)	;this is the users copy.
  2757   001067 0e20            	LD	C,32		;move it into users space.
  2758   001069 d5              	PUSH	DE
  2759   00106a cd4f0b          	CALL	DE2HL
  2760   00106d cd780d          	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
  2761   001070 d1              	POP	DE		;now get the extent byte from this fcb.
  2762   001071 210c00          	LD	HL,12
  2763   001074 19              	ADD	HL,DE
  2764   001075 4e              	LD	C,(HL)		;into (C).
  2765   001076 210f00          	LD	HL,15		;now get the record count byte into (B).
  2766   001079 19              	ADD	HL,DE
  2767   00107a 46              	LD	B,(HL)
  2768   00107b e1              	POP	HL		;keep the same extent as the user had originally.
  2769   00107c f1              	POP	AF
  2770   00107d 77              	LD	(HL),A
  2771   00107e 79              	LD	A,C		;is it the same as in the directory fcb?
  2772   00107f be              	CP	(HL)
  2773   001080 78              	LD	A,B		;if yes, then use the same record count.
  2774   001081 ca8b10          	JP	Z,OPENIT2
  2775   001084 3e00            	LD	A,0		;if the user specified an extent greater than
  2776   001086 da8b10          	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
  2777   001089 3e80            	LD	A,128		;otherwise set to maximum.
  2778   00108b 2a430b          OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
  2779   00108e 110f00          	LD	DE,15
  2780   001091 19              	ADD	HL,DE		;compute relative position.
  2781   001092 77              	LD	(HL),A		;and set the record count.
  2782   001093 c9              	RET
  2783                          ;
  2784                          ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
  2785                          ; point to a zero value (16 bit).
  2786                          ;   Return with zero flag set it (DE) was moved. Registers (DE)
  2787                          ; and (HL) are not changed. However (A) is.
  2788                          ;
  2789   001094 7e              MOVEWORD: LD	A,(HL)		;check for a zero word.
  2790   001095 23              	INC	HL
  2791   001096 b6              	OR	(HL)		;both bytes zero?
  2792   001097 2b              	DEC	HL
  2793   001098 c0              	RET	NZ		;nope, just return.
  2794   001099 1a              	LD	A,(DE)		;yes, move two bytes from (DE) into
  2795   00109a 77              	LD	(HL),A		;this zero space.
  2796   00109b 13              	INC	DE
  2797   00109c 23              	INC	HL
  2798   00109d 1a              	LD	A,(DE)
  2799   00109e 77              	LD	(HL),A
  2800   00109f 1b              	DEC	DE		;don't disturb these registers.
  2801   0010a0 2b              	DEC	HL
  2802   0010a1 c9              	RET
  2803                          ;
  2804                          ;   Get here to close a file specified by (fcb).
  2805                          ;
  2806   0010a2 af              CLOSEIT:XOR	A		;clear status and file position bytes.
  2807   0010a3 32450b          	LD	(STATUS),A
  2808   0010a6 32ea15          	LD	(FILEPOS),A
  2809   0010a9 32eb15          	LD	(FILEPOS+1),A
  2810   0010ac cd1e0d          	CALL	GETWPRT		;get write protect bit for this drive.
  2811   0010af c0              	RET	NZ		;just return if it is set.
  2812   0010b0 cd690d          	CALL	GETS2		;else get the 's2' byte.
  2813   0010b3 e680            	AND	80H		;and look at bit 7 (file unmodified?).
  2814   0010b5 c0              	RET	NZ		;just return if set.
  2815   0010b6 0e0f            	LD	C,15		;else look up this file in directory.
  2816   0010b8 cd180f          	CALL	FINDFST
  2817   0010bb cdf50d          	CALL	CKFILPOS	;was it found?
  2818   0010be c8              	RET	Z		;just return if not.
  2819   0010bf 011000          	LD	BC,16		;set (HL) pointing to records used section.
  2820   0010c2 cd5e0d          	CALL	FCB2HL
  2821   0010c5 09              	ADD	HL,BC
  2822   0010c6 eb              	EX	DE,HL
  2823   0010c7 2a430b          	LD	HL,(PARAMS)	;do the same for users specified fcb.
  2824   0010ca 09              	ADD	HL,BC
  2825   0010cb 0e10            	LD	C,16		;this many bytes are present in this extent.
  2826   0010cd 3add15          CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
  2827   0010d0 b7              	OR	A
  2828   0010d1 cae810          	JP	Z,CLOSEIT4
  2829   0010d4 7e              	LD	A,(HL)		;just 8 bit. Get one from users fcb.
  2830   0010d5 b7              	OR	A
  2831   0010d6 1a              	LD	A,(DE)		;now get one from directory fcb.
  2832   0010d7 c2db10          	JP	NZ,CLOSEIT2
  2833   0010da 77              	LD	(HL),A		;users byte was zero. Update from directory.
  2834   0010db b7              CLOSEIT2: OR	A
  2835   0010dc c2e110          	JP	NZ,CLOSEIT3
  2836   0010df 7e              	LD	A,(HL)		;directories byte was zero, update from users fcb.
  2837   0010e0 12              	LD	(DE),A
  2838   0010e1 be              CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
  2839   0010e2 c21f11          	JP	NZ,CLOSEIT7	;then close error if they are not the same.
  2840   0010e5 c3fd10          	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
  2841   0010e8 cd9410          CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
  2842   0010eb eb              	EX	DE,HL
  2843   0010ec cd9410          	CALL	MOVEWORD	;update directories fcb if it is zero.
  2844   0010ef eb              	EX	DE,HL
  2845   0010f0 1a              	LD	A,(DE)		;if these two values are no different,
  2846   0010f1 be              	CP	(HL)		;then a close error occured.
  2847   0010f2 c21f11          	JP	NZ,CLOSEIT7
  2848   0010f5 13              	INC	DE		;check second byte.
  2849   0010f6 23              	INC	HL
  2850   0010f7 1a              	LD	A,(DE)
  2851   0010f8 be              	CP	(HL)
  2852   0010f9 c21f11          	JP	NZ,CLOSEIT7
  2853   0010fc 0d              	DEC	C		;remember 16 bit values.
  2854   0010fd 13              CLOSEIT5: INC	DE		;bump to next item in table.
  2855   0010fe 23              	INC	HL
  2856   0010ff 0d              	DEC	C		;there are 16 entries only.
  2857   001100 c2cd10          	JP	NZ,CLOSEIT1	;continue if more to do.
  2858   001103 01ecff          	LD	BC,0FFECH	;backup 20 places (extent byte).
  2859   001106 09              	ADD	HL,BC
  2860   001107 eb              	EX	DE,HL
  2861   001108 09              	ADD	HL,BC
  2862   001109 1a              	LD	A,(DE)
  2863   00110a be              	CP	(HL)		;directory's extent already greater than the
  2864   00110b da1711          	JP	C,CLOSEIT6	;users extent?
  2865   00110e 77              	LD	(HL),A		;no, update directory extent.
  2866   00110f 010300          	LD	BC,3		;and update the record count byte in
  2867   001112 09              	ADD	HL,BC		;directories fcb.
  2868   001113 eb              	EX	DE,HL
  2869   001114 09              	ADD	HL,BC
  2870   001115 7e              	LD	A,(HL)		;get from user.
  2871   001116 12              	LD	(DE),A		;and put in directory.
  2872   001117 3eff            CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
  2873   001119 32d215          	LD	(CLOSEFLG),A
  2874   00111c c31010          	JP	UPDATE1		;update the directory now.
  2875   00111f 21450b          CLOSEIT7: LD	HL,STATUS	;set return status and then return.
  2876   001122 35              	DEC	(HL)
  2877   001123 c9              	RET
  2878                          ;
  2879                          ;   Routine to get the next empty space in the directory. It
  2880                          ; will then be cleared for use.
  2881                          ;
  2882   001124 cd540d          GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
  2883   001127 2a430b          	LD	HL,(PARAMS)	;save current parameters (fcb).
  2884   00112a e5              	PUSH	HL
  2885   00112b 21ac15          	LD	HL,EMPTYFCB	;use special one for empty space.
  2886   00112e 22430b          	LD	(PARAMS),HL
  2887   001131 0e01            	LD	C,1		;search for first empty spot in directory.
  2888   001133 cd180f          	CALL	FINDFST		;(* only check first byte *)
  2889   001136 cdf50d          	CALL	CKFILPOS	;none?
  2890   001139 e1              	POP	HL
  2891   00113a 22430b          	LD	(PARAMS),HL	;restore original fcb address.
  2892   00113d c8              	RET	Z		;return if no more space.
  2893   00113e eb              	EX	DE,HL
  2894   00113f 210f00          	LD	HL,15		;point to number of records for this file.
  2895   001142 19              	ADD	HL,DE
  2896   001143 0e11            	LD	C,17		;and clear all of this space.
  2897   001145 af              	XOR	A
  2898   001146 77              GETMT1:	LD	(HL),A
  2899   001147 23              	INC	HL
  2900   001148 0d              	DEC	C
  2901   001149 c24611          	JP	NZ,GETMT1
  2902   00114c 210d00          	LD	HL,13		;clear the 's1' byte also.
  2903   00114f 19              	ADD	HL,DE
  2904   001150 77              	LD	(HL),A
  2905   001151 cd8c0d          	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
  2906   001154 cdfd0f          	CALL	FCBSET		;write out this fcb entry to directory.
  2907   001157 c3780d          	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
  2908                          ;
  2909                          ;   Routine to close the current extent and open the next one
  2910                          ; for reading.
  2911                          ;
  2912   00115a af              GETNEXT:XOR	A
  2913   00115b 32d215          	LD	(CLOSEFLG),A	;clear close flag.
  2914   00115e cda210          	CALL	CLOSEIT		;close this extent.
  2915   001161 cdf50d          	CALL	CKFILPOS
  2916   001164 c8              	RET	Z		;not there???
  2917   001165 2a430b          	LD	HL,(PARAMS)	;get extent byte.
  2918   001168 010c00          	LD	BC,12
  2919   00116b 09              	ADD	HL,BC
  2920   00116c 7e              	LD	A,(HL)		;and increment it.
  2921   00116d 3c              	INC	A
  2922   00116e e61f            	AND	1FH		;keep within range 0-31.
  2923   001170 77              	LD	(HL),A
  2924   001171 ca8311          	JP	Z,GTNEXT1	;overflow?
  2925   001174 47              	LD	B,A		;mask extent byte.
  2926   001175 3ac515          	LD	A,(EXTMASK)
  2927   001178 a0              	AND	B
  2928   001179 21d215          	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
  2929   00117c a6              	AND	(HL)
  2930   00117d ca8e11          	JP	Z,GTNEXT2	;if zero, we must read in next extent.
  2931   001180 c3ac11          	JP	GTNEXT3		;else, it is already in memory.
  2932   001183 010200          GTNEXT1:LD	BC,2		;Point to the 's2' byte.
  2933   001186 09              	ADD	HL,BC
  2934   001187 34              	INC	(HL)		;and bump it.
  2935   001188 7e              	LD	A,(HL)		;too many extents?
  2936   001189 e60f            	AND	0FH
  2937   00118b cab611          	JP	Z,GTNEXT5	;yes, set error code.
  2938                          ;
  2939                          ;   Get here to open the next extent.
  2940                          ;
  2941   00118e 0e0f            GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
  2942   001190 cd180f          	CALL	FINDFST		;find the first one.
  2943   001193 cdf50d          	CALL	CKFILPOS	;none available?
  2944   001196 c2ac11          	JP	NZ,GTNEXT3
  2945   001199 3ad315          	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
  2946   00119c 3c              	INC	A		;0ffh means reading (so not possible).
  2947   00119d cab611          	JP	Z,GTNEXT5	;or an error.
  2948   0011a0 cd2411          	CALL	GETEMPTY	;we are writing, get an empty entry.
  2949   0011a3 cdf50d          	CALL	CKFILPOS	;none?
  2950   0011a6 cab611          	JP	Z,GTNEXT5	;error if true.
  2951   0011a9 c3af11          	JP	GTNEXT4		;else we are almost done.
  2952   0011ac cd5a10          GTNEXT3:CALL	OPENIT1		;open this extent.
  2953   0011af cdbb0c          GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
  2954   0011b2 af              	XOR	A		;clear status and return.
  2955   0011b3 c3010b          	JP	SETSTAT
  2956                          ;
  2957                          ;   Error in extending the file. Too many extents were needed
  2958                          ; or not enough space on the disk.
  2959                          ;
  2960   0011b6 cd050b          GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
  2961   0011b9 c3780d          	JP	SETS2B7		;so this is not written on a close.
  2962                          ;
  2963                          ;   Read a sequential file.
  2964                          ;
  2965   0011bc 3e01            RDSEQ:	LD	A,1		;set sequential access mode.
  2966   0011be 32d515          	LD	(MODE),A
  2967   0011c1 3eff            RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
  2968   0011c3 32d315          	LD	(RDWRTFLG),A
  2969   0011c6 cdbb0c          	CALL	STRDATA		;put rec# and ext# into fcb.
  2970   0011c9 3ae315          	LD	A,(SAVNREC)	;get next record to read.
  2971   0011cc 21e115          	LD	HL,SAVNXT	;get number of records in extent.
  2972   0011cf be              	CP	(HL)		;within this extent?
  2973   0011d0 dae611          	JP	C,RDSEQ2
  2974   0011d3 fe80            	CP	128		;no. Is this extent fully used?
  2975   0011d5 c2fb11          	JP	NZ,RDSEQ3	;no. End-of-file.
  2976   0011d8 cd5a11          	CALL	GETNEXT		;yes, open the next one.
  2977   0011db af              	XOR	A		;reset next record to read.
  2978   0011dc 32e315          	LD	(SAVNREC),A
  2979   0011df 3a450b          	LD	A,(STATUS)	;check on open, successful?
  2980   0011e2 b7              	OR	A
  2981   0011e3 c2fb11          	JP	NZ,RDSEQ3	;no, error.
  2982   0011e6 cd770c          RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
  2983   0011e9 cd840c          	CALL	CHKBLK		;check it. Within bounds?
  2984   0011ec cafb11          	JP	Z,RDSEQ3	;no, error.
  2985   0011ef cd8a0c          	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
  2986   0011f2 cdd10b          	CALL	TRKSEC1		;set the track and sector for this block #.
  2987   0011f5 cdb20b          	CALL	DOREAD		;and read it.
  2988   0011f8 c3d20c          	JP	SETNREC		;and set the next record to be accessed.
  2989                          ;
  2990                          ;   Read error occured. Set status and return.
  2991                          ;
  2992   0011fb c3050b          RDSEQ3:	JP	IOERR1
  2993                          ;
  2994                          ;   Write the next sequential record.
  2995                          ;
  2996   0011fe 3e01            WTSEQ:	LD	A,1		;set sequential access mode.
  2997   001200 32d515          	LD	(MODE),A
  2998   001203 3e00            WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
  2999   001205 32d315          	LD	(RDWRTFLG),A
  3000   001208 cd540d          	CALL	CHKWPRT		;check write protect status.
  3001   00120b 2a430b          	LD	HL,(PARAMS)
  3002   00120e cd470d          	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
  3003   001211 cdbb0c          	CALL	STRDATA		;put updated data into fcb.
  3004   001214 3ae315          	LD	A,(SAVNREC)	;get record number to write.
  3005   001217 fe80            	CP	128		;within range?
  3006   001219 d2050b          	JP	NC,IOERR1	;no, error(?).
  3007   00121c cd770c          	CALL	COMBLK		;compute block number.
  3008   00121f cd840c          	CALL	CHKBLK		;check number.
  3009   001222 0e00            	LD	C,0		;is there one to write to?
  3010   001224 c26e12          	JP	NZ,WTSEQ6	;yes, go do it.
  3011   001227 cd3e0c          	CALL	GETBLOCK	;get next block number within fcb to use.
  3012   00122a 32d715          	LD	(RELBLOCK),A	;and save.
  3013   00122d 010000          	LD	BC,0		;start looking for space from the start
  3014   001230 b7              	OR	A		;if none allocated as yet.
  3015   001231 ca3b12          	JP	Z,WTSEQ2
  3016   001234 4f              	LD	C,A		;extract previous block number from fcb
  3017   001235 0b              	DEC	BC		;so we can be closest to it.
  3018   001236 cd5e0c          	CALL	EXTBLK
  3019   001239 44              	LD	B,H
  3020   00123a 4d              	LD	C,L
  3021   00123b cdbe0f          WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
  3022   00123e 7d              	LD	A,L		;check for a zero number.
  3023   00123f b4              	OR	H
  3024   001240 c24812          	JP	NZ,WTSEQ3
  3025   001243 3e02            	LD	A,2		;no more space?
  3026   001245 c3010b          	JP	SETSTAT
  3027   001248 22e515          WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
  3028   00124b eb              	EX	DE,HL		;put block number into (DE).
  3029   00124c 2a430b          	LD	HL,(PARAMS)	;now we must update the fcb for this
  3030   00124f 011000          	LD	BC,16		;newly allocated block.
  3031   001252 09              	ADD	HL,BC
  3032   001253 3add15          	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
  3033   001256 b7              	OR	A
  3034   001257 3ad715          	LD	A,(RELBLOCK)	;(* update this entry *)
  3035   00125a ca6412          	JP	Z,WTSEQ4	;zero means 16 bit ones.
  3036   00125d cd640d          	CALL	ADDA2HL		;(HL)=(HL)+(A)
  3037   001260 73              	LD	(HL),E		;store new block number.
  3038   001261 c36c12          	JP	WTSEQ5
  3039   001264 4f              WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
  3040   001265 0600            	LD	B,0
  3041   001267 09              	ADD	HL,BC
  3042   001268 09              	ADD	HL,BC
  3043   001269 73              	LD	(HL),E		;stuff block number (DE) there.
  3044   00126a 23              	INC	HL
  3045   00126b 72              	LD	(HL),D
  3046   00126c 0e02            WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
  3047   00126e 3a450b          WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
  3048   001271 b7              	OR	A
  3049   001272 c0              	RET	NZ
  3050   001273 c5              	PUSH	BC		;yes, save write flag for bios (register C).
  3051   001274 cd8a0c          	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
  3052   001277 3ad515          	LD	A,(MODE)	;get access mode flag (1=sequential,
  3053   00127a 3d              	DEC	A		;0=random, 2=special?).
  3054   00127b 3d              	DEC	A
  3055   00127c c2bb12          	JP	NZ,WTSEQ9
  3056                          ;
  3057                          ;   Special random i/o from function #40. Maybe for M/PM, but the
  3058                          ; current block, if it has not been written to, will be zeroed
  3059                          ; out and then written (reason?).
  3060                          ;
  3061   00127f c1              	POP	BC
  3062   001280 c5              	PUSH	BC
  3063   001281 79              	LD	A,C		;get write status flag (2=writing unused space).
  3064   001282 3d              	DEC	A
  3065   001283 3d              	DEC	A
  3066   001284 c2bb12          	JP	NZ,WTSEQ9
  3067   001287 e5              	PUSH	HL
  3068   001288 2ab915          	LD	HL,(DIRBUF)	;zero out the directory buffer.
  3069   00128b 57              	LD	D,A		;note that (A) is zero here.
  3070   00128c 77              WTSEQ7:	LD	(HL),A
  3071   00128d 23              	INC	HL
  3072   00128e 14              	INC	D		;do 128 bytes.
  3073   00128f f28c12          	JP	P,WTSEQ7
  3074   001292 cde00d          	CALL	DIRDMA		;tell the bios the dma address for directory access.
  3075   001295 2ae715          	LD	HL,(LOGSECT)	;get sector that starts current block.
  3076   001298 0e02            	LD	C,2		;set 'writing to unused space' flag.
  3077   00129a 22e515          WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
  3078   00129d c5              	PUSH	BC
  3079   00129e cdd10b          	CALL	TRKSEC1		;determine its track and sector numbers.
  3080   0012a1 c1              	POP	BC
  3081   0012a2 cdb80b          	CALL	DOWRITE		;now write out 128 bytes of zeros.
  3082   0012a5 2ae515          	LD	HL,(BLKNMBR)	;get sector number.
  3083   0012a8 0e00            	LD	C,0		;set normal write flag.
  3084   0012aa 3ac415          	LD	A,(BLKMASK)	;determine if we have written the entire
  3085   0012ad 47              	LD	B,A		;physical block.
  3086   0012ae a5              	AND	L
  3087   0012af b8              	CP	B
  3088   0012b0 23              	INC	HL		;prepare for the next one.
  3089   0012b1 c29a12          	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
  3090   0012b4 e1              	POP	HL		;reset next sector number.
  3091   0012b5 22e515          	LD	(BLKNMBR),HL
  3092   0012b8 cdda0d          	CALL	DEFDMA		;and reset dma address.
  3093                          ;
  3094                          ;   Normal disk write. Set the desired track and sector then
  3095                          ; do the actual write.
  3096                          ;
  3097   0012bb cdd10b          WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
  3098   0012be c1              	POP	BC		;get write status flag.
  3099   0012bf c5              	PUSH	BC
  3100   0012c0 cdb80b          	CALL	DOWRITE		;and write this out.
  3101   0012c3 c1              	POP	BC
  3102   0012c4 3ae315          	LD	A,(SAVNREC)	;get number of records in file.
  3103   0012c7 21e115          	LD	HL,SAVNXT	;get last record written.
  3104   0012ca be              	CP	(HL)
  3105   0012cb dad212          	JP	C,WTSEQ10
  3106   0012ce 77              	LD	(HL),A		;we have to update record count.
  3107   0012cf 34              	INC	(HL)
  3108   0012d0 0e02            	LD	C,2
  3109                          ;
  3110                          ;*   This area has been patched to correct disk update problem
  3111                          ;* when using blocking and de-blocking in the BIOS.
  3112                          ;
  3113   0012d2 00              WTSEQ10:NOP			;was 'dcr c'
  3114   0012d3 00              	NOP			;was 'dcr c'
  3115   0012d4 210000          	LD	HL,0		;was 'jnz wtseq99'
  3116                          ;
  3117                          ; *   End of patch.
  3118                          ;
  3119   0012d7 f5              	PUSH	AF
  3120   0012d8 cd690d          	CALL	GETS2		;set 'extent written to' flag.
  3121   0012db e67f            	AND	7FH		;(* clear bit 7 *)
  3122   0012dd 77              	LD	(HL),A
  3123   0012de f1              	POP	AF		;get record count for this extent.
  3124   0012df fe7f            WTSEQ99:CP	127		;is it full?
  3125   0012e1 c20013          	JP	NZ,WTSEQ12
  3126   0012e4 3ad515          	LD	A,(MODE)	;yes, are we in sequential mode?
  3127   0012e7 fe01            	CP	1
  3128   0012e9 c20013          	JP	NZ,WTSEQ12
  3129   0012ec cdd20c          	CALL	SETNREC		;yes, set next record number.
  3130   0012ef cd5a11          	CALL	GETNEXT		;and get next empty space in directory.
  3131   0012f2 21450b          	LD	HL,STATUS	;ok?
  3132   0012f5 7e              	LD	A,(HL)
  3133   0012f6 b7              	OR	A
  3134   0012f7 c2fe12          	JP	NZ,WTSEQ11
  3135   0012fa 3d              	DEC	A		;yes, set record count to -1.
  3136   0012fb 32e315          	LD	(SAVNREC),A
  3137   0012fe 3600            WTSEQ11:LD	(HL),0		;clear status.
  3138   001300 c3d20c          WTSEQ12:JP	SETNREC		;set next record to access.
  3139                          ;
  3140                          ;   For random i/o, set the fcb for the desired record number
  3141                          ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
  3142                          ; used as follows:
  3143                          ;
  3144                          ;       fcb+35            fcb+34            fcb+33
  3145                          ;  |     'r-2'      |      'r-1'      |      'r-0'     |
  3146                          ;  |7             0 | 7             0 | 7             0|
  3147                          ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
  3148                          ;  |    overflow   | | extra |  extent   |   record #  |
  3149                          ;  | ______________| |_extent|__number___|_____________|
  3150                          ;                     also 's2'
  3151                          ;
  3152                          ;   On entry, register (C) contains 0ffh if this is a read
  3153                          ; and thus we can not access unwritten disk space. Otherwise,
  3154                          ; another extent will be opened (for writing) if required.
  3155                          ;
  3156   001303 af              POSITION: XOR	A		;set random i/o flag.
  3157   001304 32d515          	LD	(MODE),A
  3158                          ;
  3159                          ;   Special entry (function #40). M/PM ?
  3160                          ;
  3161   001307 c5              POSITN1:PUSH	BC		;save read/write flag.
  3162   001308 2a430b          	LD	HL,(PARAMS)	;get address of fcb.
  3163   00130b eb              	EX	DE,HL
  3164   00130c 212100          	LD	HL,33		;now get byte 'r0'.
  3165   00130f 19              	ADD	HL,DE
  3166   001310 7e              	LD	A,(HL)
  3167   001311 e67f            	AND	7FH		;keep bits 0-6 for the record number to access.
  3168   001313 f5              	PUSH	AF
  3169   001314 7e              	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
  3170   001315 17              	RLA
  3171   001316 23              	INC	HL
  3172   001317 7e              	LD	A,(HL)
  3173   001318 17              	RLA
  3174   001319 e61f            	AND	1FH		;and save this in bits 0-4 of (C).
  3175   00131b 4f              	LD	C,A		;this is the extent byte.
  3176   00131c 7e              	LD	A,(HL)		;now get the extra extent byte.
  3177   00131d 1f              	RRA
  3178   00131e 1f              	RRA
  3179   00131f 1f              	RRA
  3180   001320 1f              	RRA
  3181   001321 e60f            	AND	0FH
  3182   001323 47              	LD	B,A		;and save it in (B).
  3183   001324 f1              	POP	AF		;get record number back to (A).
  3184   001325 23              	INC	HL		;check overflow byte 'r2'.
  3185   001326 6e              	LD	L,(HL)
  3186   001327 2c              	INC	L
  3187   001328 2d              	DEC	L
  3188   001329 2e06            	LD	L,6		;prepare for error.
  3189   00132b c28b13          	JP	NZ,POSITN5	;out of disk space error.
  3190   00132e 212000          	LD	HL,32		;store record number into fcb.
  3191   001331 19              	ADD	HL,DE
  3192   001332 77              	LD	(HL),A
  3193   001333 210c00          	LD	HL,12		;and now check the extent byte.
  3194   001336 19              	ADD	HL,DE
  3195   001337 79              	LD	A,C
  3196   001338 96              	SUB	(HL)		;same extent as before?
  3197   001339 c24713          	JP	NZ,POSITN2
  3198   00133c 210e00          	LD	HL,14		;yes, check extra extent byte 's2' also.
  3199   00133f 19              	ADD	HL,DE
  3200   001340 78              	LD	A,B
  3201   001341 96              	SUB	(HL)
  3202   001342 e67f            	AND	7FH
  3203   001344 ca7f13          	JP	Z,POSITN3	;same, we are almost done then.
  3204                          ;
  3205                          ;  Get here when another extent is required.
  3206                          ;
  3207   001347 c5              POSITN2:PUSH	BC
  3208   001348 d5              	PUSH	DE
  3209   001349 cda210          	CALL	CLOSEIT		;close current extent.
  3210   00134c d1              	POP	DE
  3211   00134d c1              	POP	BC
  3212   00134e 2e03            	LD	L,3		;prepare for error.
  3213   001350 3a450b          	LD	A,(STATUS)
  3214   001353 3c              	INC	A
  3215   001354 ca8413          	JP	Z,POSITN4	;close error.
  3216   001357 210c00          	LD	HL,12		;put desired extent into fcb now.
  3217   00135a 19              	ADD	HL,DE
  3218   00135b 71              	LD	(HL),C
  3219   00135c 210e00          	LD	HL,14		;and store extra extent byte 's2'.
  3220   00135f 19              	ADD	HL,DE
  3221   001360 70              	LD	(HL),B
  3222   001361 cd5110          	CALL	OPENIT		;try and get this extent.
  3223   001364 3a450b          	LD	A,(STATUS)	;was it there?
  3224   001367 3c              	INC	A
  3225   001368 c27f13          	JP	NZ,POSITN3
  3226   00136b c1              	POP	BC		;no. can we create a new one (writing?).
  3227   00136c c5              	PUSH	BC
  3228   00136d 2e04            	LD	L,4		;prepare for error.
  3229   00136f 0c              	INC	C
  3230   001370 ca8413          	JP	Z,POSITN4	;nope, reading unwritten space error.
  3231   001373 cd2411          	CALL	GETEMPTY	;yes we can, try to find space.
  3232   001376 2e05            	LD	L,5		;prepare for error.
  3233   001378 3a450b          	LD	A,(STATUS)
  3234   00137b 3c              	INC	A
  3235   00137c ca8413          	JP	Z,POSITN4	;out of space?
  3236                          ;
  3237                          ;   Normal return location. Clear error code and return.
  3238                          ;
  3239   00137f c1              POSITN3:POP	BC		;restore stack.
  3240   001380 af              	XOR	A		;and clear error code byte.
  3241   001381 c3010b          	JP	SETSTAT
  3242                          ;
  3243                          ;   Error. Set the 's2' byte to indicate this (why?).
  3244                          ;
  3245   001384 e5              POSITN4:PUSH	HL
  3246   001385 cd690d          	CALL	GETS2
  3247   001388 36c0            	LD	(HL),0C0H
  3248   00138a e1              	POP	HL
  3249                          ;
  3250                          ;   Return with error code (presently in L).
  3251                          ;
  3252   00138b c1              POSITN5:POP	BC
  3253   00138c 7d              	LD	A,L		;get error code.
  3254   00138d 32450b          	LD	(STATUS),A
  3255   001390 c3780d          	JP	SETS2B7
  3256                          ;
  3257                          ;   Read a random record.
  3258                          ;
  3259   001393 0eff            READRAN:LD	C,0FFH		;set 'read' status.
  3260   001395 cd0313          	CALL	POSITION	;position the file to proper record.
  3261   001398 ccc111          	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
  3262   00139b c9              	RET
  3263                          ;
  3264                          ;   Write to a random record.
  3265                          ;
  3266   00139c 0e00            WRITERAN: LD	C,0		;set 'writing' flag.
  3267   00139e cd0313          	CALL	POSITION	;position the file to proper record.
  3268   0013a1 cc0312          	CALL	Z,WTSEQ1	;and write as usual (if no errors).
  3269   0013a4 c9              	RET
  3270                          ;
  3271                          ;   Compute the random record number. Enter with (HL) pointing
  3272                          ; to a fcb an (DE) contains a relative location of a record
  3273                          ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
  3274                          ; byte, and (A) the 'r2' byte.
  3275                          ;
  3276                          ;   On return, the zero flag is set if the record is within
  3277                          ; bounds. Otherwise, an overflow occured.
  3278                          ;
  3279   0013a5 eb              COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
  3280   0013a6 19              	ADD	HL,DE		;compute relative position of record #.
  3281   0013a7 4e              	LD	C,(HL)		;get record number into (BC).
  3282   0013a8 0600            	LD	B,0
  3283   0013aa 210c00          	LD	HL,12		;now get extent.
  3284   0013ad 19              	ADD	HL,DE
  3285   0013ae 7e              	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
  3286   0013af 0f              	RRCA			;move lower bit into bit 7.
  3287   0013b0 e680            	AND	80H		;and ignore all other bits.
  3288   0013b2 81              	ADD	A,C		;add to our record number.
  3289   0013b3 4f              	LD	C,A
  3290   0013b4 3e00            	LD	A,0		;take care of any carry.
  3291   0013b6 88              	ADC	A,B
  3292   0013b7 47              	LD	B,A
  3293   0013b8 7e              	LD	A,(HL)		;now get the upper bits of extent into
  3294   0013b9 0f              	RRCA			;bit positions 0-3.
  3295   0013ba e60f            	AND	0FH		;and ignore all others.
  3296   0013bc 80              	ADD	A,B		;add this in to 'r1' byte.
  3297   0013bd 47              	LD	B,A
  3298   0013be 210e00          	LD	HL,14		;get the 's2' byte (extra extent).
  3299   0013c1 19              	ADD	HL,DE
  3300   0013c2 7e              	LD	A,(HL)
  3301   0013c3 87              	ADD	A,A		;and shift it left 4 bits (bits 4-7).
  3302   0013c4 87              	ADD	A,A
  3303   0013c5 87              	ADD	A,A
  3304   0013c6 87              	ADD	A,A
  3305   0013c7 f5              	PUSH	AF		;save carry flag (bit 0 of flag byte).
  3306   0013c8 80              	ADD	A,B		;now add extra extent into 'r1'.
  3307   0013c9 47              	LD	B,A
  3308   0013ca f5              	PUSH	AF		;and save carry (overflow byte 'r2').
  3309   0013cb e1              	POP	HL		;bit 0 of (L) is the overflow indicator.
  3310   0013cc 7d              	LD	A,L
  3311   0013cd e1              	POP	HL		;and same for first carry flag.
  3312   0013ce b5              	OR	L		;either one of these set?
  3313   0013cf e601            	AND	01H		;only check the carry flags.
  3314   0013d1 c9              	RET
  3315                          ;
  3316                          ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
  3317                          ; reflect the last record used for a random (or other) file.
  3318                          ; This reads the directory and looks at all extents computing
  3319                          ; the largerst record number for each and keeping the maximum
  3320                          ; value only. Then 'r0', 'r1', and 'r2' will reflect this
  3321                          ; maximum record number. This is used to compute the space used
  3322                          ; by a random file.
  3323                          ;
  3324   0013d2 0e0c            RANSIZE:LD	C,12		;look thru directory for first entry with
  3325   0013d4 cd180f          	CALL	FINDFST		;this name.
  3326   0013d7 2a430b          	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
  3327   0013da 112100          	LD	DE,33
  3328   0013dd 19              	ADD	HL,DE
  3329   0013de e5              	PUSH	HL
  3330   0013df 72              	LD	(HL),D		;note that (D)=0.
  3331   0013e0 23              	INC	HL
  3332   0013e1 72              	LD	(HL),D
  3333   0013e2 23              	INC	HL
  3334   0013e3 72              	LD	(HL),D
  3335   0013e4 cdf50d          RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
  3336   0013e7 ca0c14          	JP	Z,RANSIZ3	;no, we are done.
  3337   0013ea cd5e0d          	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
  3338   0013ed 110f00          	LD	DE,15		;point to last record in extent.
  3339   0013f0 cda513          	CALL	COMPRAND	;and compute random parameters.
  3340   0013f3 e1              	POP	HL
  3341   0013f4 e5              	PUSH	HL		;now check these values against those
  3342   0013f5 5f              	LD	E,A		;already in fcb.
  3343   0013f6 79              	LD	A,C		;the carry flag will be set if those
  3344   0013f7 96              	SUB	(HL)		;in the fcb represent a larger size than
  3345   0013f8 23              	INC	HL		;this extent does.
  3346   0013f9 78              	LD	A,B
  3347   0013fa 9e              	SBC	A,(HL)
  3348   0013fb 23              	INC	HL
  3349   0013fc 7b              	LD	A,E
  3350   0013fd 9e              	SBC	A,(HL)
  3351   0013fe da0614          	JP	C,RANSIZ2
  3352   001401 73              	LD	(HL),E		;we found a larger (in size) extent.
  3353   001402 2b              	DEC	HL		;stuff these values into fcb.
  3354   001403 70              	LD	(HL),B
  3355   001404 2b              	DEC	HL
  3356   001405 71              	LD	(HL),C
  3357   001406 cd2d0f          RANSIZ2:CALL	FINDNXT		;now get the next extent.
  3358   001409 c3e413          	JP	RANSIZ1		;continue til all done.
  3359   00140c e1              RANSIZ3:POP	HL		;we are done, restore the stack and
  3360   00140d c9              	RET			;return.
  3361                          ;
  3362                          ;   Function to return the random record position of a given
  3363                          ; file which has been read in sequential mode up to now.
  3364                          ;
  3365   00140e 2a430b          SETRAN:	LD	HL,(PARAMS)	;point to fcb.
  3366   001411 112000          	LD	DE,32		;and to last used record.
  3367   001414 cda513          	CALL	COMPRAND	;compute random position.
  3368   001417 212100          	LD	HL,33		;now stuff these values into fcb.
  3369   00141a 19              	ADD	HL,DE
  3370   00141b 71              	LD	(HL),C		;move 'r0'.
  3371   00141c 23              	INC	HL
  3372   00141d 70              	LD	(HL),B		;and 'r1'.
  3373   00141e 23              	INC	HL
  3374   00141f 77              	LD	(HL),A		;and lastly 'r2'.
  3375   001420 c9              	RET
  3376                          ;
  3377                          ;   This routine select the drive specified in (ACTIVE) and
  3378                          ; update the login vector and bitmap table if this drive was
  3379                          ; not already active.
  3380                          ;
  3381   001421 2aaf15          LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
  3382   001424 3a420b          	LD	A,(ACTIVE)	;get the default drive.
  3383   001427 4f              	LD	C,A
  3384   001428 cdea0c          	CALL	SHIFTR		;position active bit for this drive
  3385   00142b e5              	PUSH	HL		;into bit 0.
  3386   00142c eb              	EX	DE,HL
  3387   00142d cd590b          	CALL	SELECT		;select this drive.
  3388   001430 e1              	POP	HL
  3389   001431 cc470b          	CALL	Z,SLCTERR	;valid drive?
  3390   001434 7d              	LD	A,L		;is this a newly activated drive?
  3391   001435 1f              	RRA
  3392   001436 d8              	RET	C
  3393   001437 2aaf15          	LD	HL,(LOGIN)	;yes, update the login vector.
  3394   00143a 4d              	LD	C,L
  3395   00143b 44              	LD	B,H
  3396   00143c cd0b0d          	CALL	SETBIT
  3397   00143f 22af15          	LD	(LOGIN),HL	;and save.
  3398   001442 c3a30e          	JP	BITMAP		;now update the bitmap.
  3399                          ;
  3400                          ;   Function to set the active disk number.
  3401                          ;
  3402   001445 3ad615          SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
  3403   001448 21420b          	LD	HL,ACTIVE	;represents a change in drives.
  3404   00144b be              	CP	(HL)
  3405   00144c c8              	RET	Z
  3406   00144d 77              	LD	(HL),A		;yes it does, log it in.
  3407   00144e c32114          	JP	LOGINDRV
  3408                          ;
  3409                          ;   This is the 'auto disk select' routine. The firsst byte
  3410                          ; of the fcb is examined for a drive specification. If non
  3411                          ; zero then the drive will be selected and loged in.
  3412                          ;
  3413   001451 3eff            AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
  3414   001453 32de15          	LD	(AUTO),A
  3415   001456 2a430b          	LD	HL,(PARAMS)	;get drive specified.
  3416   001459 7e              	LD	A,(HL)
  3417   00145a e61f            	AND	1FH		;look at lower 5 bits.
  3418   00145c 3d              	DEC	A		;adjust for (1=A, 2=B) etc.
  3419   00145d 32d615          	LD	(EPARAM),A	;and save for the select routine.
  3420   001460 fe1e            	CP	1EH		;check for 'no change' condition.
  3421   001462 d27514          	JP	NC,AUTOSL1	;yes, don't change.
  3422   001465 3a420b          	LD	A,(ACTIVE)	;we must change, save currently active
  3423   001468 32df15          	LD	(OLDDRV),A	;drive.
  3424   00146b 7e              	LD	A,(HL)		;and save first byte of fcb also.
  3425   00146c 32e015          	LD	(AUTOFLAG),A	;this must be non-zero.
  3426   00146f e6e0            	AND	0E0H		;whats this for (bits 6,7 are used for
  3427   001471 77              	LD	(HL),A		;something)?
  3428   001472 cd4514          	CALL	SETDSK		;select and log in this drive.
  3429   001475 3a410b          AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
  3430   001478 2a430b          	LD	HL,(PARAMS)	;(* upper half of first byte *)
  3431   00147b b6              	OR	(HL)
  3432   00147c 77              	LD	(HL),A
  3433   00147d c9              	RET			;and return (all done).
  3434                          ;
  3435                          ;   Function to return the current cp/m version number.
  3436                          ;
  3437   00147e 3e22            GETVER:	LD	A,022H		;version 2.2
  3438   001480 c3010b          	JP	SETSTAT
  3439                          ;
  3440                          ;   Function to reset the disk system.
  3441                          ;
  3442   001483 210000          RSTDSK:	LD	HL,0		;clear write protect status and log
  3443   001486 22ad15          	LD	(WRTPRT),HL	;in vector.
  3444   001489 22af15          	LD	(LOGIN),HL
  3445   00148c af              	XOR	A		;select drive 'A'.
  3446   00148d 32420b          	LD	(ACTIVE),A
  3447   001490 218000          	LD	HL,TBUFF	;setup default dma address.
  3448   001493 22b115          	LD	(USERDMA),HL
  3449   001496 cdda0d          	CALL	DEFDMA
  3450   001499 c32114          	JP	LOGINDRV	;now log in drive 'A'.
  3451                          ;
  3452                          ;   Function to open a specified file.
  3453                          ;
  3454   00149c cd720d          OPENFIL:CALL	CLEARS2		;clear 's2' byte.
  3455   00149f cd5114          	CALL	AUTOSEL		;select proper disk.
  3456   0014a2 c35110          	JP	OPENIT		;and open the file.
  3457                          ;
  3458                          ;   Function to close a specified file.
  3459                          ;
  3460   0014a5 cd5114          CLOSEFIL: CALL	AUTOSEL		;select proper disk.
  3461   0014a8 c3a210          	JP	CLOSEIT		;and close the file.
  3462                          ;
  3463                          ;   Function to return the first occurence of a specified file
  3464                          ; name. If the first byte of the fcb is '?' then the name will
  3465                          ; not be checked (get the first entry no matter what).
  3466                          ;
  3467   0014ab 0e00            GETFST:	LD	C,0		;prepare for special search.
  3468   0014ad eb              	EX	DE,HL
  3469   0014ae 7e              	LD	A,(HL)		;is first byte a '?'?
  3470   0014af fe3f            	CP	'?'
  3471   0014b1 cac214          	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
  3472   0014b4 cda60c          	CALL	SETEXT		;get the extension byte from fcb.
  3473   0014b7 7e              	LD	A,(HL)		;is it '?'? if yes, then we want
  3474   0014b8 fe3f            	CP	'?'		;an entry with a specific 's2' byte.
  3475   0014ba c4720d          	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
  3476   0014bd cd5114          	CALL	AUTOSEL		;select proper drive.
  3477   0014c0 0e0f            	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
  3478   0014c2 cd180f          GETFST1:CALL	FINDFST		;find an entry and then move it into
  3479   0014c5 c3e90d          	JP	MOVEDIR		;the users dma space.
  3480                          ;
  3481                          ;   Function to return the next occurence of a file name.
  3482                          ;
  3483   0014c8 2ad915          GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
  3484   0014cb 22430b          	LD	(PARAMS),HL	;other dbos calls are allowed.
  3485   0014ce cd5114          	CALL	AUTOSEL		;no error will be returned, but the
  3486   0014d1 cd2d0f          	CALL	FINDNXT		;results will be wrong.
  3487   0014d4 c3e90d          	JP	MOVEDIR
  3488                          ;
  3489                          ;   Function to delete a file by name.
  3490                          ;
  3491   0014d7 cd5114          DELFILE:CALL	AUTOSEL		;select proper drive.
  3492   0014da cd9c0f          	CALL	ERAFILE		;erase the file.
  3493   0014dd c3010f          	JP	STSTATUS	;set status and return.
  3494                          ;
  3495                          ;   Function to execute a sequential read of the specified
  3496                          ; record number.
  3497                          ;
  3498   0014e0 cd5114          READSEQ:CALL	AUTOSEL		;select proper drive then read.
  3499   0014e3 c3bc11          	JP	RDSEQ
  3500                          ;
  3501                          ;   Function to write the net sequential record.
  3502                          ;
  3503   0014e6 cd5114          WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
  3504   0014e9 c3fe11          	JP	WTSEQ
  3505                          ;
  3506                          ;   Create a file function.
  3507                          ;
  3508   0014ec cd720d          FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
  3509   0014ef cd5114          	CALL	AUTOSEL		;select proper drive and get the next
  3510   0014f2 c32411          	JP	GETEMPTY	;empty directory space.
  3511                          ;
  3512                          ;   Function to rename a file.
  3513                          ;
  3514   0014f5 cd5114          RENFILE:CALL	AUTOSEL		;select proper drive and then switch
  3515   0014f8 cd1610          	CALL	CHGNAMES	;file names.
  3516   0014fb c3010f          	JP	STSTATUS
  3517                          ;
  3518                          ;   Function to return the login vector.
  3519                          ;
  3520   0014fe 2aaf15          GETLOG:	LD	HL,(LOGIN)
  3521   001501 c32915          	JP	GETPRM1
  3522                          ;
  3523                          ;   Function to return the current disk assignment.
  3524                          ;
  3525   001504 3a420b          GETCRNT:LD	A,(ACTIVE)
  3526   001507 c3010b          	JP	SETSTAT
  3527                          ;
  3528                          ;   Function to set the dma address.
  3529                          ;
  3530   00150a eb              PUTDMA:	EX	DE,HL
  3531   00150b 22b115          	LD	(USERDMA),HL	;save in our space and then get to
  3532   00150e c3da0d          	JP	DEFDMA		;the bios with this also.
  3533                          ;
  3534                          ;   Function to return the allocation vector.
  3535                          ;
  3536   001511 2abf15          GETALOC:LD	HL,(ALOCVECT)
  3537   001514 c32915          	JP	GETPRM1
  3538                          ;
  3539                          ;   Function to return the read-only status vector.
  3540                          ;
  3541   001517 2aad15          GETROV:	LD	HL,(WRTPRT)
  3542   00151a c32915          	JP	GETPRM1
  3543                          ;
  3544                          ;   Function to set the file attributes (read-only, system).
  3545                          ;
  3546   00151d cd5114          SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
  3547   001520 cd3b10          	CALL	SAVEATTR
  3548   001523 c3010f          	JP	STSTATUS
  3549                          ;
  3550                          ;   Function to return the address of the disk parameter block
  3551                          ; for the current drive.
  3552                          ;
  3553   001526 2abb15          GETPARM:LD	HL,(DISKPB)
  3554   001529 22450b          GETPRM1:LD	(STATUS),HL
  3555   00152c c9              	RET
  3556                          ;
  3557                          ;   Function to get or set the user number. If (E) was (FF)
  3558                          ; then this is a request to return the current user number.
  3559                          ; Else set the user number from (E).
  3560                          ;
  3561   00152d 3ad615          GETUSER:LD	A,(EPARAM)	;get parameter.
  3562   001530 feff            	CP	0FFH		;get user number?
  3563   001532 c23b15          	JP	NZ,SETUSER
  3564   001535 3a410b          	LD	A,(USERNO)	;yes, just do it.
  3565   001538 c3010b          	JP	SETSTAT
  3566   00153b e61f            SETUSER:AND	1FH		;no, we should set it instead. keep low
  3567   00153d 32410b          	LD	(USERNO),A	;bits (0-4) only.
  3568   001540 c9              	RET
  3569                          ;
  3570                          ;   Function to read a random record from a file.
  3571                          ;
  3572   001541 cd5114          RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
  3573   001544 c39313          	JP	READRAN
  3574                          ;
  3575                          ;   Function to compute the file size for random files.
  3576                          ;
  3577   001547 cd5114          WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
  3578   00154a c39c13          	JP	WRITERAN
  3579                          ;
  3580                          ;   Function to compute the size of a random file.
  3581                          ;
  3582   00154d cd5114          FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
  3583   001550 c3d213          	JP	RANSIZE
  3584                          ;
  3585                          ;   Function #37. This allows a program to log off any drives.
  3586                          ; On entry, set (DE) to contain a word with bits set for those
  3587                          ; drives that are to be logged off. The log-in vector and the
  3588                          ; write protect vector will be updated. This must be a M/PM
  3589                          ; special function.
  3590                          ;
  3591   001553 2a430b          LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
  3592   001556 7d              	LD	A,L		;for each bit that is set, we want
  3593   001557 2f              	CPL			;to clear that bit in (LOGIN)
  3594   001558 5f              	LD	E,A		;and (WRTPRT).
  3595   001559 7c              	LD	A,H
  3596   00155a 2f              	CPL
  3597   00155b 2aaf15          	LD	HL,(LOGIN)	;reset the login vector.
  3598   00155e a4              	AND	H
  3599   00155f 57              	LD	D,A
  3600   001560 7d              	LD	A,L
  3601   001561 a3              	AND	E
  3602   001562 5f              	LD	E,A
  3603   001563 2aad15          	LD	HL,(WRTPRT)
  3604   001566 eb              	EX	DE,HL
  3605   001567 22af15          	LD	(LOGIN),HL	;and save.
  3606   00156a 7d              	LD	A,L		;now do the write protect vector.
  3607   00156b a3              	AND	E
  3608   00156c 6f              	LD	L,A
  3609   00156d 7c              	LD	A,H
  3610   00156e a2              	AND	D
  3611   00156f 67              	LD	H,A
  3612   001570 22ad15          	LD	(WRTPRT),HL	;and save. all done.
  3613   001573 c9              	RET
  3614                          ;
  3615                          ;   Get here to return to the user.
  3616                          ;
  3617   001574 3ade15          GOBACK:	LD	A,(AUTO)	;was auto select activated?
  3618   001577 b7              	OR	A
  3619   001578 ca9115          	JP	Z,GOBACK1
  3620   00157b 2a430b          	LD	HL,(PARAMS)	;yes, but was a change made?
  3621   00157e 3600            	LD	(HL),0		;(* reset first byte of fcb *)
  3622   001580 3ae015          	LD	A,(AUTOFLAG)
  3623   001583 b7              	OR	A
  3624   001584 ca9115          	JP	Z,GOBACK1
  3625   001587 77              	LD	(HL),A		;yes, reset first byte properly.
  3626   001588 3adf15          	LD	A,(OLDDRV)	;and get the old drive and select it.
  3627   00158b 32d615          	LD	(EPARAM),A
  3628   00158e cd4514          	CALL	SETDSK
  3629   001591 2a0f0b          GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
  3630   001594 f9              	LD	SP,HL
  3631   001595 2a450b          	LD	HL,(STATUS)	;get return status.
  3632   001598 7d              	LD	A,L		;force version 1.4 compatability.
  3633   001599 44              	LD	B,H
  3634   00159a c9              	RET			;and go back to user.
  3635                          ;
  3636                          ;   Function #40. This is a special entry to do random i/o.
  3637                          ; For the case where we are writing to unused disk space, this
  3638                          ; space will be zeroed out first. This must be a M/PM special
  3639                          ; purpose function, because why would any normal program even
  3640                          ; care about the previous contents of a sector about to be
  3641                          ; written over.
  3642                          ;
  3643   00159b cd5114          WTSPECL:CALL	AUTOSEL		;select proper drive.
  3644   00159e 3e02            	LD	A,2		;use special write mode.
  3645   0015a0 32d515          	LD	(MODE),A
  3646   0015a3 0e00            	LD	C,0		;set write indicator.
  3647   0015a5 cd0713          	CALL	POSITN1		;position the file.
  3648   0015a8 cc0312          	CALL	Z,WTSEQ1	;and write (if no errors).
  3649   0015ab c9              	RET
  3650                          ;
  3651                          ;**************************************************************
  3652                          ;*
  3653                          ;*     BDOS data storage pool.
  3654                          ;*
  3655                          ;**************************************************************
  3656                          ;
  3657   0015ac e5              EMPTYFCB: DB	0E5H		;empty directory segment indicator.
  3658   0015ad 0000            WRTPRT:	DW	0		;write protect status for all 16 drives.
  3659   0015af 0000            LOGIN:	DW	0		;drive active word (1 bit per drive).
  3660   0015b1 8000            USERDMA:DW	080H		;user's dma address (defaults to 80h).
  3661                          ;
  3662                          ;   Scratch areas from parameter block.
  3663                          ;
  3664   0015b3 0000            SCRATCH1: DW	0		;relative position within dir segment for file (0-3).
  3665   0015b5 0000            SCRATCH2: DW	0		;last selected track number.
  3666   0015b7 0000            SCRATCH3: DW	0		;last selected sector number.
  3667                          ;
  3668                          ;   Disk storage areas from parameter block.
  3669                          ;
  3670   0015b9 0000            DIRBUF:	DW	0		;address of directory buffer to use.
  3671   0015bb 0000            DISKPB:	DW	0		;contains address of disk parameter block.
  3672   0015bd 0000            CHKVECT:DW	0		;address of check vector.
  3673   0015bf 0000            ALOCVECT: DW	0		;address of allocation vector (bit map).
  3674                          ;
  3675                          ;   Parameter block returned from the bios.
  3676                          ;
  3677   0015c1 0000            SECTORS:DW	0		;sectors per track from bios.
  3678   0015c3 00              BLKSHFT:DB	0		;block shift.
  3679   0015c4 00              BLKMASK:DB	0		;block mask.
  3680   0015c5 00              EXTMASK:DB	0		;extent mask.
  3681   0015c6 0000            DSKSIZE:DW	0		;disk size from bios (number of blocks-1).
  3682   0015c8 0000            DIRSIZE:DW	0		;directory size.
  3683   0015ca 0000            ALLOC0:	DW	0		;storage for first bytes of bit map (dir space used).
  3684   0015cc 0000            ALLOC1:	DW	0
  3685   0015ce 0000            OFFSET:	DW	0		;first usable track number.
  3686   0015d0 0000            XLATE:	DW	0		;sector translation table address.
  3687                          ;
  3688                          ;
  3689   0015d2 00              CLOSEFLG: DB	0		;close flag (=0ffh is extent written ok).
  3690   0015d3 00              RDWRTFLG: DB	0		;read/write flag (0ffh=read, 0=write).
  3691   0015d4 00              FNDSTAT:DB	0		;filename found status (0=found first entry).
  3692   0015d5 00              MODE:	DB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
  3693   0015d6 00              EPARAM:	DB	0		;storage for register (E) on entry to bdos.
  3694   0015d7 00              RELBLOCK: DB	0		;relative position within fcb of block number written.
  3695   0015d8 00              COUNTER:DB	0		;byte counter for directory name searches.
  3696   0015d9 00000000        SAVEFCB:DW	0,0		;save space for address of fcb (for directory searches).
  3697   0015dd 00              BIGDISK:DB	0		;if =0 then disk is > 256 blocks long.
  3698   0015de 00              AUTO:	DB	0		;if non-zero, then auto select activated.
  3699   0015df 00              OLDDRV:	DB	0		;on auto select, storage for previous drive.
  3700   0015e0 00              AUTOFLAG: DB	0		;if non-zero, then auto select changed drives.
  3701   0015e1 00              SAVNXT:	DB	0		;storage for next record number to access.
  3702   0015e2 00              SAVEXT:	DB	0		;storage for extent number of file.
  3703   0015e3 0000            SAVNREC:DW	0		;storage for number of records in file.
  3704   0015e5 0000            BLKNMBR:DW	0		;block number (physical sector) used within a file or logical sect
  3705   0015e7 0000            LOGSECT:DW	0		;starting logical (128 byte) sector of block (physical sector).
  3706   0015e9 00              FCBPOS:	DB	0		;relative position within buffer for fcb of file of interest.
  3707   0015ea 0000            FILEPOS:DW	0		;files position within directory (0 to max entries -1).
  3708                          ;
  3709                          ;   Disk directory buffer checksum bytes. One for each of the
  3710                          ; 16 possible drives.
  3711                          ;
  3712   0015ec 0000000000000000CKSUMTBL: DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
  3713                          ;
  3714                          ;   Extra space ?
  3715                          ;
  3716   0015fc 00000000        	DB	0,0,0,0
  3717                          
  3718   001600 0000000000000000	DS	1024
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
  3719                          ;
  3720                          ;**************************************************************
  3721                          ;*
  3722                          ;*        B I O S   J U M P   T A B L E
  3723                          ;*
  3724                          ;**************************************************************
  3725                          ;
  3726                          BOOT:	equ	BIOS		;NOTE WE USE FAKE DESTINATIONS
  3727                          WBOOT:	equ	BIOS + 3
  3728                          CONST:	equ	BIOS + 6
  3729                          CONIN:	equ	BIOS + 9
  3730                          CONOUT:	equ	BIOS + 12
  3731                          LIST:	equ	BIOS + 15
  3732                          PUNCH:	equ	BIOS + 18
  3733                          READER:	equ	BIOS + 21
  3734                          HOME:	equ	BIOS + 24
  3735                          SELDSK:	equ	BIOS + 27
  3736                          SETTRK:	equ	BIOS + 30
  3737                          SETSEC:	equ	BIOS + 33
  3738                          SETDMA:	equ	BIOS + 36
  3739                          READ:	equ	BIOS + 39
  3740                          WRITE:	equ	BIOS + 42
  3741                          PRSTAT:	equ	BIOS + 45
  3742                          SECTRN:	equ	BIOS + 48
  3743                          ;
  3744                          ;*
  3745                          ;******************   E N D   O F   C P / M   *****************
  3746                          ;*
  3747                          
  3748                          ;	include "cpm22bios.asm"
  3749                          
