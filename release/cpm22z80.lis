cpm22z80.asm:
     1                          ;**************************************************************
     2                          ;*
     3                          ;*             C P / M   version   2 . 2
     4                          ;*
     5                          ;*   Reconstructed from memory image on February 27, 1981
     6                          ;*
     7                          ;*                by Clark A. Calkins
     8                          ;*
     9                          ;**************************************************************
    10                          ;
    11                          ;   Set memory limit here. This is the amount of contigeous
    12                          ; ram starting from 0000. CP/M will reside at the end of this space.
    13                          ;
    14                          MEM	EQU	64		;for a 62k system (TS802 TEST - WORKS OK).
    15                          ;
    16                          IOBYTE	EQU	3		;i/o definition byte.
    17                          TDRIVE	EQU	4		;current drive name and user number.
    18                          ENTRY	EQU	5		;entry point for the cp/m bdos.
    19                          TFCB	EQU	5CH		;default file control block.
    20                          TBUFF	EQU	80H		;i/o buffer and command line storage.
    21                          TBASE	EQU	100H		;transiant program storage area.
    22                          ;
    23                          ;   Set control character equates.
    24                          ;
    25                          CNTRLC	EQU	3		;control-c
    26                          CNTRLE	EQU	05H		;control-e
    27                          BS	EQU	08H		;backspace
    28                          TAB	EQU	09H		;tab
    29                          LF	EQU	0AH		;line feed
    30                          FF	EQU	0CH		;form feed
    31                          CR	EQU	0DH		;carriage return
    32                          CNTRLP	EQU	10H		;control-p
    33                          CNTRLR	EQU	12H		;control-r
    34                          CNTRLS	EQU	13H		;control-s
    35                          CNTRLU	EQU	15H		;control-u
    36                          CNTRLX	EQU	18H		;control-x
    37                          CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
    38                          DEL	EQU	7FH		;rubout
    39                          ;
    40                          ;   Set origin for CP/M
    41                          ;
    42                          	ORG	(MEM-7)*1024
    43                          ;
    44   000000 c35c03          CBASE:	JP	COMMAND		;execute command processor (ccp).
    45   000003 c35803          	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
    46                          
    47                          ;
    48                          ;   Standard cp/m ccp input buffer. Format is (max length),
    49                          ; (actual length), (char #1), (char #2), (char #3), etc.
    50                          ;
    51   000006 7f              INBUFF:	DB	127		;length of input buffer.
    52   000007 00              	DB	0		;current length of contents.
    53   000008 436f707972696768	DB	"Copyright"
                74              
    54   000011 2031393739202863	DB	" 1979 (c) by Digital Research      "
                2920627920446967
                6974616c20526573
                6561726368202020
                202020          
    55   000034 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                00000000000000  
    56   00004b 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                00000000000000  
    57   000062 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                00000000000000  
    58   000079 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                00000000000000  
    59   000088 0800            INPOINT:DW	INBUFF+2	;input line pointer
    60   00008a 0000            NAMEPNT:DW	0		;input line pointer used for error message. Points to
    61                          ;			;start of name in error.
    62                          ;
    63                          ;   Routine to print (A) on the console. All registers used.
    64                          ;
    65   00008c 5f              PRINT:	LD	E,A		;setup bdos call.
    66   00008d 0e02            	LD	C,2
    67   00008f c30500          	JP	ENTRY
    68                          ;
    69                          ;   Routine to print (A) on the console and to save (BC).
    70                          ;
    71   000092 c5              PRINTB:	PUSH	BC
    72   000093 cd8c00          	CALL	PRINT
    73   000096 c1              	POP	BC
    74   000097 c9              	RET
    75                          ;
    76                          ;   Routine to send a carriage return, line feed combination
    77                          ; to the console.
    78                          ;
    79   000098 3e0d            CRLF:	LD	A,CR
    80   00009a cd9200          	CALL	PRINTB
    81   00009d 3e0a            	LD	A,LF
    82   00009f c39200          	JP	PRINTB
    83                          ;
    84                          ;   Routine to send one space to the console and save (BC).
    85                          ;
    86   0000a2 3e20            SPACE:	LD	A,' '
    87   0000a4 c39200          	JP	PRINTB
    88                          ;
    89                          ;   Routine to print character string pointed to be (BC) on the
    90                          ; console. It must terminate with a null byte.
    91                          ;
    92   0000a7 c5              PLINE:	PUSH	BC
    93   0000a8 cd9800          	CALL	CRLF
    94   0000ab e1              	POP	HL
    95   0000ac 7e              PLINE2:	LD	A,(HL)
    96   0000ad b7              	OR	A
    97   0000ae c8              	RET	Z
    98   0000af 23              	INC	HL
    99   0000b0 e5              	PUSH	HL
   100   0000b1 cd8c00          	CALL	PRINT
   101   0000b4 e1              	POP	HL
   102   0000b5 c3ac00          	JP	PLINE2
   103                          ;
   104                          ;   Routine to reset the disk system.
   105                          ;
   106   0000b8 0e0d            RESDSK:	LD	C,13
   107   0000ba c30500          	JP	ENTRY
   108                          ;
   109                          ;   Routine to select disk (A).
   110                          ;
   111   0000bd 5f              DSKSEL:	LD	E,A
   112   0000be 0e0e            	LD	C,14
   113   0000c0 c30500          	JP	ENTRY
   114                          ;
   115                          ;   Routine to call bdos and save the return code. The zero
   116                          ; flag is set on a return of 0ffh.
   117                          ;
   118   0000c3 cd0500          ENTRY1:	CALL	ENTRY
   119   0000c6 32ee07          	LD	(RTNCODE),A	;save return code.
   120   0000c9 3c              	INC	A		;set zero if 0ffh returned.
   121   0000ca c9              	RET
   122                          ;
   123                          ;   Routine to open a file. (DE) must point to the FCB.
   124                          ;
   125   0000cb 0e0f            OPEN:	LD	C,15
   126   0000cd c3c300          	JP	ENTRY1
   127                          ;
   128                          ;   Routine to open file at (FCB).
   129                          ;
   130   0000d0 af              OPENFCB:XOR	A		;clear the record number byte at fcb+32
   131   0000d1 32ed07          	LD	(FCB+32),A
   132   0000d4 11cd07          	LD	DE,FCB
   133   0000d7 c3cb00          	JP	OPEN
   134                          ;
   135                          ;   Routine to close a file. (DE) points to FCB.
   136                          ;
   137   0000da 0e10            CLOSE:	LD	C,16
   138   0000dc c3c300          	JP	ENTRY1
   139                          ;
   140                          ;   Routine to search for the first file with ambigueous name
   141                          ; (DE).
   142                          ;
   143   0000df 0e11            SRCHFST:LD	C,17
   144   0000e1 c3c300          	JP	ENTRY1
   145                          ;
   146                          ;   Search for the next ambigeous file name.
   147                          ;
   148   0000e4 0e12            SRCHNXT:LD	C,18
   149   0000e6 c3c300          	JP	ENTRY1
   150                          ;
   151                          ;   Search for file at (FCB).
   152                          ;
   153   0000e9 11cd07          SRCHFCB:LD	DE,FCB
   154   0000ec c3df00          	JP	SRCHFST
   155                          ;
   156                          ;   Routine to delete a file pointed to by (DE).
   157                          ;
   158   0000ef 0e13            DELETE:	LD	C,19
   159   0000f1 c30500          	JP	ENTRY
   160                          ;
   161                          ;   Routine to call the bdos and set the zero flag if a zero
   162                          ; status is returned.
   163                          ;
   164   0000f4 cd0500          ENTRY2:	CALL	ENTRY
   165   0000f7 b7              	OR	A		;set zero flag if appropriate.
   166   0000f8 c9              	RET
   167                          ;
   168                          ;   Routine to read the next record from a sequential file.
   169                          ; (DE) points to the FCB.
   170                          ;
   171   0000f9 0e14            RDREC:	LD	C,20
   172   0000fb c3f400          	JP	ENTRY2
   173                          ;
   174                          ;   Routine to read file at (FCB).
   175                          ;
   176   0000fe 11cd07          READFCB:LD	DE,FCB
   177   000101 c3f900          	JP	RDREC
   178                          ;
   179                          ;   Routine to write the next record of a sequential file.
   180                          ; (DE) points to the FCB.
   181                          ;
   182   000104 0e15            WRTREC:	LD	C,21
   183   000106 c3f400          	JP	ENTRY2
   184                          ;
   185                          ;   Routine to create the file pointed to by (DE).
   186                          ;
   187   000109 0e16            CREATE:	LD	C,22
   188   00010b c3c300          	JP	ENTRY1
   189                          ;
   190                          ;   Routine to rename the file pointed to by (DE). Note that
   191                          ; the new name starts at (DE+16).
   192                          ;
   193   00010e 0e17            RENAM:	LD	C,23
   194   000110 c30500          	JP	ENTRY
   195                          ;
   196                          ;   Get the current user code.
   197                          ;
   198   000113 1eff            GETUSR:	LD	E,0FFH
   199                          ;
   200                          ;   Routne to get or set the current user code.
   201                          ; If (E) is FF then this is a GET, else it is a SET.
   202                          ;
   203   000115 0e20            GETSETUC: LD	C,32
   204   000117 c30500          	JP	ENTRY
   205                          ;
   206                          ;   Routine to set the current drive byte at (TDRIVE).
   207                          ;
   208   00011a cd1301          SETCDRV:CALL	GETUSR		;get user number
   209   00011d 87              	ADD	A,A		;and shift into the upper 4 bits.
   210   00011e 87              	ADD	A,A
   211   00011f 87              	ADD	A,A
   212   000120 87              	ADD	A,A
   213   000121 21ef07          	LD	HL,CDRIVE	;now add in the current drive number.
   214   000124 b6              	OR	(HL)
   215   000125 320400          	LD	(TDRIVE),A	;and save.
   216   000128 c9              	RET
   217                          ;
   218                          ;   Move currently active drive down to (TDRIVE).
   219                          ;
   220   000129 3aef07          MOVECD:	LD	A,(CDRIVE)
   221   00012c 320400          	LD	(TDRIVE),A
   222   00012f c9              	RET
   223                          ;
   224                          ;   Routine to convert (A) into upper case ascii. Only letters
   225                          ; are affected.
   226                          ;
   227   000130 fe61            UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
   228   000132 d8              	RET	C
   229   000133 fe7b            	CP	'{'
   230   000135 d0              	RET	NC
   231   000136 e65f            	AND	5FH		;convert it if found.
   232   000138 c9              	RET
   233                          ;
   234                          ;   Routine to get a line of input. We must check to see if the
   235                          ; user is in (BATCH) mode. If so, then read the input from file
   236                          ; ($$$.SUB). At the end, reset to console input.
   237                          ;
   238   000139 3aab07          GETINP:	LD	A,(BATCH)	;if =0, then use console input.
   239   00013c b7              	OR	A
   240   00013d ca9601          	JP	Z,GETINP1
   241                          ;
   242                          ;   Use the submit file ($$$.sub) which is prepared by a
   243                          ; SUBMIT run. It must be on drive (A) and it will be deleted
   244                          ; if and error occures (like eof).
   245                          ;
   246   000140 3aef07          	LD	A,(CDRIVE)	;select drive 0 if need be.
   247   000143 b7              	OR	A
   248   000144 3e00            	LD	A,0		;always use drive A for submit.
   249   000146 c4bd00          	CALL	NZ,DSKSEL	;select it if required.
   250   000149 11ac07          	LD	DE,BATCHFCB
   251   00014c cdcb00          	CALL	OPEN		;look for it.
   252   00014f ca9601          	JP	Z,GETINP1	;if not there, use normal input.
   253   000152 3abb07          	LD	A,(BATCHFCB+15)	;get last record number+1.
   254   000155 3d              	DEC	A
   255   000156 32cc07          	LD	(BATCHFCB+32),A
   256   000159 11ac07          	LD	DE,BATCHFCB
   257   00015c cdf900          	CALL	RDREC		;read last record.
   258   00015f c29601          	JP	NZ,GETINP1	;quit on end of file.
   259                          ;
   260                          ;   Move this record into input buffer.
   261                          ;
   262   000162 110700          	LD	DE,INBUFF+1
   263   000165 218000          	LD	HL,TBUFF	;data was read into buffer here.
   264   000168 0680            	LD	B,128		;all 128 characters may be used.
   265   00016a cd4204          	CALL	HL2DE		;(HL) to (DE), (B) bytes.
   266   00016d 21ba07          	LD	HL,BATCHFCB+14
   267   000170 3600            	LD	(HL),0		;zero out the 's2' byte.
   268   000172 23              	INC	HL		;and decrement the record count.
   269   000173 35              	DEC	(HL)
   270   000174 11ac07          	LD	DE,BATCHFCB	;close the batch file now.
   271   000177 cdda00          	CALL	CLOSE
   272   00017a ca9601          	JP	Z,GETINP1	;quit on an error.
   273   00017d 3aef07          	LD	A,(CDRIVE)	;re-select previous drive if need be.
   274   000180 b7              	OR	A
   275   000181 c4bd00          	CALL	NZ,DSKSEL	;don't do needless selects.
   276                          ;
   277                          ;   Print line just read on console.
   278                          ;
   279   000184 210800          	LD	HL,INBUFF+2
   280   000187 cdac00          	CALL	PLINE2
   281   00018a cdc201          	CALL	CHKCON		;check console, quit on a key.
   282   00018d caa701          	JP	Z,GETINP2	;jump if no key is pressed.
   283                          ;
   284                          ;   Terminate the submit job on any keyboard input. Delete this
   285                          ; file such that it is not re-started and jump to normal keyboard
   286                          ; input section.
   287                          ;
   288   000190 cddd01          	CALL	DELBATCH	;delete the batch file.
   289   000193 c38203          	JP	CMMND1		;and restart command input.
   290                          ;
   291                          ;   Get here for normal keyboard input. Delete the submit file
   292                          ; incase there was one.
   293                          ;
   294   000196 cddd01          GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
   295   000199 cd1a01          	CALL	SETCDRV		;reset active disk.
   296   00019c 0e0a            	LD	C,10		;get line from console device.
   297   00019e 110600          	LD	DE,INBUFF
   298   0001a1 cd0500          	CALL	ENTRY
   299   0001a4 cd2901          	CALL	MOVECD		;reset current drive (again).
   300                          ;
   301                          ;   Convert input line to upper case.
   302                          ;
   303   0001a7 210700          GETINP2:LD	HL,INBUFF+1
   304   0001aa 46              	LD	B,(HL)		;(B)=character counter.
   305   0001ab 23              GETINP3:INC	HL
   306   0001ac 78              	LD	A,B		;end of the line?
   307   0001ad b7              	OR	A
   308   0001ae caba01          	JP	Z,GETINP4
   309   0001b1 7e              	LD	A,(HL)		;convert to upper case.
   310   0001b2 cd3001          	CALL	UPPER
   311   0001b5 77              	LD	(HL),A
   312   0001b6 05              	DEC	B		;adjust character count.
   313   0001b7 c3ab01          	JP	GETINP3
   314   0001ba 77              GETINP4:LD	(HL),A		;add trailing null.
   315   0001bb 210800          	LD	HL,INBUFF+2
   316   0001be 228800          	LD	(INPOINT),HL	;reset input line pointer.
   317   0001c1 c9              	RET
   318                          ;
   319                          ;   Routine to check the console for a key pressed. The zero
   320                          ; flag is set is none, else the character is returned in (A).
   321                          ;
   322   0001c2 0e0b            CHKCON:	LD	C,11		;check console.
   323   0001c4 cd0500          	CALL	ENTRY
   324   0001c7 b7              	OR	A
   325   0001c8 c8              	RET	Z		;return if nothing.
   326   0001c9 0e01            	LD	C,1		;else get character.
   327   0001cb cd0500          	CALL	ENTRY
   328   0001ce b7              	OR	A		;clear zero flag and return.
   329   0001cf c9              	RET
   330                          ;
   331                          ;   Routine to get the currently active drive number.
   332                          ;
   333   0001d0 0e19            GETDSK:	LD	C,25
   334   0001d2 c30500          	JP	ENTRY
   335                          ;
   336                          ;   Set the stabdard dma address.
   337                          ;
   338   0001d5 118000          STDDMA:	LD	DE,TBUFF
   339                          ;
   340                          ;   Routine to set the dma address to (DE).
   341                          ;
   342   0001d8 0e1a            DMASET:	LD	C,26
   343   0001da c30500          	JP	ENTRY
   344                          ;
   345                          ;  Delete the batch file created by SUBMIT.
   346                          ;
   347   0001dd 21ab07          DELBATCH: LD	HL,BATCH	;is batch active?
   348   0001e0 7e              	LD	A,(HL)
   349   0001e1 b7              	OR	A
   350   0001e2 c8              	RET	Z
   351   0001e3 3600            	LD	(HL),0		;yes, de-activate it.
   352   0001e5 af              	XOR	A
   353   0001e6 cdbd00          	CALL	DSKSEL		;select drive 0 for sure.
   354   0001e9 11ac07          	LD	DE,BATCHFCB	;and delete this file.
   355   0001ec cdef00          	CALL	DELETE
   356   0001ef 3aef07          	LD	A,(CDRIVE)	;reset current drive.
   357   0001f2 c3bd00          	JP	DSKSEL
   358                          ;
   359                          ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
   360                          ; the same or we halt....
   361                          ;
   362   0001f5 112803          VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
   363   0001f8 210008          	LD	HL,PATTRN2	;ditto, but how could they be different?
   364   0001fb 0606            	LD	B,6		;6 bytes each.
   365   0001fd 1a              VERIFY1:LD	A,(DE)
   366   0001fe be              	CP	(HL)
   367   0001ff c2cf03          	JP	NZ,HALT		;jump to halt routine.
   368   000202 13              	INC	DE
   369   000203 23              	INC	HL
   370   000204 05              	DEC	B
   371   000205 c2fd01          	JP	NZ,VERIFY1
   372   000208 c9              	RET
   373                          ;
   374                          ;   Print back file name with a '?' to indicate a syntax error.
   375                          ;
   376   000209 cd9800          SYNERR:	CALL	CRLF		;end current line.
   377   00020c 2a8a00          	LD	HL,(NAMEPNT)	;this points to name in error.
   378   00020f 7e              SYNERR1:LD	A,(HL)		;print it until a space or null is found.
   379   000210 fe20            	CP	' '
   380   000212 ca2202          	JP	Z,SYNERR2
   381   000215 b7              	OR	A
   382   000216 ca2202          	JP	Z,SYNERR2
   383   000219 e5              	PUSH	HL
   384   00021a cd8c00          	CALL	PRINT
   385   00021d e1              	POP	HL
   386   00021e 23              	INC	HL
   387   00021f c30f02          	JP	SYNERR1
   388   000222 3e3f            SYNERR2:LD	A,'?'		;add trailing '?'.
   389   000224 cd8c00          	CALL	PRINT
   390   000227 cd9800          	CALL	CRLF
   391   00022a cddd01          	CALL	DELBATCH	;delete any batch file.
   392   00022d c38203          	JP	CMMND1		;and restart from console input.
   393                          ;
   394                          ;   Check character at (DE) for legal command input. Note that the
   395                          ; zero flag is set if the character is a delimiter.
   396                          ;
   397   000230 1a              CHECK:	LD	A,(DE)
   398   000231 b7              	OR	A
   399   000232 c8              	RET	Z
   400   000233 fe20            	CP	' '		;control characters are not legal here.
   401   000235 da0902          	JP	C,SYNERR
   402   000238 c8              	RET	Z		;check for valid delimiter.
   403   000239 fe3d            	CP	'='
   404   00023b c8              	RET	Z
   405   00023c fe5f            	CP	'_'
   406   00023e c8              	RET	Z
   407   00023f fe2e            	CP	'.'
   408   000241 c8              	RET	Z
   409   000242 fe3a            	CP	':'
   410   000244 c8              	RET	Z
   411   000245 fe3b            	CP	';'
   412   000247 c8              	RET	Z
   413   000248 fe3c            	CP	'<'
   414   00024a c8              	RET	Z
   415   00024b fe3e            	CP	'>'
   416   00024d c8              	RET	Z
   417   00024e c9              	RET
   418                          ;
   419                          ;   Get the next non-blank character from (DE).
   420                          ;
   421   00024f 1a              NONBLANK: LD	A,(DE)
   422   000250 b7              	OR	A		;string ends with a null.
   423   000251 c8              	RET	Z
   424   000252 fe20            	CP	' '
   425   000254 c0              	RET	NZ
   426   000255 13              	INC	DE
   427   000256 c34f02          	JP	NONBLANK
   428                          ;
   429                          ;   Add (HL)=(HL)+(A)
   430                          ;
   431   000259 85              ADDHL:	ADD	A,L
   432   00025a 6f              	LD	L,A
   433   00025b d0              	RET	NC		;take care of any carry.
   434   00025c 24              	INC	H
   435   00025d c9              	RET
   436                          ;
   437                          ;   Convert the first name in (FCB).
   438                          ;
   439   00025e 3e00            CONVFST:LD	A,0
   440                          ;
   441                          ;   Format a file name (convert * to '?', etc.). On return,
   442                          ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
   443                          ; the position within the fcb for the name (either 0 or 16).
   444                          ;
   445   000260 21cd07          CONVERT:LD	HL,FCB
   446   000263 cd5902          	CALL	ADDHL
   447   000266 e5              	PUSH	HL
   448   000267 e5              	PUSH	HL
   449   000268 af              	XOR	A
   450   000269 32f007          	LD	(CHGDRV),A	;initialize drive change flag.
   451   00026c 2a8800          	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
   452   00026f eb              	EX	DE,HL
   453   000270 cd4f02          	CALL	NONBLANK	;get next non-blank character.
   454   000273 eb              	EX	DE,HL
   455   000274 228a00          	LD	(NAMEPNT),HL	;save pointer here for any error message.
   456   000277 eb              	EX	DE,HL
   457   000278 e1              	POP	HL
   458   000279 1a              	LD	A,(DE)		;get first character.
   459   00027a b7              	OR	A
   460   00027b ca8902          	JP	Z,CONVRT1
   461   00027e de40            	SBC	A,'A'-1		;might be a drive name, convert to binary.
   462   000280 47              	LD	B,A		;and save.
   463   000281 13              	INC	DE		;check next character for a ':'.
   464   000282 1a              	LD	A,(DE)
   465   000283 fe3a            	CP	':'
   466   000285 ca9002          	JP	Z,CONVRT2
   467   000288 1b              	DEC	DE		;nope, move pointer back to the start of the line.
   468   000289 3aef07          CONVRT1:LD	A,(CDRIVE)
   469   00028c 77              	LD	(HL),A
   470   00028d c39602          	JP	CONVRT3
   471   000290 78              CONVRT2:LD	A,B
   472   000291 32f007          	LD	(CHGDRV),A	;set change in drives flag.
   473   000294 70              	LD	(HL),B
   474   000295 13              	INC	DE
   475                          ;
   476                          ;   Convert the basic file name.
   477                          ;
   478   000296 0608            CONVRT3:LD	B,08H
   479   000298 cd3002          CONVRT4:CALL	CHECK
   480   00029b cab902          	JP	Z,CONVRT8
   481   00029e 23              	INC	HL
   482   00029f fe2a            	CP	'*'		;note that an '*' will fill the remaining
   483   0002a1 c2a902          	JP	NZ,CONVRT5	;field with '?'.
   484   0002a4 363f            	LD	(HL),'?'
   485   0002a6 c3ab02          	JP	CONVRT6
   486   0002a9 77              CONVRT5:LD	(HL),A
   487   0002aa 13              	INC	DE
   488   0002ab 05              CONVRT6:DEC	B
   489   0002ac c29802          	JP	NZ,CONVRT4
   490   0002af cd3002          CONVRT7:CALL	CHECK		;get next delimiter.
   491   0002b2 cac002          	JP	Z,GETEXT
   492   0002b5 13              	INC	DE
   493   0002b6 c3af02          	JP	CONVRT7
   494   0002b9 23              CONVRT8:INC	HL		;blank fill the file name.
   495   0002ba 3620            	LD	(HL),' '
   496   0002bc 05              	DEC	B
   497   0002bd c2b902          	JP	NZ,CONVRT8
   498                          ;
   499                          ;   Get the extension and convert it.
   500                          ;
   501   0002c0 0603            GETEXT:	LD	B,03H
   502   0002c2 fe2e            	CP	'.'
   503   0002c4 c2e902          	JP	NZ,GETEXT5
   504   0002c7 13              	INC	DE
   505   0002c8 cd3002          GETEXT1:CALL	CHECK
   506   0002cb cae902          	JP	Z,GETEXT5
   507   0002ce 23              	INC	HL
   508   0002cf fe2a            	CP	'*'
   509   0002d1 c2d902          	JP	NZ,GETEXT2
   510   0002d4 363f            	LD	(HL),'?'
   511   0002d6 c3db02          	JP	GETEXT3
   512   0002d9 77              GETEXT2:LD	(HL),A
   513   0002da 13              	INC	DE
   514   0002db 05              GETEXT3:DEC	B
   515   0002dc c2c802          	JP	NZ,GETEXT1
   516   0002df cd3002          GETEXT4:CALL	CHECK
   517   0002e2 caf002          	JP	Z,GETEXT6
   518   0002e5 13              	INC	DE
   519   0002e6 c3df02          	JP	GETEXT4
   520   0002e9 23              GETEXT5:INC	HL
   521   0002ea 3620            	LD	(HL),' '
   522   0002ec 05              	DEC	B
   523   0002ed c2e902          	JP	NZ,GETEXT5
   524   0002f0 0603            GETEXT6:LD	B,3
   525   0002f2 23              GETEXT7:INC	HL
   526   0002f3 3600            	LD	(HL),0
   527   0002f5 05              	DEC	B
   528   0002f6 c2f202          	JP	NZ,GETEXT7
   529   0002f9 eb              	EX	DE,HL
   530   0002fa 228800          	LD	(INPOINT),HL	;save input line pointer.
   531   0002fd e1              	POP	HL
   532                          ;
   533                          ;   Check to see if this is an ambigeous file name specification.
   534                          ; Set the (A) register to non zero if it is.
   535                          ;
   536   0002fe 010b00          	LD	BC,11		;set name length.
   537   000301 23              GETEXT8:INC	HL
   538   000302 7e              	LD	A,(HL)
   539   000303 fe3f            	CP	'?'		;any question marks?
   540   000305 c20903          	JP	NZ,GETEXT9
   541   000308 04              	INC	B		;count them.
   542   000309 0d              GETEXT9:DEC	C
   543   00030a c20103          	JP	NZ,GETEXT8
   544   00030d 78              	LD	A,B
   545   00030e b7              	OR	A
   546   00030f c9              	RET
   547                          ;
   548                          ;   CP/M command table. Note commands can be either 3 or 4 characters long.
   549                          ;
   550                          NUMCMDS EQU	6		;number of commands
   551   000310 44495220        CMDTBL:	DB	"DIR "
   552   000314 45524120        	DB	"ERA "
   553   000318 54595045        	DB	"TYPE"
   554   00031c 53415645        	DB	"SAVE"
   555   000320 52454e20        	DB	"REN "
   556   000324 55534552        	DB	"USER"
   557                          ;
   558                          ;   The following six bytes must agree with those at (PATTRN2)
   559                          ; or cp/m will HALT. Why?
   560                          ;
   561   000328 001600000000    PATTRN1:DB	0,22,0,0,0,0	;(* serial number bytes *).
   562                          ;
   563                          ;   Search the command table for a match with what has just
   564                          ; been entered. If a match is found, then we jump to the
   565                          ; proper section. Else jump to (UNKNOWN).
   566                          ; On return, the (C) register is set to the command number
   567                          ; that matched (or NUMCMDS+1 if no match).
   568                          ;
   569   00032e 211003          SEARCH:	LD	HL,CMDTBL
   570   000331 0e00            	LD	C,0
   571   000333 79              SEARCH1:LD	A,C
   572   000334 fe06            	CP	NUMCMDS		;this commands exists.
   573   000336 d0              	RET	NC
   574   000337 11ce07          	LD	DE,FCB+1	;check this one.
   575   00033a 0604            	LD	B,4		;max command length.
   576   00033c 1a              SEARCH2:LD	A,(DE)
   577   00033d be              	CP	(HL)
   578   00033e c24f03          	JP	NZ,SEARCH3	;not a match.
   579   000341 13              	INC	DE
   580   000342 23              	INC	HL
   581   000343 05              	DEC	B
   582   000344 c23c03          	JP	NZ,SEARCH2
   583   000347 1a              	LD	A,(DE)		;allow a 3 character command to match.
   584   000348 fe20            	CP	' '
   585   00034a c25403          	JP	NZ,SEARCH4
   586   00034d 79              	LD	A,C		;set return register for this command.
   587   00034e c9              	RET
   588   00034f 23              SEARCH3:INC	HL
   589   000350 05              	DEC	B
   590   000351 c24f03          	JP	NZ,SEARCH3
   591   000354 0c              SEARCH4:INC	C
   592   000355 c33303          	JP	SEARCH1
   593                          ;
   594                          ;   Set the input buffer to empty and then start the command
   595                          ; processor (ccp).
   596                          ;
   597   000358 af              CLEARBUF: XOR	A
   598   000359 320700          	LD	(INBUFF+1),A	;second byte is actual length.
   599                          ;
   600                          ;**************************************************************
   601                          ;*
   602                          ;*
   603                          ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
   604                          ;*
   605                          ;**************************************************************
   606                          ;*
   607   00035c 31ab07          COMMAND:LD	SP,CCPSTACK	;setup stack area.
   608   00035f c5              	PUSH	BC		;note that (C) should be equal to:
   609   000360 79              	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
   610   000361 1f              	RRA			;and 'dddd' is the drive number.
   611   000362 1f              	RRA
   612   000363 1f              	RRA
   613   000364 1f              	RRA
   614   000365 e60f            	AND	0FH		;isolate the user number.
   615   000367 5f              	LD	E,A
   616   000368 cd1501          	CALL	GETSETUC	;and set it.
   617   00036b cdb800          	CALL	RESDSK		;reset the disk system.
   618   00036e 32ab07          	LD	(BATCH),A	;clear batch mode flag.
   619   000371 c1              	POP	BC
   620   000372 79              	LD	A,C
   621   000373 e60f            	AND	0FH		;isolate the drive number.
   622   000375 32ef07          	LD	(CDRIVE),A	;and save.
   623   000378 cdbd00          	CALL	DSKSEL		;...and select.
   624   00037b 3a0700          	LD	A,(INBUFF+1)
   625   00037e b7              	OR	A		;anything in input buffer already?
   626   00037f c29803          	JP	NZ,CMMND2	;yes, we just process it.
   627                          ;
   628                          ;   Entry point to get a command line from the console.
   629                          ;
   630   000382 31ab07          CMMND1:	LD	SP,CCPSTACK	;set stack straight.
   631   000385 cd9800          	CALL	CRLF		;start a new line on the screen.
   632   000388 cdd001          	CALL	GETDSK		;get current drive.
   633   00038b c661            	ADD	A,'a'
   634   00038d cd8c00          	CALL	PRINT		;print current drive.
   635   000390 3e3e            	LD	A,'>'
   636   000392 cd8c00          	CALL	PRINT		;and add prompt.
   637   000395 cd3901          	CALL	GETINP		;get line from user.
   638                          ;
   639                          ;   Process command line here.
   640                          ;
   641   000398 118000          CMMND2:	LD	DE,TBUFF
   642   00039b cdd801          	CALL	DMASET		;set standard dma address.
   643   00039e cdd001          	CALL	GETDSK
   644   0003a1 32ef07          	LD	(CDRIVE),A	;set current drive.
   645   0003a4 cd5e02          	CALL	CONVFST		;convert name typed in.
   646   0003a7 c40902          	CALL	NZ,SYNERR	;wild cards are not allowed.
   647   0003aa 3af007          	LD	A,(CHGDRV)	;if a change in drives was indicated,
   648   0003ad b7              	OR	A		;then treat this as an unknown command
   649   0003ae c2a506          	JP	NZ,UNKNOWN	;which gets executed.
   650   0003b1 cd2e03          	CALL	SEARCH		;else search command table for a match.
   651                          ;
   652                          ;   Note that an unknown command returns
   653                          ; with (A) pointing to the last address
   654                          ; in our table which is (UNKNOWN).
   655                          ;
   656   0003b4 21c103          	LD	HL,CMDADR	;now, look thru our address table for command (A).
   657   0003b7 5f              	LD	E,A		;set (DE) to command number.
   658   0003b8 1600            	LD	D,0
   659   0003ba 19              	ADD	HL,DE
   660   0003bb 19              	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
   661   0003bc 7e              	LD	A,(HL)		;now pick out this address.
   662   0003bd 23              	INC	HL
   663   0003be 66              	LD	H,(HL)
   664   0003bf 6f              	LD	L,A
   665   0003c0 e9              	JP	(HL)		;now execute it.
   666                          ;
   667                          ;   CP/M command address table.
   668                          ;
   669   0003c1 77041f055d05ad05CMDADR:	DW	DIRECT,ERASE,TYPE,SAVE
   670   0003c9 10068e06a506    	DW	RENAME,USER,UNKNOWN
   671                          ;
   672                          ;   Halt the system. Reason for this is unknown at present.
   673                          ;
   674   0003cf 21f376          HALT:	LD	HL,76F3H	;'DI HLT' instructions.
   675   0003d2 220000          	LD	(CBASE),HL
   676   0003d5 210000          	LD	HL,CBASE
   677   0003d8 e9              	JP	(HL)
   678                          ;
   679                          ;   Read error while TYPEing a file.
   680                          ;
   681   0003d9 01df03          RDERROR:LD	BC,RDERR
   682   0003dc c3a700          	JP	PLINE
   683   0003df 5265616420657272RDERR:	DB	"Read error",0
                6f7200          
   684                          ;
   685                          ;   Required file was not located.
   686                          ;
   687   0003ea 01f003          NONE:	LD	BC,NOFILE
   688   0003ed c3a700          	JP	PLINE
   689   0003f0 4e6f2066696c6500NOFILE:	DB	"No file",0
   690                          ;
   691                          ;   Decode a command of the form 'A>filename number{ filename}.
   692                          ; Note that a drive specifier is not allowed on the first file
   693                          ; name. On return, the number is in register (A). Any error
   694                          ; causes 'filename?' to be printed and the command is aborted.
   695                          ;
   696   0003f8 cd5e02          DECODE:	CALL	CONVFST		;convert filename.
   697   0003fb 3af007          	LD	A,(CHGDRV)	;do not allow a drive to be specified.
   698   0003fe b7              	OR	A
   699   0003ff c20902          	JP	NZ,SYNERR
   700   000402 21ce07          	LD	HL,FCB+1	;convert number now.
   701   000405 010b00          	LD	BC,11		;(B)=sum register, (C)=max digit count.
   702   000408 7e              DECODE1:LD	A,(HL)
   703   000409 fe20            	CP	' '		;a space terminates the numeral.
   704   00040b ca3304          	JP	Z,DECODE3
   705   00040e 23              	INC	HL
   706   00040f d630            	SUB	'0'		;make binary from ascii.
   707   000411 fe0a            	CP	10		;legal digit?
   708   000413 d20902          	JP	NC,SYNERR
   709   000416 57              	LD	D,A		;yes, save it in (D).
   710   000417 78              	LD	A,B		;compute (B)=(B)*10 and check for overflow.
   711   000418 e6e0            	AND	0E0H
   712   00041a c20902          	JP	NZ,SYNERR
   713   00041d 78              	LD	A,B
   714   00041e 07              	RLCA
   715   00041f 07              	RLCA
   716   000420 07              	RLCA			;(A)=(B)*8
   717   000421 80              	ADD	A,B		;.......*9
   718   000422 da0902          	JP	C,SYNERR
   719   000425 80              	ADD	A,B		;.......*10
   720   000426 da0902          	JP	C,SYNERR
   721   000429 82              	ADD	A,D		;add in new digit now.
   722   00042a da0902          DECODE2:JP	C,SYNERR
   723   00042d 47              	LD	B,A		;and save result.
   724   00042e 0d              	DEC	C		;only look at 11 digits.
   725   00042f c20804          	JP	NZ,DECODE1
   726   000432 c9              	RET
   727   000433 7e              DECODE3:LD	A,(HL)		;spaces must follow (why?).
   728   000434 fe20            	CP	' '
   729   000436 c20902          	JP	NZ,SYNERR
   730   000439 23              	INC	HL
   731   00043a 0d              DECODE4:DEC	C
   732   00043b c23304          	JP	NZ,DECODE3
   733   00043e 78              	LD	A,B		;set (A)=the numeric value entered.
   734   00043f c9              	RET
   735                          ;
   736                          ;   Move 3 bytes from (HL) to (DE). Note that there is only
   737                          ; one reference to this at (A2D5h).
   738                          ;
   739   000440 0603            MOVE3:	LD	B,3
   740                          ;
   741                          ;   Move (B) bytes from (HL) to (DE).
   742                          ;
   743   000442 7e              HL2DE:	LD	A,(HL)
   744   000443 12              	LD	(DE),A
   745   000444 23              	INC	HL
   746   000445 13              	INC	DE
   747   000446 05              	DEC	B
   748   000447 c24204          	JP	NZ,HL2DE
   749   00044a c9              	RET
   750                          ;
   751                          ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
   752                          ;
   753   00044b 218000          EXTRACT:LD	HL,TBUFF
   754   00044e 81              	ADD	A,C
   755   00044f cd5902          	CALL	ADDHL
   756   000452 7e              	LD	A,(HL)
   757   000453 c9              	RET
   758                          ;
   759                          ;  Check drive specified. If it means a change, then the new
   760                          ; drive will be selected. In any case, the drive byte of the
   761                          ; fcb will be set to null (means use current drive).
   762                          ;
   763   000454 af              DSELECT:XOR	A		;null out first byte of fcb.
   764   000455 32cd07          	LD	(FCB),A
   765   000458 3af007          	LD	A,(CHGDRV)	;a drive change indicated?
   766   00045b b7              	OR	A
   767   00045c c8              	RET	Z
   768   00045d 3d              	DEC	A		;yes, is it the same as the current drive?
   769   00045e 21ef07          	LD	HL,CDRIVE
   770   000461 be              	CP	(HL)
   771   000462 c8              	RET	Z
   772   000463 c3bd00          	JP	DSKSEL		;no. Select it then.
   773                          ;
   774                          ;   Check the drive selection and reset it to the previous
   775                          ; drive if it was changed for the preceeding command.
   776                          ;
   777   000466 3af007          RESETDR:LD	A,(CHGDRV)	;drive change indicated?
   778   000469 b7              	OR	A
   779   00046a c8              	RET	Z
   780   00046b 3d              	DEC	A		;yes, was it a different drive?
   781   00046c 21ef07          	LD	HL,CDRIVE
   782   00046f be              	CP	(HL)
   783   000470 c8              	RET	Z
   784   000471 3aef07          	LD	A,(CDRIVE)	;yes, re-select our old drive.
   785   000474 c3bd00          	JP	DSKSEL
   786                          ;
   787                          ;**************************************************************
   788                          ;*
   789                          ;*           D I R E C T O R Y   C O M M A N D
   790                          ;*
   791                          ;**************************************************************
   792                          ;
   793   000477 cd5e02          DIRECT:	CALL	CONVFST		;convert file name.
   794   00047a cd5404          	CALL	DSELECT		;select indicated drive.
   795   00047d 21ce07          	LD	HL,FCB+1	;was any file indicated?
   796   000480 7e              	LD	A,(HL)
   797   000481 fe20            	CP	' '
   798   000483 c28f04          	JP	NZ,DIRECT2
   799   000486 060b            	LD	B,11		;no. Fill field with '?' - same as *.*.
   800   000488 363f            DIRECT1:LD	(HL),'?'
   801   00048a 23              	INC	HL
   802   00048b 05              	DEC	B
   803   00048c c28804          	JP	NZ,DIRECT1
   804   00048f 1e00            DIRECT2:LD	E,0		;set initial cursor position.
   805   000491 d5              	PUSH	DE
   806   000492 cde900          	CALL	SRCHFCB		;get first file name.
   807   000495 ccea03          	CALL	Z,NONE		;none found at all?
   808   000498 ca1b05          DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
   809   00049b 3aee07          	LD	A,(RTNCODE)	;get file's position in segment (0-3).
   810   00049e 0f              	RRCA
   811   00049f 0f              	RRCA
   812   0004a0 0f              	RRCA
   813   0004a1 e660            	AND	60H		;(A)=position*32
   814   0004a3 4f              	LD	C,A
   815   0004a4 3e0a            	LD	A,10
   816   0004a6 cd4b04          	CALL	EXTRACT		;extract the tenth entry in fcb.
   817   0004a9 17              	RLA			;check system file status bit.
   818   0004aa da0f05          	JP	C,DIRECT8	;we don't list them.
   819   0004ad d1              	POP	DE
   820   0004ae 7b              	LD	A,E		;bump name count.
   821   0004af 1c              	INC	E
   822   0004b0 d5              	PUSH	DE
   823   0004b1 e603            	AND	03H		;at end of line?
   824   0004b3 f5              	PUSH	AF
   825   0004b4 c2cc04          	JP	NZ,DIRECT4
   826   0004b7 cd9800          	CALL	CRLF		;yes, end this line and start another.
   827   0004ba c5              	PUSH	BC
   828   0004bb cdd001          	CALL	GETDSK		;start line with ('A:').
   829   0004be c1              	POP	BC
   830   0004bf c641            	ADD	A,'A'
   831   0004c1 cd9200          	CALL	PRINTB
   832   0004c4 3e3a            	LD	A,':'
   833   0004c6 cd9200          	CALL	PRINTB
   834   0004c9 c3d404          	JP	DIRECT5
   835   0004cc cda200          DIRECT4:CALL	SPACE		;add seperator between file names.
   836   0004cf 3e3a            	LD	A,':'
   837   0004d1 cd9200          	CALL	PRINTB
   838   0004d4 cda200          DIRECT5:CALL	SPACE
   839   0004d7 0601            	LD	B,1		;'extract' each file name character at a time.
   840   0004d9 78              DIRECT6:LD	A,B
   841   0004da cd4b04          	CALL	EXTRACT
   842   0004dd e67f            	AND	7FH		;strip bit 7 (status bit).
   843   0004df fe20            	CP	' '		;are we at the end of the name?
   844   0004e1 c2f904          	JP	NZ,DRECT65
   845   0004e4 f1              	POP	AF		;yes, don't print spaces at the end of a line.
   846   0004e5 f5              	PUSH	AF
   847   0004e6 fe03            	CP	3
   848   0004e8 c2f704          	JP	NZ,DRECT63
   849   0004eb 3e09            	LD	A,9		;first check for no extension.
   850   0004ed cd4b04          	CALL	EXTRACT
   851   0004f0 e67f            	AND	7FH
   852   0004f2 fe20            	CP	' '
   853   0004f4 ca0e05          	JP	Z,DIRECT7	;don't print spaces.
   854   0004f7 3e20            DRECT63:LD	A,' '		;else print them.
   855   0004f9 cd9200          DRECT65:CALL	PRINTB
   856   0004fc 04              	INC	B		;bump to next character psoition.
   857   0004fd 78              	LD	A,B
   858   0004fe fe0c            	CP	12		;end of the name?
   859   000500 d20e05          	JP	NC,DIRECT7
   860   000503 fe09            	CP	9		;nope, starting extension?
   861   000505 c2d904          	JP	NZ,DIRECT6
   862   000508 cda200          	CALL	SPACE		;yes, add seperating space.
   863   00050b c3d904          	JP	DIRECT6
   864   00050e f1              DIRECT7:POP	AF		;get the next file name.
   865   00050f cdc201          DIRECT8:CALL	CHKCON		;first check console, quit on anything.
   866   000512 c21b05          	JP	NZ,DIRECT9
   867   000515 cde400          	CALL	SRCHNXT		;get next name.
   868   000518 c39804          	JP	DIRECT3		;and continue with our list.
   869   00051b d1              DIRECT9:POP	DE		;restore the stack and return to command level.
   870   00051c c38607          	JP	GETBACK
   871                          ;
   872                          ;**************************************************************
   873                          ;*
   874                          ;*                E R A S E   C O M M A N D
   875                          ;*
   876                          ;**************************************************************
   877                          ;
   878   00051f cd5e02          ERASE:	CALL	CONVFST		;convert file name.
   879   000522 fe0b            	CP	11		;was '*.*' entered?
   880   000524 c24205          	JP	NZ,ERASE1
   881   000527 015205          	LD	BC,YESNO	;yes, ask for confirmation.
   882   00052a cda700          	CALL	PLINE
   883   00052d cd3901          	CALL	GETINP
   884   000530 210700          	LD	HL,INBUFF+1
   885   000533 35              	DEC	(HL)		;must be exactly 'y'.
   886   000534 c28203          	JP	NZ,CMMND1
   887   000537 23              	INC	HL
   888   000538 7e              	LD	A,(HL)
   889   000539 fe59            	CP	'Y'
   890   00053b c28203          	JP	NZ,CMMND1
   891   00053e 23              	INC	HL
   892   00053f 228800          	LD	(INPOINT),HL	;save input line pointer.
   893   000542 cd5404          ERASE1:	CALL	DSELECT		;select desired disk.
   894   000545 11cd07          	LD	DE,FCB
   895   000548 cdef00          	CALL	DELETE		;delete the file.
   896   00054b 3c              	INC	A
   897   00054c ccea03          	CALL	Z,NONE		;not there?
   898   00054f c38607          	JP	GETBACK		;return to command level now.
   899   000552 416c6c2028792f6eYESNO:	DB	"All (y/n)?",0
                293f00          
   900                          ;
   901                          ;**************************************************************
   902                          ;*
   903                          ;*            T Y P E   C O M M A N D
   904                          ;*
   905                          ;**************************************************************
   906                          ;
   907   00055d cd5e02          TYPE:	CALL	CONVFST		;convert file name.
   908   000560 c20902          	JP	NZ,SYNERR	;wild cards not allowed.
   909   000563 cd5404          	CALL	DSELECT		;select indicated drive.
   910   000566 cdd000          	CALL	OPENFCB		;open the file.
   911   000569 caa705          	JP	Z,TYPE5		;not there?
   912   00056c cd9800          	CALL	CRLF		;ok, start a new line on the screen.
   913   00056f 21f107          	LD	HL,NBYTES	;initialize byte counter.
   914   000572 36ff            	LD	(HL),0FFH	;set to read first sector.
   915   000574 21f107          TYPE1:	LD	HL,NBYTES
   916   000577 7e              TYPE2:	LD	A,(HL)		;have we written the entire sector?
   917   000578 fe80            	CP	128
   918   00057a da8705          	JP	C,TYPE3
   919   00057d e5              	PUSH	HL		;yes, read in the next one.
   920   00057e cdfe00          	CALL	READFCB
   921   000581 e1              	POP	HL
   922   000582 c2a005          	JP	NZ,TYPE4	;end or error?
   923   000585 af              	XOR	A		;ok, clear byte counter.
   924   000586 77              	LD	(HL),A
   925   000587 34              TYPE3:	INC	(HL)		;count this byte.
   926   000588 218000          	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
   927   00058b cd5902          	CALL	ADDHL
   928   00058e 7e              	LD	A,(HL)
   929   00058f fe1a            	CP	CNTRLZ		;end of file mark?
   930   000591 ca8607          	JP	Z,GETBACK
   931   000594 cd8c00          	CALL	PRINT		;no, print it.
   932   000597 cdc201          	CALL	CHKCON		;check console, quit if anything ready.
   933   00059a c28607          	JP	NZ,GETBACK
   934   00059d c37405          	JP	TYPE1
   935                          ;
   936                          ;   Get here on an end of file or read error.
   937                          ;
   938   0005a0 3d              TYPE4:	DEC	A		;read error?
   939   0005a1 ca8607          	JP	Z,GETBACK
   940   0005a4 cdd903          	CALL	RDERROR		;yes, print message.
   941   0005a7 cd6604          TYPE5:	CALL	RESETDR		;and reset proper drive
   942   0005aa c30902          	JP	SYNERR		;now print file name with problem.
   943                          ;
   944                          ;**************************************************************
   945                          ;*
   946                          ;*            S A V E   C O M M A N D
   947                          ;*
   948                          ;**************************************************************
   949                          ;
   950   0005ad cdf803          SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
   951   0005b0 f5              	PUSH	AF		;save number of pages to write.
   952   0005b1 cd5e02          	CALL	CONVFST		;convert file name.
   953   0005b4 c20902          	JP	NZ,SYNERR	;wild cards not allowed.
   954   0005b7 cd5404          	CALL	DSELECT		;select specified drive.
   955   0005ba 11cd07          	LD	DE,FCB		;now delete this file.
   956   0005bd d5              	PUSH	DE
   957   0005be cdef00          	CALL	DELETE
   958   0005c1 d1              	POP	DE
   959   0005c2 cd0901          	CALL	CREATE		;and create it again.
   960   0005c5 cafb05          	JP	Z,SAVE3		;can't create?
   961   0005c8 af              	XOR	A		;clear record number byte.
   962   0005c9 32ed07          	LD	(FCB+32),A
   963   0005cc f1              	POP	AF		;convert pages to sectors.
   964   0005cd 6f              	LD	L,A
   965   0005ce 2600            	LD	H,0
   966   0005d0 29              	ADD	HL,HL		;(HL)=number of sectors to write.
   967   0005d1 110001          	LD	DE,TBASE	;and we start from here.
   968   0005d4 7c              SAVE1:	LD	A,H		;done yet?
   969   0005d5 b5              	OR	L
   970   0005d6 caf105          	JP	Z,SAVE2
   971   0005d9 2b              	DEC	HL		;nope, count this and compute the start
   972   0005da e5              	PUSH	HL		;of the next 128 byte sector.
   973   0005db 218000          	LD	HL,128
   974   0005de 19              	ADD	HL,DE
   975   0005df e5              	PUSH	HL		;save it and set the transfer address.
   976   0005e0 cdd801          	CALL	DMASET
   977   0005e3 11cd07          	LD	DE,FCB		;write out this sector now.
   978   0005e6 cd0401          	CALL	WRTREC
   979   0005e9 d1              	POP	DE		;reset (DE) to the start of the last sector.
   980   0005ea e1              	POP	HL		;restore sector count.
   981   0005eb c2fb05          	JP	NZ,SAVE3	;write error?
   982   0005ee c3d405          	JP	SAVE1
   983                          ;
   984                          ;   Get here after writing all of the file.
   985                          ;
   986   0005f1 11cd07          SAVE2:	LD	DE,FCB		;now close the file.
   987   0005f4 cdda00          	CALL	CLOSE
   988   0005f7 3c              	INC	A		;did it close ok?
   989   0005f8 c20106          	JP	NZ,SAVE4
   990                          ;
   991                          ;   Print out error message (no space).
   992                          ;
   993   0005fb 010706          SAVE3:	LD	BC,NOSPACE
   994   0005fe cda700          	CALL	PLINE
   995   000601 cdd501          SAVE4:	CALL	STDDMA		;reset the standard dma address.
   996   000604 c38607          	JP	GETBACK
   997   000607 4e6f207370616365NOSPACE:DB	"No space",0
                00              
   998                          ;
   999                          ;**************************************************************
  1000                          ;*
  1001                          ;*           R E N A M E   C O M M A N D
  1002                          ;*
  1003                          ;**************************************************************
  1004                          ;
  1005   000610 cd5e02          RENAME:	CALL	CONVFST		;convert first file name.
  1006   000613 c20902          	JP	NZ,SYNERR	;wild cards not allowed.
  1007   000616 3af007          	LD	A,(CHGDRV)	;remember any change in drives specified.
  1008   000619 f5              	PUSH	AF
  1009   00061a cd5404          	CALL	DSELECT		;and select this drive.
  1010   00061d cde900          	CALL	SRCHFCB		;is this file present?
  1011   000620 c27906          	JP	NZ,RENAME6	;yes, print error message.
  1012   000623 21cd07          	LD	HL,FCB		;yes, move this name into second slot.
  1013   000626 11dd07          	LD	DE,FCB+16
  1014   000629 0610            	LD	B,16
  1015   00062b cd4204          	CALL	HL2DE
  1016   00062e 2a8800          	LD	HL,(INPOINT)	;get input pointer.
  1017   000631 eb              	EX	DE,HL
  1018   000632 cd4f02          	CALL	NONBLANK	;get next non blank character.
  1019   000635 fe3d            	CP	'='		;only allow an '=' or '_' seperator.
  1020   000637 ca3f06          	JP	Z,RENAME1
  1021   00063a fe5f            	CP	'_'
  1022   00063c c27306          	JP	NZ,RENAME5
  1023   00063f eb              RENAME1:EX	DE,HL
  1024   000640 23              	INC	HL		;ok, skip seperator.
  1025   000641 228800          	LD	(INPOINT),HL	;save input line pointer.
  1026   000644 cd5e02          	CALL	CONVFST		;convert this second file name now.
  1027   000647 c27306          	JP	NZ,RENAME5	;again, no wild cards.
  1028   00064a f1              	POP	AF		;if a drive was specified, then it
  1029   00064b 47              	LD	B,A		;must be the same as before.
  1030   00064c 21f007          	LD	HL,CHGDRV
  1031   00064f 7e              	LD	A,(HL)
  1032   000650 b7              	OR	A
  1033   000651 ca5906          	JP	Z,RENAME2
  1034   000654 b8              	CP	B
  1035   000655 70              	LD	(HL),B
  1036   000656 c27306          	JP	NZ,RENAME5	;they were different, error.
  1037   000659 70              RENAME2:LD	(HL),B		;	reset as per the first file specification.
  1038   00065a af              	XOR	A
  1039   00065b 32cd07          	LD	(FCB),A		;clear the drive byte of the fcb.
  1040   00065e cde900          RENAME3:CALL	SRCHFCB		;and go look for second file.
  1041   000661 ca6d06          	JP	Z,RENAME4	;doesn't exist?
  1042   000664 11cd07          	LD	DE,FCB
  1043   000667 cd0e01          	CALL	RENAM		;ok, rename the file.
  1044   00066a c38607          	JP	GETBACK
  1045                          ;
  1046                          ;   Process rename errors here.
  1047                          ;
  1048   00066d cdea03          RENAME4:CALL	NONE		;file not there.
  1049   000670 c38607          	JP	GETBACK
  1050   000673 cd6604          RENAME5:CALL	RESETDR		;bad command format.
  1051   000676 c30902          	JP	SYNERR
  1052   000679 018206          RENAME6:LD	BC,EXISTS	;destination file already exists.
  1053   00067c cda700          	CALL	PLINE
  1054   00067f c38607          	JP	GETBACK
  1055   000682 46696c6520657869EXISTS:	DB	"File exists",0
                73747300        
  1056                          ;
  1057                          ;**************************************************************
  1058                          ;*
  1059                          ;*             U S E R   C O M M A N D
  1060                          ;*
  1061                          ;**************************************************************
  1062                          ;
  1063   00068e cdf803          USER:	CALL	DECODE		;get numeric value following command.
  1064   000691 fe10            	CP	16		;legal user number?
  1065   000693 d20902          	JP	NC,SYNERR
  1066   000696 5f              	LD	E,A		;yes but is there anything else?
  1067   000697 3ace07          	LD	A,(FCB+1)
  1068   00069a fe20            	CP	' '
  1069   00069c ca0902          	JP	Z,SYNERR	;yes, that is not allowed.
  1070   00069f cd1501          	CALL	GETSETUC	;ok, set user code.
  1071   0006a2 c38907          	JP	GETBACK1
  1072                          ;
  1073                          ;**************************************************************
  1074                          ;*
  1075                          ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
  1076                          ;*
  1077                          ;**************************************************************
  1078                          ;
  1079   0006a5 cdf501          UNKNOWN:CALL	VERIFY		;check for valid system (why?).
  1080   0006a8 3ace07          	LD	A,(FCB+1)	;anything to execute?
  1081   0006ab fe20            	CP	' '
  1082   0006ad c2c406          	JP	NZ,UNKWN1
  1083   0006b0 3af007          	LD	A,(CHGDRV)	;nope, only a drive change?
  1084   0006b3 b7              	OR	A
  1085   0006b4 ca8907          	JP	Z,GETBACK1	;neither???
  1086   0006b7 3d              	DEC	A
  1087   0006b8 32ef07          	LD	(CDRIVE),A	;ok, store new drive.
  1088   0006bb cd2901          	CALL	MOVECD		;set (TDRIVE) also.
  1089   0006be cdbd00          	CALL	DSKSEL		;and select this drive.
  1090   0006c1 c38907          	JP	GETBACK1	;then return.
  1091                          ;
  1092                          ;   Here a file name was typed. Prepare to execute it.
  1093                          ;
  1094   0006c4 11d607          UNKWN1:	LD	DE,FCB+9	;an extension specified?
  1095   0006c7 1a              	LD	A,(DE)
  1096   0006c8 fe20            	CP	' '
  1097   0006ca c20902          	JP	NZ,SYNERR	;yes, not allowed.
  1098   0006cd d5              UNKWN2:	PUSH	DE
  1099   0006ce cd5404          	CALL	DSELECT		;select specified drive.
  1100   0006d1 d1              	POP	DE
  1101   0006d2 218307          	LD	HL,COMFILE	;set the extension to 'COM'.
  1102   0006d5 cd4004          	CALL	MOVE3
  1103   0006d8 cdd000          	CALL	OPENFCB		;and open this file.
  1104   0006db ca6b07          	JP	Z,UNKWN9	;not present?
  1105                          ;
  1106                          ;   Load in the program.
  1107                          ;
  1108   0006de 210001          	LD	HL,TBASE	;store the program starting here.
  1109   0006e1 e5              UNKWN3:	PUSH	HL
  1110   0006e2 eb              	EX	DE,HL
  1111   0006e3 cdd801          	CALL	DMASET		;set transfer address.
  1112   0006e6 11cd07          	LD	DE,FCB		;and read the next record.
  1113   0006e9 cdf900          	CALL	RDREC
  1114   0006ec c20107          	JP	NZ,UNKWN4	;end of file or read error?
  1115   0006ef e1              	POP	HL		;nope, bump pointer for next sector.
  1116   0006f0 118000          	LD	DE,128
  1117   0006f3 19              	ADD	HL,DE
  1118   0006f4 110000          	LD	DE,CBASE	;enough room for the whole file?
  1119   0006f7 7d              	LD	A,L
  1120   0006f8 93              	SUB	E
  1121   0006f9 7c              	LD	A,H
  1122   0006fa 9a              	SBC	A,D
  1123   0006fb d27107          	JP	NC,UNKWN0	;no, it can't fit.
  1124   0006fe c3e106          	JP	UNKWN3
  1125                          ;
  1126                          ;   Get here after finished reading.
  1127                          ;
  1128   000701 e1              UNKWN4:	POP	HL
  1129   000702 3d              	DEC	A		;normal end of file?
  1130   000703 c27107          	JP	NZ,UNKWN0
  1131   000706 cd6604          	CALL	RESETDR		;yes, reset previous drive.
  1132   000709 cd5e02          	CALL	CONVFST		;convert the first file name that follows
  1133   00070c 21f007          	LD	HL,CHGDRV	;command name.
  1134   00070f e5              	PUSH	HL
  1135   000710 7e              	LD	A,(HL)		;set drive code in default fcb.
  1136   000711 32cd07          	LD	(FCB),A
  1137   000714 3e10            	LD	A,16		;put second name 16 bytes later.
  1138   000716 cd6002          	CALL	CONVERT		;convert second file name.
  1139   000719 e1              	POP	HL
  1140   00071a 7e              	LD	A,(HL)		;and set the drive for this second file.
  1141   00071b 32dd07          	LD	(FCB+16),A
  1142   00071e af              	XOR	A		;clear record byte in fcb.
  1143   00071f 32ed07          	LD	(FCB+32),A
  1144   000722 115c00          	LD	DE,TFCB		;move it into place at(005Ch).
  1145   000725 21cd07          	LD	HL,FCB
  1146   000728 0621            	LD	B,33
  1147   00072a cd4204          	CALL	HL2DE
  1148   00072d 210800          	LD	HL,INBUFF+2	;now move the remainder of the input
  1149   000730 7e              UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
  1150   000731 b7              	OR	A		;or a null.
  1151   000732 ca3e07          	JP	Z,UNKWN6
  1152   000735 fe20            	CP	' '
  1153   000737 ca3e07          	JP	Z,UNKWN6
  1154   00073a 23              	INC	HL
  1155   00073b c33007          	JP	UNKWN5
  1156                          ;
  1157                          ;   Do the line move now. It ends in a null byte.
  1158                          ;
  1159   00073e 0600            UNKWN6:	LD	B,0		;keep a character count.
  1160   000740 118100          	LD	DE,TBUFF+1	;data gets put here.
  1161   000743 7e              UNKWN7:	LD	A,(HL)		;move it now.
  1162   000744 12              	LD	(DE),A
  1163   000745 b7              	OR	A
  1164   000746 ca4f07          	JP	Z,UNKWN8
  1165   000749 04              	INC	B
  1166   00074a 23              	INC	HL
  1167   00074b 13              	INC	DE
  1168   00074c c34307          	JP	UNKWN7
  1169   00074f 78              UNKWN8:	LD	A,B		;now store the character count.
  1170   000750 328000          	LD	(TBUFF),A
  1171   000753 cd9800          	CALL	CRLF		;clean up the screen.
  1172   000756 cdd501          	CALL	STDDMA		;set standard transfer address.
  1173   000759 cd1a01          	CALL	SETCDRV		;reset current drive.
  1174   00075c cd0001          	CALL	TBASE		;and execute the program.
  1175                          ;
  1176                          ;   Transiant programs return here (or reboot).
  1177                          ;
  1178   00075f 31ab07          	LD	SP,BATCH	;set stack first off.
  1179   000762 cd2901          	CALL	MOVECD		;move current drive into place (TDRIVE).
  1180   000765 cdbd00          	CALL	DSKSEL		;and reselect it.
  1181   000768 c38203          	JP	CMMND1		;back to comand mode.
  1182                          ;
  1183                          ;   Get here if some error occured.
  1184                          ;
  1185   00076b cd6604          UNKWN9:	CALL	RESETDR		;inproper format.
  1186   00076e c30902          	JP	SYNERR
  1187   000771 017a07          UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
  1188   000774 cda700          	CALL	PLINE
  1189   000777 c38607          	JP	GETBACK
  1190   00077a 426164206c6f6164BADLOAD:DB	"Bad load",0
                00              
  1191   000783 434f4d          COMFILE:DB	"COM"		;command file extension.
  1192                          ;
  1193                          ;   Get here to return to command level. We will reset the
  1194                          ; previous active drive and then either return to command
  1195                          ; level directly or print error message and then return.
  1196                          ;
  1197   000786 cd6604          GETBACK:CALL	RESETDR		;reset previous drive.
  1198   000789 cd5e02          GETBACK1: CALL	CONVFST		;convert first name in (FCB).
  1199   00078c 3ace07          	LD	A,(FCB+1)	;if this was just a drive change request,
  1200   00078f d620            	SUB	' '		;make sure it was valid.
  1201   000791 21f007          	LD	HL,CHGDRV
  1202   000794 b6              	OR	(HL)
  1203   000795 c20902          	JP	NZ,SYNERR
  1204   000798 c38203          	JP	CMMND1		;ok, return to command level.
  1205                          ;
  1206                          ;   ccp stack area.
  1207                          ;
  1208   00079b 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
  1209                          CCPSTACK EQU	$	;end of ccp stack area.
  1210                          ;
  1211                          ;   Batch (or SUBMIT) processing information storage.
  1212                          ;
  1213   0007ab 00              BATCH:	DB	0		;batch mode flag (0=not active).
  1214   0007ac 0024242420202020BATCHFCB: DB	0,"$$$     SUB",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                2053554200000000
                0000000000000000
                0000000000000000
                00              
  1215                          ;
  1216                          ;   File control block setup by the CCP.
  1217                          ;
  1218   0007cd 0020202020202020FCB:	DB	0,"           ",0,0,0,0,0,"           ",0,0,0,0,0
                2020202000000000
                0020202020202020
                2020202000000000
                00              
  1219   0007ee 00              RTNCODE:DB	0		;status returned from bdos call.
  1220   0007ef 00              CDRIVE:	DB	0		;currently active drive.
  1221   0007f0 00              CHGDRV:	DB	0		;change in drives flag (0=no change).
  1222   0007f1 0000            NBYTES:	DW	0		;byte counter used by TYPE.
  1223                          ;
  1224                          ;   Room for expansion?
  1225                          ;
  1226   0007f3 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000      
  1227                          ;
  1228                          ;   Note that the following six bytes must match those at
  1229                          ; (PATTRN1) or cp/m will HALT. Why?
  1230                          ;
  1231   000800 001600000000    PATTRN2:DB	0,22,0,0,0,0	;(* serial number bytes *).
  1232                          ;
  1233                          ;**************************************************************
  1234                          ;*
  1235                          ;*                    B D O S   E N T R Y
  1236                          ;*
  1237                          ;**************************************************************
  1238                          ;
  1239   000806 c31108          FBASE:	JP	FBASE1
  1240                          ;
  1241                          ;   Bdos error table.
  1242                          ;
  1243   000809 9908            BADSCTR:DW	ERROR1		;bad sector on read or write.
  1244   00080b a508            BADSLCT:DW	ERROR2		;bad disk select.
  1245   00080d ab08            RODISK:	DW	ERROR3		;disk is read only.
  1246   00080f b108            ROFILE:	DW	ERROR4		;file is read only.
  1247                          ;
  1248                          ;   Entry into bdos. (DE) or (E) are the parameters passed. The
  1249                          ; function number desired is in register (C).
  1250                          ;
  1251   000811 eb              FBASE1:	EX	DE,HL		;save the (DE) parameters.
  1252   000812 22430b          	LD	(PARAMS),HL
  1253   000815 eb              	EX	DE,HL
  1254   000816 7b              	LD	A,E		;and save register (E) in particular.
  1255   000817 32d615          	LD	(EPARAM),A
  1256   00081a 210000          	LD	HL,0
  1257   00081d 22450b          	LD	(STATUS),HL	;clear return status.
  1258   000820 39              	ADD	HL,SP
  1259   000821 220f0b          	LD	(USRSTACK),HL	;save users stack pointer.
  1260   000824 31410b          	LD	SP,STKAREA	;and set our own.
  1261   000827 af              	XOR	A		;clear auto select storage space.
  1262   000828 32e015          	LD	(AUTOFLAG),A
  1263   00082b 32de15          	LD	(AUTO),A
  1264   00082e 217415          	LD	HL,GOBACK	;set return address.
  1265   000831 e5              	PUSH	HL
  1266   000832 79              	LD	A,C		;get function number.
  1267   000833 fe29            	CP	NFUNCTS		;valid function number?
  1268   000835 d0              	RET	NC
  1269   000836 4b              	LD	C,E		;keep single register function here.
  1270   000837 214708          	LD	HL,FUNCTNS	;now look thru the function table.
  1271   00083a 5f              	LD	E,A
  1272   00083b 1600            	LD	D,0		;(DE)=function number.
  1273   00083d 19              	ADD	HL,DE
  1274   00083e 19              	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
  1275   00083f 5e              	LD	E,(HL)
  1276   000840 23              	INC	HL
  1277   000841 56              	LD	D,(HL)		;now (DE)=address for this function.
  1278   000842 2a430b          	LD	HL,(PARAMS)	;retrieve parameters.
  1279   000845 eb              	EX	DE,HL		;now (DE) has the original parameters.
  1280   000846 e9              	JP	(HL)		;execute desired function.
  1281                          ;
  1282                          ;   BDOS function jump table.
  1283                          ;
  1284                          NFUNCTS EQU	41		;number of functions in followin table.
  1285                          ;
  1286   000847 0316c80a9009ce0aFUNCTNS:DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
                12160f16d40aed0a
  1287   000857 f30af80ae109fe0a	DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
                7e14831445149c14
  1288   000867 a514ab14c814d714	DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
                e014e614ec14    
  1289   000875 f514fe1404150a15	DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
                11152c0d17151d15
  1290   000885 26152d1541154715	DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
                4d150e145315040b
  1291   000895 040b9b15        	DW	RTN,WTSPECL
  1292                          ;
  1293                          ;   Bdos error message section.
  1294                          ;
  1295   000899 21ca08          ERROR1:	LD	HL,BADSEC	;bad sector message.
  1296   00089c cde508          	CALL	PRTERR		;print it and get a 1 char responce.
  1297   00089f fe03            	CP	CNTRLC		;re-boot request (control-c)?
  1298   0008a1 ca0000          	JP	Z,0		;yes.
  1299   0008a4 c9              	RET			;no, return to retry i/o function.
  1300                          ;
  1301   0008a5 21d508          ERROR2:	LD	HL,BADSEL	;bad drive selected.
  1302   0008a8 c3b408          	JP	ERROR5
  1303                          ;
  1304   0008ab 21e108          ERROR3:	LD	HL,DISKRO	;disk is read only.
  1305   0008ae c3b408          	JP	ERROR5
  1306                          ;
  1307   0008b1 21dc08          ERROR4:	LD	HL,FILERO	;file is read only.
  1308                          ;
  1309   0008b4 cde508          ERROR5:	CALL	PRTERR
  1310   0008b7 c30000          	JP	0		;always reboot on these errors.
  1311                          ;
  1312   0008ba 42646f7320457272BDOSERR:DB	"Bdos Err On "
                204f6e20        
  1313   0008c6 203a2024        BDOSDRV:DB	" : $"
  1314   0008ca 4261642053656374BADSEC:	DB	"Bad Sector$"
                6f7224          
  1315   0008d5 53656c65637424  BADSEL:	DB	"Select$"
  1316   0008dc 46696c6520      FILERO:	DB	"File "
  1317   0008e1 522f4f24        DISKRO:	DB	"R/O$"
  1318                          ;
  1319                          ;   Print bdos error message.
  1320                          ;
  1321   0008e5 e5              PRTERR:	PUSH	HL		;save second message pointer.
  1322   0008e6 cdc909          	CALL	OUTCRLF		;send (cr)(lf).
  1323   0008e9 3a420b          	LD	A,(ACTIVE)	;get active drive.
  1324   0008ec c641            	ADD	A,'A'		;make ascii.
  1325   0008ee 32c608          	LD	(BDOSDRV),A	;and put in message.
  1326   0008f1 01ba08          	LD	BC,BDOSERR	;and print it.
  1327   0008f4 cdd309          	CALL	PRTMESG
  1328   0008f7 c1              	POP	BC		;print second message line now.
  1329   0008f8 cdd309          	CALL	PRTMESG
  1330                          ;
  1331                          ;   Get an input character. We will check our 1 character
  1332                          ; buffer first. This may be set by the console status routine.
  1333                          ;
  1334   0008fb 210e0b          GETCHAR:LD	HL,CHARBUF	;check character buffer.
  1335   0008fe 7e              	LD	A,(HL)		;anything present already?
  1336   0008ff 3600            	LD	(HL),0		;...either case clear it.
  1337   000901 b7              	OR	A
  1338   000902 c0              	RET	NZ		;yes, use it.
  1339   000903 c30916          	JP	CONIN		;nope, go get a character responce.
  1340                          ;
  1341                          ;   Input and echo a character.
  1342                          ;
  1343   000906 cdfb08          GETECHO:CALL	GETCHAR		;input a character.
  1344   000909 cd1409          	CALL	CHKCHAR		;carriage control?
  1345   00090c d8              	RET	C		;no, a regular control char so don't echo.
  1346   00090d f5              	PUSH	AF		;ok, save character now.
  1347   00090e 4f              	LD	C,A
  1348   00090f cd9009          	CALL	OUTCON		;and echo it.
  1349   000912 f1              	POP	AF		;get character and return.
  1350   000913 c9              	RET
  1351                          ;
  1352                          ;   Check character in (A). Set the zero flag on a carriage
  1353                          ; control character and the carry flag on any other control
  1354                          ; character.
  1355                          ;
  1356   000914 fe0d            CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
  1357   000916 c8              	RET	Z		;or a tab.
  1358   000917 fe0a            	CP	LF
  1359   000919 c8              	RET	Z
  1360   00091a fe09            	CP	TAB
  1361   00091c c8              	RET	Z
  1362   00091d fe08            	CP	BS
  1363   00091f c8              	RET	Z
  1364   000920 fe20            	CP	' '		;other control char? Set carry flag.
  1365   000922 c9              	RET
  1366                          ;
  1367                          ;   Check the console during output. Halt on a control-s, then
  1368                          ; reboot on a control-c. If anything else is ready, clear the
  1369                          ; zero flag and return (the calling routine may want to do
  1370                          ; something).
  1371                          ;
  1372   000923 3a0e0b          CKCONSOL: LD	A,(CHARBUF)	;check buffer.
  1373   000926 b7              	OR	A		;if anything, just return without checking.
  1374   000927 c24509          	JP	NZ,CKCON2
  1375   00092a cd0616          	CALL	CONST		;nothing in buffer. Check console.
  1376   00092d e601            	AND	01H		;look at bit 0.
  1377   00092f c8              	RET	Z		;return if nothing.
  1378   000930 cd0916          	CALL	CONIN		;ok, get it.
  1379   000933 fe13            	CP	CNTRLS		;if not control-s, return with zero cleared.
  1380   000935 c24209          	JP	NZ,CKCON1
  1381   000938 cd0916          	CALL	CONIN		;halt processing until another char
  1382   00093b fe03            	CP	CNTRLC		;is typed. Control-c?
  1383   00093d ca0000          	JP	Z,0		;yes, reboot now.
  1384   000940 af              	XOR	A		;no, just pretend nothing was ever ready.
  1385   000941 c9              	RET
  1386   000942 320e0b          CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
  1387   000945 3e01            CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
  1388   000947 c9              	RET
  1389                          ;
  1390                          ;   Output (C) to the screen. If the printer flip-flop flag
  1391                          ; is set, we will send character to printer also. The console
  1392                          ; will be checked in the process.
  1393                          ;
  1394   000948 3a0a0b          OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
  1395   00094b b7              	OR	A		;anything and we won't generate output.
  1396   00094c c26209          	JP	NZ,OUTCHR1
  1397   00094f c5              	PUSH	BC
  1398   000950 cd2309          	CALL	CKCONSOL	;check console (we don't care whats there).
  1399   000953 c1              	POP	BC
  1400   000954 c5              	PUSH	BC
  1401   000955 cd0c16          	CALL	CONOUT		;output (C) to the screen.
  1402   000958 c1              	POP	BC
  1403   000959 c5              	PUSH	BC
  1404   00095a 3a0d0b          	LD	A,(PRTFLAG)	;check printer flip-flop flag.
  1405   00095d b7              	OR	A
  1406   00095e c40f16          	CALL	NZ,LIST		;print it also if non-zero.
  1407   000961 c1              	POP	BC
  1408   000962 79              OUTCHR1:LD	A,C		;update cursors position.
  1409   000963 210c0b          	LD	HL,CURPOS
  1410   000966 fe7f            	CP	DEL		;rubouts don't do anything here.
  1411   000968 c8              	RET	Z
  1412   000969 34              	INC	(HL)		;bump line pointer.
  1413   00096a fe20            	CP	' '		;and return if a normal character.
  1414   00096c d0              	RET	NC
  1415   00096d 35              	DEC	(HL)		;restore and check for the start of the line.
  1416   00096e 7e              	LD	A,(HL)
  1417   00096f b7              	OR	A
  1418   000970 c8              	RET	Z		;ingnore control characters at the start of the line.
  1419   000971 79              	LD	A,C
  1420   000972 fe08            	CP	BS		;is it a backspace?
  1421   000974 c27909          	JP	NZ,OUTCHR2
  1422   000977 35              	DEC	(HL)		;yes, backup pointer.
  1423   000978 c9              	RET
  1424   000979 fe0a            OUTCHR2:CP	LF		;is it a line feed?
  1425   00097b c0              	RET	NZ		;ignore anything else.
  1426   00097c 3600            	LD	(HL),0		;reset pointer to start of line.
  1427   00097e c9              	RET
  1428                          ;
  1429                          ;   Output (A) to the screen. If it is a control character
  1430                          ; (other than carriage control), use ^x format.
  1431                          ;
  1432   00097f 79              SHOWIT:	LD	A,C
  1433   000980 cd1409          	CALL	CHKCHAR		;check character.
  1434   000983 d29009          	JP	NC,OUTCON	;not a control, use normal output.
  1435   000986 f5              	PUSH	AF
  1436   000987 0e5e            	LD	C,'^'		;for a control character, preceed it with '^'.
  1437   000989 cd4809          	CALL	OUTCHAR
  1438   00098c f1              	POP	AF
  1439   00098d f640            	OR	'@'		;and then use the letter equivelant.
  1440   00098f 4f              	LD	C,A
  1441                          ;
  1442                          ;   Function to output (C) to the console device and expand tabs
  1443                          ; if necessary.
  1444                          ;
  1445   000990 79              OUTCON:	LD	A,C
  1446   000991 fe09            	CP	TAB		;is it a tab?
  1447   000993 c24809          	JP	NZ,OUTCHAR	;use regular output.
  1448   000996 0e20            OUTCON1:LD	C,' '		;yes it is, use spaces instead.
  1449   000998 cd4809          	CALL	OUTCHAR
  1450   00099b 3a0c0b          	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
  1451                          
  1452   00099e e607            	AND	07H		;position.
  1453   0009a0 c29609          	JP	NZ,OUTCON1
  1454   0009a3 c9              	RET
  1455                          ;
  1456                          ;   Echo a backspace character. Erase the prevoius character
  1457                          ; on the screen.
  1458                          ;
  1459   0009a4 cdac09          BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
  1460   0009a7 0e20            	LD	C,' '		;then blank that character.
  1461   0009a9 cd0c16          	CALL	CONOUT
  1462   0009ac 0e08            BACKUP1:LD	C,BS		;then back space once more.
  1463   0009ae c30c16          	JP	CONOUT
  1464                          ;
  1465                          ;   Signal a deleted line. Print a '#' at the end and start
  1466                          ; over.
  1467                          ;
  1468   0009b1 0e23            NEWLINE:LD	C,'#'
  1469   0009b3 cd4809          	CALL	OUTCHAR		;print this.
  1470   0009b6 cdc909          	CALL	OUTCRLF		;start new line.
  1471   0009b9 3a0c0b          NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
  1472   0009bc 210b0b          	LD	HL,STARTING
  1473   0009bf be              	CP	(HL)
  1474   0009c0 d0              	RET	NC		;there yet?
  1475   0009c1 0e20            	LD	C,' '
  1476   0009c3 cd4809          	CALL	OUTCHAR		;nope, keep going.
  1477   0009c6 c3b909          	JP	NEWLN1
  1478                          ;
  1479                          ;   Output a (cr) (lf) to the console device (screen).
  1480                          ;
  1481   0009c9 0e0d            OUTCRLF:LD	C,CR
  1482   0009cb cd4809          	CALL	OUTCHAR
  1483   0009ce 0e0a            	LD	C,LF
  1484   0009d0 c34809          	JP	OUTCHAR
  1485                          ;
  1486                          ;   Print message pointed to by (BC). It will end with a '$'.
  1487                          ;
  1488   0009d3 0a              PRTMESG:LD	A,(BC)		;check for terminating character.
  1489   0009d4 fe24            	CP	'$'
  1490   0009d6 c8              	RET	Z
  1491   0009d7 03              	INC	BC
  1492   0009d8 c5              	PUSH	BC		;otherwise, bump pointer and print it.
  1493   0009d9 4f              	LD	C,A
  1494   0009da cd9009          	CALL	OUTCON
  1495   0009dd c1              	POP	BC
  1496   0009de c3d309          	JP	PRTMESG
  1497                          ;
  1498                          ;   Function to execute a buffered read.
  1499                          ;
  1500   0009e1 3a0c0b          RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
  1501   0009e4 320b0b          	LD	(STARTING),A
  1502   0009e7 2a430b          	LD	HL,(PARAMS)	;get the maximum buffer space.
  1503   0009ea 4e              	LD	C,(HL)
  1504   0009eb 23              	INC	HL		;point to first available space.
  1505   0009ec e5              	PUSH	HL		;and save.
  1506   0009ed 0600            	LD	B,0		;keep a character count.
  1507   0009ef c5              RDBUF1:	PUSH	BC
  1508   0009f0 e5              	PUSH	HL
  1509   0009f1 cdfb08          RDBUF2:	CALL	GETCHAR		;get the next input character.
  1510   0009f4 e67f            	AND	7FH		;strip bit 7.
  1511   0009f6 e1              	POP	HL		;reset registers.
  1512   0009f7 c1              	POP	BC
  1513   0009f8 fe0d            	CP	CR		;en of the line?
  1514   0009fa cac10a          	JP	Z,RDBUF17
  1515   0009fd fe0a            	CP	LF
  1516   0009ff cac10a          	JP	Z,RDBUF17
  1517   000a02 fe08            	CP	BS		;how about a backspace?
  1518   000a04 c2160a          	JP	NZ,RDBUF3
  1519   000a07 78              	LD	A,B		;yes, but ignore at the beginning of the line.
  1520   000a08 b7              	OR	A
  1521   000a09 caef09          	JP	Z,RDBUF1
  1522   000a0c 05              	DEC	B		;ok, update counter.
  1523   000a0d 3a0c0b          	LD	A,(CURPOS)	;if we backspace to the start of the line,
  1524   000a10 320a0b          	LD	(OUTFLAG),A	;treat as a cancel (control-x).
  1525   000a13 c3700a          	JP	RDBUF10
  1526   000a16 fe7f            RDBUF3:	CP	DEL		;user typed a rubout?
  1527   000a18 c2260a          	JP	NZ,RDBUF4
  1528   000a1b 78              	LD	A,B		;ignore at the start of the line.
  1529   000a1c b7              	OR	A
  1530   000a1d caef09          	JP	Z,RDBUF1
  1531   000a20 7e              	LD	A,(HL)		;ok, echo the prevoius character.
  1532   000a21 05              	DEC	B		;and reset pointers (counters).
  1533   000a22 2b              	DEC	HL
  1534   000a23 c3a90a          	JP	RDBUF15
  1535   000a26 fe05            RDBUF4:	CP	CNTRLE		;physical end of line?
  1536   000a28 c2370a          	JP	NZ,RDBUF5
  1537   000a2b c5              	PUSH	BC		;yes, do it.
  1538   000a2c e5              	PUSH	HL
  1539   000a2d cdc909          	CALL	OUTCRLF
  1540   000a30 af              	XOR	A		;and update starting position.
  1541   000a31 320b0b          	LD	(STARTING),A
  1542   000a34 c3f109          	JP	RDBUF2
  1543   000a37 fe10            RDBUF5:	CP	CNTRLP		;control-p?
  1544   000a39 c2480a          	JP	NZ,RDBUF6
  1545   000a3c e5              	PUSH	HL		;yes, flip the print flag filp-flop byte.
  1546   000a3d 210d0b          	LD	HL,PRTFLAG
  1547   000a40 3e01            	LD	A,1		;PRTFLAG=1-PRTFLAG
  1548   000a42 96              	SUB	(HL)
  1549   000a43 77              	LD	(HL),A
  1550   000a44 e1              	POP	HL
  1551   000a45 c3ef09          	JP	RDBUF1
  1552   000a48 fe18            RDBUF6:	CP	CNTRLX		;control-x (cancel)?
  1553   000a4a c25f0a          	JP	NZ,RDBUF8
  1554   000a4d e1              	POP	HL
  1555   000a4e 3a0b0b          RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
  1556   000a51 210c0b          	LD	HL,CURPOS
  1557   000a54 be              	CP	(HL)
  1558   000a55 d2e109          	JP	NC,RDBUFF	;done yet?
  1559   000a58 35              	DEC	(HL)		;no, decrement pointer and output back up one space.
  1560   000a59 cda409          	CALL	BACKUP
  1561   000a5c c34e0a          	JP	RDBUF7
  1562   000a5f fe15            RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
  1563   000a61 c26b0a          	JP	NZ,RDBUF9
  1564   000a64 cdb109          	CALL	NEWLINE		;start a new line.
  1565   000a67 e1              	POP	HL
  1566   000a68 c3e109          	JP	RDBUFF
  1567   000a6b fe12            RDBUF9:	CP	CNTRLR		;control-r?
  1568   000a6d c2a60a          	JP	NZ,RDBUF14
  1569   000a70 c5              RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
  1570   000a71 cdb109          	CALL	NEWLINE
  1571   000a74 c1              	POP	BC
  1572   000a75 e1              	POP	HL
  1573   000a76 e5              	PUSH	HL
  1574   000a77 c5              	PUSH	BC
  1575   000a78 78              RDBUF11:LD	A,B		;done whole line yet?
  1576   000a79 b7              	OR	A
  1577   000a7a ca8a0a          	JP	Z,RDBUF12
  1578   000a7d 23              	INC	HL		;nope, get next character.
  1579   000a7e 4e              	LD	C,(HL)
  1580   000a7f 05              	DEC	B		;count it.
  1581   000a80 c5              	PUSH	BC
  1582   000a81 e5              	PUSH	HL
  1583   000a82 cd7f09          	CALL	SHOWIT		;and display it.
  1584   000a85 e1              	POP	HL
  1585   000a86 c1              	POP	BC
  1586   000a87 c3780a          	JP	RDBUF11
  1587   000a8a e5              RDBUF12:PUSH	HL		;done with line. If we were displaying
  1588   000a8b 3a0a0b          	LD	A,(OUTFLAG)	;then update cursor position.
  1589   000a8e b7              	OR	A
  1590   000a8f caf109          	JP	Z,RDBUF2
  1591   000a92 210c0b          	LD	HL,CURPOS	;because this line is shorter, we must
  1592   000a95 96              	SUB	(HL)		;back up the cursor (not the screen however)
  1593   000a96 320a0b          	LD	(OUTFLAG),A	;some number of positions.
  1594   000a99 cda409          RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
  1595   000a9c 210a0b          	LD	HL,OUTFLAG	;zero, the screen will not be changed.
  1596   000a9f 35              	DEC	(HL)
  1597   000aa0 c2990a          	JP	NZ,RDBUF13
  1598   000aa3 c3f109          	JP	RDBUF2		;now just get the next character.
  1599                          ;
  1600                          ;   Just a normal character, put this in our buffer and echo.
  1601                          ;
  1602   000aa6 23              RDBUF14:INC	HL
  1603   000aa7 77              	LD	(HL),A		;store character.
  1604   000aa8 04              	INC	B		;and count it.
  1605   000aa9 c5              RDBUF15:PUSH	BC
  1606   000aaa e5              	PUSH	HL
  1607   000aab 4f              	LD	C,A		;echo it now.
  1608   000aac cd7f09          	CALL	SHOWIT
  1609   000aaf e1              	POP	HL
  1610   000ab0 c1              	POP	BC
  1611   000ab1 7e              	LD	A,(HL)		;was it an abort request?
  1612   000ab2 fe03            	CP	CNTRLC		;control-c abort?
  1613   000ab4 78              	LD	A,B
  1614   000ab5 c2bd0a          	JP	NZ,RDBUF16
  1615   000ab8 fe01            	CP	1		;only if at start of line.
  1616   000aba ca0000          	JP	Z,0
  1617   000abd b9              RDBUF16:CP	C		;nope, have we filled the buffer?
  1618   000abe daef09          	JP	C,RDBUF1
  1619   000ac1 e1              RDBUF17:POP	HL		;yes end the line and return.
  1620   000ac2 70              	LD	(HL),B
  1621   000ac3 0e0d            	LD	C,CR
  1622   000ac5 c34809          	JP	OUTCHAR		;output (cr) and return.
  1623                          ;
  1624                          ;   Function to get a character from the console device.
  1625                          ;
  1626   000ac8 cd0609          GETCON:	CALL	GETECHO		;get and echo.
  1627   000acb c3010b          	JP	SETSTAT		;save status and return.
  1628                          ;
  1629                          ;   Function to get a character from the tape reader device.
  1630                          ;
  1631   000ace cd1516          GETRDR:	CALL	READER		;get a character from reader, set status and return.
  1632   000ad1 c3010b          	JP	SETSTAT
  1633                          ;
  1634                          ;  Function to perform direct console i/o. If (C) contains (FF)
  1635                          ; then this is an input request. If (C) contains (FE) then
  1636                          ; this is a status request. Otherwise we are to output (C).
  1637                          ;
  1638   000ad4 79              DIRCIO:	LD	A,C		;test for (FF).
  1639   000ad5 3c              	INC	A
  1640   000ad6 cae00a          	JP	Z,DIRC1
  1641   000ad9 3c              	INC	A		;test for (FE).
  1642   000ada ca0616          	JP	Z,CONST
  1643   000add c30c16          	JP	CONOUT		;just output (C).
  1644   000ae0 cd0616          DIRC1:	CALL	CONST		;this is an input request.
  1645   000ae3 b7              	OR	A
  1646   000ae4 ca9115          	JP	Z,GOBACK1	;not ready? Just return (directly).
  1647   000ae7 cd0916          	CALL	CONIN		;yes, get character.
  1648   000aea c3010b          	JP	SETSTAT		;set status and return.
  1649                          ;
  1650                          ;   Function to return the i/o byte.
  1651                          ;
  1652   000aed 3a0300          GETIOB:	LD	A,(IOBYTE)
  1653   000af0 c3010b          	JP	SETSTAT
  1654                          ;
  1655                          ;   Function to set the i/o byte.
  1656                          ;
  1657   000af3 210300          SETIOB:	LD	HL,IOBYTE
  1658   000af6 71              	LD	(HL),C
  1659   000af7 c9              	RET
  1660                          ;
  1661                          ;   Function to print the character string pointed to by (DE)
  1662                          ; on the console device. The string ends with a '$'.
  1663                          ;
  1664   000af8 eb              PRTSTR:	EX	DE,HL
  1665   000af9 4d              	LD	C,L
  1666   000afa 44              	LD	B,H		;now (BC) points to it.
  1667   000afb c3d309          	JP	PRTMESG
  1668                          ;
  1669                          ;   Function to interigate the console device.
  1670                          ;
  1671   000afe cd2309          GETCSTS:CALL	CKCONSOL
  1672                          ;
  1673                          ;   Get here to set the status and return to the cleanup
  1674                          ; section. Then back to the user.
  1675                          ;
  1676   000b01 32450b          SETSTAT:LD	(STATUS),A
  1677   000b04 c9              RTN:	RET
  1678                          ;
  1679                          ;   Set the status to 1 (read or write error code).
  1680                          ;
  1681   000b05 3e01            IOERR1:	LD	A,1
  1682   000b07 c3010b          	JP	SETSTAT
  1683                          ;
  1684   000b0a 00              OUTFLAG:DB	0		;output flag (non zero means no output).
  1685   000b0b 02              STARTING: DB	2		;starting position for cursor.
  1686   000b0c 00              CURPOS:	DB	0		;cursor position (0=start of line).
  1687   000b0d 00              PRTFLAG:DB	0		;printer flag (control-p toggle). List if non zero.
  1688   000b0e 00              CHARBUF:DB	0		;single input character buffer.
  1689                          ;
  1690                          ;   Stack area for BDOS calls.
  1691                          ;
  1692   000b0f 0000            USRSTACK: DW	0		;save users stack pointer here.
  1693                          ;
  1694   000b11 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                0000000000000000
  1695   000b29 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                0000000000000000
  1696                          STKAREA EQU	$		;end of stack area.
  1697                          ;
  1698   000b41 00              USERNO:	DB	0		;current user number.
  1699   000b42 00              ACTIVE:	DB	0		;currently active drive.
  1700   000b43 0000            PARAMS:	DW	0		;save (DE) parameters here on entry.
  1701   000b45 0000            STATUS:	DW	0		;status returned from bdos function.
  1702                          ;
  1703                          ;   Select error occured, jump to error routine.
  1704                          ;
  1705   000b47 210b08          SLCTERR:LD	HL,BADSLCT
  1706                          ;
  1707                          ;   Jump to (HL) indirectly.
  1708                          ;
  1709   000b4a 5e              JUMPHL:	LD	E,(HL)
  1710   000b4b 23              	INC	HL
  1711   000b4c 56              	LD	D,(HL)		;now (DE) contain the desired address.
  1712   000b4d eb              	EX	DE,HL
  1713   000b4e e9              	JP	(HL)
  1714                          ;
  1715                          ;   Block move. (DE) to (HL), (C) bytes total.
  1716                          ;
  1717   000b4f 0c              DE2HL:	INC	C		;is count down to zero?
  1718   000b50 0d              DE2HL1:	DEC	C
  1719   000b51 c8              	RET	Z		;yes, we are done.
  1720   000b52 1a              	LD	A,(DE)		;no, move one more byte.
  1721   000b53 77              	LD	(HL),A
  1722   000b54 13              	INC	DE
  1723   000b55 23              	INC	HL
  1724   000b56 c3500b          	JP	DE2HL1		;and repeat.
  1725                          ;
  1726                          ;   Select the desired drive.
  1727                          ;
  1728   000b59 3a420b          SELECT:	LD	A,(ACTIVE)	;get active disk.
  1729   000b5c 4f              	LD	C,A
  1730   000b5d cd1b16          	CALL	SELDSK		;select it.
  1731   000b60 7c              	LD	A,H		;valid drive?
  1732   000b61 b5              	OR	L		;valid drive?
  1733   000b62 c8              	RET	Z		;return if not.
  1734                          ;
  1735                          ;   Here, the BIOS returned the address of the parameter block
  1736                          ; in (HL). We will extract the necessary pointers and save them.
  1737                          ;
  1738   000b63 5e              	LD	E,(HL)		;yes, get address of translation table into (DE).
  1739   000b64 23              	INC	HL
  1740   000b65 56              	LD	D,(HL)
  1741   000b66 23              	INC	HL
  1742   000b67 22b315          	LD	(SCRATCH1),HL	;save pointers to scratch areas.
  1743   000b6a 23              	INC	HL
  1744   000b6b 23              	INC	HL
  1745   000b6c 22b515          	LD	(SCRATCH2),HL	;ditto.
  1746   000b6f 23              	INC	HL
  1747   000b70 23              	INC	HL
  1748   000b71 22b715          	LD	(SCRATCH3),HL	;ditto.
  1749   000b74 23              	INC	HL
  1750   000b75 23              	INC	HL
  1751   000b76 eb              	EX	DE,HL		;now save the translation table address.
  1752   000b77 22d015          	LD	(XLATE),HL
  1753   000b7a 21b915          	LD	HL,DIRBUF	;put the next 8 bytes here.
  1754   000b7d 0e08            	LD	C,8		;they consist of the directory buffer
  1755   000b7f cd4f0b          	CALL	DE2HL		;pointer, parameter block pointer,
  1756   000b82 2abb15          	LD	HL,(DISKPB)	;check and allocation vectors.
  1757   000b85 eb              	EX	DE,HL
  1758   000b86 21c115          	LD	HL,SECTORS	;move parameter block into our ram.
  1759   000b89 0e0f            	LD	C,15		;it is 15 bytes long.
  1760   000b8b cd4f0b          	CALL	DE2HL
  1761   000b8e 2ac615          	LD	HL,(DSKSIZE)	;check disk size.
  1762   000b91 7c              	LD	A,H		;more than 256 blocks on this?
  1763   000b92 21dd15          	LD	HL,BIGDISK
  1764   000b95 36ff            	LD	(HL),0FFH	;set to samll.
  1765   000b97 b7              	OR	A
  1766   000b98 ca9d0b          	JP	Z,SELECT1
  1767   000b9b 3600            	LD	(HL),0		;wrong, set to large.
  1768   000b9d 3eff            SELECT1:LD	A,0FFH		;clear the zero flag.
  1769   000b9f b7              	OR	A
  1770   000ba0 c9              	RET
  1771                          ;
  1772                          ;   Routine to home the disk track head and clear pointers.
  1773                          ;
  1774   000ba1 cd1816          HOMEDRV:CALL	HOME		;home the head.
  1775   000ba4 af              	XOR	A
  1776   000ba5 2ab515          	LD	HL,(SCRATCH2)	;set our track pointer also.
  1777   000ba8 77              	LD	(HL),A
  1778   000ba9 23              	INC	HL
  1779   000baa 77              	LD	(HL),A
  1780   000bab 2ab715          	LD	HL,(SCRATCH3)	;and our sector pointer.
  1781   000bae 77              	LD	(HL),A
  1782   000baf 23              	INC	HL
  1783   000bb0 77              	LD	(HL),A
  1784   000bb1 c9              	RET
  1785                          ;
  1786                          ;   Do the actual disk read and check the error return status.
  1787                          ;
  1788   000bb2 cd2716          DOREAD:	CALL	READ
  1789   000bb5 c3bb0b          	JP	IORET
  1790                          ;
  1791                          ;   Do the actual disk write and handle any bios error.
  1792                          ;
  1793   000bb8 cd2a16          DOWRITE:CALL	WRITE
  1794   000bbb b7              IORET:	OR	A
  1795   000bbc c8              	RET	Z		;return unless an error occured.
  1796   000bbd 210908          	LD	HL,BADSCTR	;bad read/write on this sector.
  1797   000bc0 c34a0b          	JP	JUMPHL
  1798                          ;
  1799                          ;   Routine to select the track and sector that the desired
  1800                          ; block number falls in.
  1801                          ;
  1802   000bc3 2aea15          TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
  1803   000bc6 0e02            	LD	C,2		;in directory and compute sector #.
  1804   000bc8 cdea0c          	CALL	SHIFTR		;sector #=file-position/4.
  1805   000bcb 22e515          	LD	(BLKNMBR),HL	;save this as the block number of interest.
  1806   000bce 22ec15          	LD	(CKSUMTBL),HL	;what's it doing here too?
  1807                          ;
  1808                          ;   if the sector number has already been set (BLKNMBR), enter
  1809                          ; at this point.
  1810                          ;
  1811   000bd1 21e515          TRKSEC1:LD	HL,BLKNMBR
  1812   000bd4 4e              	LD	C,(HL)		;move sector number into (BC).
  1813   000bd5 23              	INC	HL
  1814   000bd6 46              	LD	B,(HL)
  1815   000bd7 2ab715          	LD	HL,(SCRATCH3)	;get current sector number and
  1816   000bda 5e              	LD	E,(HL)		;move this into (DE).
  1817   000bdb 23              	INC	HL
  1818   000bdc 56              	LD	D,(HL)
  1819   000bdd 2ab515          	LD	HL,(SCRATCH2)	;get current track number.
  1820   000be0 7e              	LD	A,(HL)		;and this into (HL).
  1821   000be1 23              	INC	HL
  1822   000be2 66              	LD	H,(HL)
  1823   000be3 6f              	LD	L,A
  1824   000be4 79              TRKSEC2:LD	A,C		;is desired sector before current one?
  1825   000be5 93              	SUB	E
  1826   000be6 78              	LD	A,B
  1827   000be7 9a              	SBC	A,D
  1828   000be8 d2fa0b          	JP	NC,TRKSEC3
  1829   000beb e5              	PUSH	HL		;yes, decrement sectors by one track.
  1830   000bec 2ac115          	LD	HL,(SECTORS)	;get sectors per track.
  1831   000bef 7b              	LD	A,E
  1832   000bf0 95              	SUB	L
  1833   000bf1 5f              	LD	E,A
  1834   000bf2 7a              	LD	A,D
  1835   000bf3 9c              	SBC	A,H
  1836   000bf4 57              	LD	D,A		;now we have backed up one full track.
  1837   000bf5 e1              	POP	HL
  1838   000bf6 2b              	DEC	HL		;adjust track counter.
  1839   000bf7 c3e40b          	JP	TRKSEC2
  1840   000bfa e5              TRKSEC3:PUSH	HL		;desired sector is after current one.
  1841   000bfb 2ac115          	LD	HL,(SECTORS)	;get sectors per track.
  1842   000bfe 19              	ADD	HL,DE		;bump sector pointer to next track.
  1843   000bff da0f0c          	JP	C,TRKSEC4
  1844   000c02 79              	LD	A,C		;is desired sector now before current one?
  1845   000c03 95              	SUB	L
  1846   000c04 78              	LD	A,B
  1847   000c05 9c              	SBC	A,H
  1848   000c06 da0f0c          	JP	C,TRKSEC4
  1849   000c09 eb              	EX	DE,HL		;not yes, increment track counter
  1850   000c0a e1              	POP	HL		;and continue until it is.
  1851   000c0b 23              	INC	HL
  1852   000c0c c3fa0b          	JP	TRKSEC3
  1853                          ;
  1854                          ;   here we have determined the track number that contains the
  1855                          ; desired sector.
  1856                          ;
  1857   000c0f e1              TRKSEC4:POP	HL		;get track number (HL).
  1858   000c10 c5              	PUSH	BC
  1859   000c11 d5              	PUSH	DE
  1860   000c12 e5              	PUSH	HL
  1861   000c13 eb              	EX	DE,HL
  1862   000c14 2ace15          	LD	HL,(OFFSET)	;adjust for first track offset.
  1863   000c17 19              	ADD	HL,DE
  1864   000c18 44              	LD	B,H
  1865   000c19 4d              	LD	C,L
  1866   000c1a cd1e16          	CALL	SETTRK		;select this track.
  1867   000c1d d1              	POP	DE		;reset current track pointer.
  1868   000c1e 2ab515          	LD	HL,(SCRATCH2)
  1869   000c21 73              	LD	(HL),E
  1870   000c22 23              	INC	HL
  1871   000c23 72              	LD	(HL),D
  1872   000c24 d1              	POP	DE
  1873   000c25 2ab715          	LD	HL,(SCRATCH3)	;reset the first sector on this track.
  1874   000c28 73              	LD	(HL),E
  1875   000c29 23              	INC	HL
  1876   000c2a 72              	LD	(HL),D
  1877   000c2b c1              	POP	BC
  1878   000c2c 79              	LD	A,C		;now subtract the desired one.
  1879   000c2d 93              	SUB	E		;to make it relative (1-# sectors/track).
  1880   000c2e 4f              	LD	C,A
  1881   000c2f 78              	LD	A,B
  1882   000c30 9a              	SBC	A,D
  1883   000c31 47              	LD	B,A
  1884   000c32 2ad015          	LD	HL,(XLATE)	;translate this sector according to this table.
  1885   000c35 eb              	EX	DE,HL
  1886   000c36 cd3016          	CALL	SECTRN		;let the bios translate it.
  1887   000c39 4d              	LD	C,L
  1888   000c3a 44              	LD	B,H
  1889   000c3b c32116          	JP	SETSEC		;and select it.
  1890                          ;
  1891                          ;   Compute block number from record number (SAVNREC) and
  1892                          ; extent number (SAVEXT).
  1893                          ;
  1894   000c3e 21c315          GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
  1895   000c41 4e              	LD	C,(HL)		;note that this is base 2 log of ratio.
  1896   000c42 3ae315          	LD	A,(SAVNREC)	;get record number.
  1897   000c45 b7              GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
  1898   000c46 1f              	RRA
  1899   000c47 0d              	DEC	C
  1900   000c48 c2450c          	JP	NZ,GETBLK1
  1901   000c4b 47              	LD	B,A		;save result in (B).
  1902   000c4c 3e08            	LD	A,8
  1903   000c4e 96              	SUB	(HL)
  1904   000c4f 4f              	LD	C,A		;compute (C)=8-BLKSHFT.
  1905   000c50 3ae215          	LD	A,(SAVEXT)
  1906   000c53 0d              GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
  1907   000c54 ca5c0c          	JP	Z,GETBLK3
  1908   000c57 b7              	OR	A
  1909   000c58 17              	RLA
  1910   000c59 c3530c          	JP	GETBLK2
  1911   000c5c 80              GETBLK3:ADD	A,B
  1912   000c5d c9              	RET
  1913                          ;
  1914                          ;   Routine to extract the (BC) block byte from the fcb pointed
  1915                          ; to by (PARAMS). If this is a big-disk, then these are 16 bit
  1916                          ; block numbers, else they are 8 bit numbers.
  1917                          ; Number is returned in (HL).
  1918                          ;
  1919   000c5e 2a430b          EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
  1920   000c61 111000          	LD	DE,16		;block numbers start 16 bytes into fcb.
  1921   000c64 19              	ADD	HL,DE
  1922   000c65 09              	ADD	HL,BC
  1923   000c66 3add15          	LD	A,(BIGDISK)	;are we using a big-disk?
  1924   000c69 b7              	OR	A
  1925   000c6a ca710c          	JP	Z,EXTBLK1
  1926   000c6d 6e              	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
  1927   000c6e 2600            	LD	H,0
  1928   000c70 c9              	RET
  1929   000c71 09              EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
  1930   000c72 5e              	LD	E,(HL)
  1931   000c73 23              	INC	HL
  1932   000c74 56              	LD	D,(HL)
  1933   000c75 eb              	EX	DE,HL		;return in (HL).
  1934   000c76 c9              	RET
  1935                          ;
  1936                          ;   Compute block number.
  1937                          ;
  1938   000c77 cd3e0c          COMBLK:	CALL	GETBLOCK
  1939   000c7a 4f              	LD	C,A
  1940   000c7b 0600            	LD	B,0
  1941   000c7d cd5e0c          	CALL	EXTBLK
  1942   000c80 22e515          	LD	(BLKNMBR),HL
  1943   000c83 c9              	RET
  1944                          ;
  1945                          ;   Check for a zero block number (unused).
  1946                          ;
  1947   000c84 2ae515          CHKBLK:	LD	HL,(BLKNMBR)
  1948   000c87 7d              	LD	A,L		;is it zero?
  1949   000c88 b4              	OR	H
  1950   000c89 c9              	RET
  1951                          ;
  1952                          ;   Adjust physical block (BLKNMBR) and convert to logical
  1953                          ; sector (LOGSECT). This is the starting sector of this block.
  1954                          ; The actual sector of interest is then added to this and the
  1955                          ; resulting sector number is stored back in (BLKNMBR). This
  1956                          ; will still have to be adjusted for the track number.
  1957                          ;
  1958   000c8a 3ac315          LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
  1959   000c8d 2ae515          	LD	HL,(BLKNMBR)	;get physical sector desired.
  1960   000c90 29              LOGICL1:ADD	HL,HL		;compute logical sector number.
  1961   000c91 3d              	DEC	A		;note logical sectors are 128 bytes long.
  1962   000c92 c2900c          	JP	NZ,LOGICL1
  1963   000c95 22e715          	LD	(LOGSECT),HL	;save logical sector.
  1964   000c98 3ac415          	LD	A,(BLKMASK)	;get block mask.
  1965   000c9b 4f              	LD	C,A
  1966   000c9c 3ae315          	LD	A,(SAVNREC)	;get next sector to access.
  1967   000c9f a1              	AND	C		;extract the relative position within physical block.
  1968   000ca0 b5              	OR	L		;and add it too logical sector.
  1969   000ca1 6f              	LD	L,A
  1970   000ca2 22e515          	LD	(BLKNMBR),HL	;and store.
  1971   000ca5 c9              	RET
  1972                          ;
  1973                          ;   Set (HL) to point to extent byte in fcb.
  1974                          ;
  1975   000ca6 2a430b          SETEXT:	LD	HL,(PARAMS)
  1976   000ca9 110c00          	LD	DE,12		;it is the twelth byte.
  1977   000cac 19              	ADD	HL,DE
  1978   000cad c9              	RET
  1979                          ;
  1980                          ;   Set (HL) to point to record count byte in fcb and (DE) to
  1981                          ; next record number byte.
  1982                          ;
  1983   000cae 2a430b          SETHLDE:LD	HL,(PARAMS)
  1984   000cb1 110f00          	LD	DE,15		;record count byte (#15).
  1985   000cb4 19              	ADD	HL,DE
  1986   000cb5 eb              	EX	DE,HL
  1987   000cb6 211100          	LD	HL,17		;next record number (#32).
  1988   000cb9 19              	ADD	HL,DE
  1989   000cba c9              	RET
  1990                          ;
  1991                          ;   Save current file data from fcb.
  1992                          ;
  1993   000cbb cdae0c          STRDATA:CALL	SETHLDE
  1994   000cbe 7e              	LD	A,(HL)		;get and store record count byte.
  1995   000cbf 32e315          	LD	(SAVNREC),A
  1996   000cc2 eb              	EX	DE,HL
  1997   000cc3 7e              	LD	A,(HL)		;get and store next record number byte.
  1998   000cc4 32e115          	LD	(SAVNXT),A
  1999   000cc7 cda60c          	CALL	SETEXT		;point to extent byte.
  2000   000cca 3ac515          	LD	A,(EXTMASK)	;get extent mask.
  2001   000ccd a6              	AND	(HL)
  2002   000cce 32e215          	LD	(SAVEXT),A	;and save extent here.
  2003   000cd1 c9              	RET
  2004                          ;
  2005                          ;   Set the next record to access. If (MODE) is set to 2, then
  2006                          ; the last record byte (SAVNREC) has the correct number to access.
  2007                          ; For sequential access, (MODE) will be equal to 1.
  2008                          ;
  2009   000cd2 cdae0c          SETNREC:CALL	SETHLDE
  2010   000cd5 3ad515          	LD	A,(MODE)	;get sequential flag (=1).
  2011   000cd8 fe02            	CP	2		;a 2 indicates that no adder is needed.
  2012   000cda c2de0c          	JP	NZ,STNREC1
  2013   000cdd af              	XOR	A		;clear adder (random access?).
  2014   000cde 4f              STNREC1:LD	C,A
  2015   000cdf 3ae315          	LD	A,(SAVNREC)	;get last record number.
  2016   000ce2 81              	ADD	A,C		;increment record count.
  2017   000ce3 77              	LD	(HL),A		;and set fcb's next record byte.
  2018   000ce4 eb              	EX	DE,HL
  2019   000ce5 3ae115          	LD	A,(SAVNXT)	;get next record byte from storage.
  2020   000ce8 77              	LD	(HL),A		;and put this into fcb as number of records used.
  2021   000ce9 c9              	RET
  2022                          ;
  2023                          ;   Shift (HL) right (C) bits.
  2024                          ;
  2025   000cea 0c              SHIFTR:	INC	C
  2026   000ceb 0d              SHIFTR1:DEC	C
  2027   000cec c8              	RET	Z
  2028   000ced 7c              	LD	A,H
  2029   000cee b7              	OR	A
  2030   000cef 1f              	RRA
  2031   000cf0 67              	LD	H,A
  2032   000cf1 7d              	LD	A,L
  2033   000cf2 1f              	RRA
  2034   000cf3 6f              	LD	L,A
  2035   000cf4 c3eb0c          	JP	SHIFTR1
  2036                          ;
  2037                          ;   Compute the check-sum for the directory buffer. Return
  2038                          ; integer sum in (A).
  2039                          ;
  2040   000cf7 0e80            CHECKSUM:	LD	C,128		;length of buffer.
  2041   000cf9 2ab915          		LD	HL,(DIRBUF)	;get its location.
  2042   000cfc af              		XOR	A		;clear summation byte.
  2043   000cfd 86              CHKSUM1:	ADD	A, (HL)		;and compute sum ignoring carries.
  2044   000cfe 23              		INC	HL
  2045   000cff 0d              		DEC	C
  2046   000d00 c2fd0c          		JP	NZ,CHKSUM1
  2047   000d03 c9              		RET
  2048                          ;
  2049                          ;   Shift (HL) left (C) bits.
  2050                          ;
  2051   000d04 0c              SHIFTL:		INC	C
  2052   000d05 0d              SHIFTL1:	DEC	C
  2053   000d06 c8              		RET	Z
  2054   000d07 29              		ADD	HL,HL		;shift left 1 bit.
  2055   000d08 c3050d          		JP	SHIFTL1
  2056                          ;
  2057                          ;   Routine to set a bit in a 16 bit value contained in (BC).
  2058                          ; The bit set depends on the current drive selection.
  2059                          ;
  2060   000d0b c5              SETBIT:	PUSH	BC		;save 16 bit word.
  2061   000d0c 3a420b          	LD	A,(ACTIVE)	;get active drive.
  2062   000d0f 4f              	LD	C,A
  2063   000d10 210100          	LD	HL,1
  2064   000d13 cd040d          	CALL	SHIFTL		;shift bit 0 into place.
  2065   000d16 c1              	POP	BC		;now 'or' this with the original word.
  2066   000d17 79              	LD	A,C
  2067   000d18 b5              	OR	L
  2068   000d19 6f              	LD	L,A		;low byte done, do high byte.
  2069   000d1a 78              	LD	A,B
  2070   000d1b b4              	OR	H
  2071   000d1c 67              	LD	H,A
  2072   000d1d c9              	RET
  2073                          ;
  2074                          ;   Extract the write protect status bit for the current drive.
  2075                          ; The result is returned in (A), bit 0.
  2076                          ;
  2077   000d1e 2aad15          GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
  2078   000d21 3a420b          	LD	A,(ACTIVE)	;which drive is current?
  2079   000d24 4f              	LD	C,A
  2080   000d25 cdea0c          	CALL	SHIFTR		;shift status such that bit 0 is the
  2081   000d28 7d              	LD	A,L		;one of interest for this drive.
  2082   000d29 e601            	AND	01H		;and isolate it.
  2083   000d2b c9              	RET
  2084                          ;
  2085                          ;   Function to write protect the current disk.
  2086                          ;
  2087   000d2c 21ad15          WRTPRTD:LD	HL,WRTPRT	;point to status word.
  2088   000d2f 4e              	LD	C,(HL)		;set (BC) equal to the status.
  2089   000d30 23              	INC	HL
  2090   000d31 46              	LD	B,(HL)
  2091   000d32 cd0b0d          	CALL	SETBIT		;and set this bit according to current drive.
  2092   000d35 22ad15          	LD	(WRTPRT),HL	;then save.
  2093   000d38 2ac815          	LD	HL,(DIRSIZE)	;now save directory size limit.
  2094   000d3b 23              	INC	HL		;remember the last one.
  2095   000d3c eb              	EX	DE,HL
  2096   000d3d 2ab315          	LD	HL,(SCRATCH1)	;and store it here.
  2097   000d40 73              	LD	(HL),E		;put low byte.
  2098   000d41 23              	INC	HL
  2099   000d42 72              	LD	(HL),D		;then high byte.
  2100   000d43 c9              	RET
  2101                          ;
  2102                          ;   Check for a read only file.
  2103                          ;
  2104   000d44 cd5e0d          CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
  2105   000d47 110900          CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
  2106   000d4a 19              	ADD	HL,DE
  2107   000d4b 7e              	LD	A,(HL)
  2108   000d4c 17              	RLA
  2109   000d4d d0              	RET	NC		;return if ok.
  2110   000d4e 210f08          	LD	HL,ROFILE	;else, print error message and terminate.
  2111   000d51 c34a0b          	JP	JUMPHL
  2112                          ;
  2113                          ;   Check the write protect status of the active disk.
  2114                          ;
  2115   000d54 cd1e0d          CHKWPRT:CALL	GETWPRT
  2116   000d57 c8              	RET	Z		;return if ok.
  2117   000d58 210d08          	LD	HL,RODISK	;else print message and terminate.
  2118   000d5b c34a0b          	JP	JUMPHL
  2119                          ;
  2120                          ;   Routine to set (HL) pointing to the proper entry in the
  2121                          ; directory buffer.
  2122                          ;
  2123   000d5e 2ab915          FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
  2124   000d61 3ae915          	LD	A,(FCBPOS)	;relative position of file.
  2125                          ;
  2126                          ;   Routine to add (A) to (HL).
  2127                          ;
  2128   000d64 85              ADDA2HL:ADD	A,L
  2129   000d65 6f              	LD	L,A
  2130   000d66 d0              	RET	NC
  2131   000d67 24              	INC	H		;take care of any carry.
  2132   000d68 c9              	RET
  2133                          ;
  2134                          ;   Routine to get the 's2' byte from the fcb supplied in
  2135                          ; the initial parameter specification.
  2136                          ;
  2137   000d69 2a430b          GETS2:	LD	HL,(PARAMS)	;get address of fcb.
  2138   000d6c 110e00          	LD	DE,14		;relative position of 's2'.
  2139   000d6f 19              	ADD	HL,DE
  2140   000d70 7e              	LD	A,(HL)		;extract this byte.
  2141   000d71 c9              	RET
  2142                          ;
  2143                          ;   Clear the 's2' byte in the fcb.
  2144                          ;
  2145   000d72 cd690d          CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
  2146   000d75 3600            	LD	(HL),0		;now clear it.
  2147   000d77 c9              	RET
  2148                          ;
  2149                          ;   Set bit 7 in the 's2' byte of the fcb.
  2150                          ;
  2151   000d78 cd690d          SETS2B7:CALL	GETS2		;get the byte.
  2152   000d7b f680            	OR	80H		;and set bit 7.
  2153   000d7d 77              	LD	(HL),A		;then store.
  2154   000d7e c9              	RET
  2155                          ;
  2156                          ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
  2157                          ; the difference. This checks to see if there are more file
  2158                          ; names in the directory. We are at (FILEPOS) and there are
  2159                          ; (SCRATCH1) of them to check.
  2160                          ;
  2161   000d7f 2aea15          MOREFLS:LD	HL,(FILEPOS)	;we are here.
  2162   000d82 eb              	EX	DE,HL
  2163   000d83 2ab315          	LD	HL,(SCRATCH1)	;and don't go past here.
  2164   000d86 7b              	LD	A,E		;compute difference but don't keep.
  2165   000d87 96              	SUB	(HL)
  2166   000d88 23              	INC	HL
  2167   000d89 7a              	LD	A,D
  2168   000d8a 9e              	SBC	A,(HL)		;set carry if no more names.
  2169   000d8b c9              	RET
  2170                          ;
  2171                          ;   Call this routine to prevent (SCRATCH1) from being greater
  2172                          ; than (FILEPOS).
  2173                          ;
  2174   000d8c cd7f0d          CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
  2175   000d8f d8              	RET	C
  2176   000d90 13              	INC	DE		;yes, reset it to (FILEPOS).
  2177   000d91 72              	LD	(HL),D
  2178   000d92 2b              	DEC	HL
  2179   000d93 73              	LD	(HL),E
  2180   000d94 c9              	RET
  2181                          ;
  2182                          ;   Compute (HL)=(DE)-(HL)
  2183                          ;
  2184   000d95 7b              SUBHL:	LD	A,E		;compute difference.
  2185   000d96 95              	SUB	L
  2186   000d97 6f              	LD	L,A		;store low byte.
  2187   000d98 7a              	LD	A,D
  2188   000d99 9c              	SBC	A,H
  2189   000d9a 67              	LD	H,A		;and then high byte.
  2190   000d9b c9              	RET
  2191                          ;
  2192                          ;   Set the directory checksum byte.
  2193                          ;
  2194   000d9c 0eff            SETDIR:	LD	C,0FFH
  2195                          ;
  2196                          ;   Routine to set or compare the directory checksum byte. If
  2197                          ; (C)=0ffh, then this will set the checksum byte. Else the byte
  2198                          ; will be checked. If the check fails (the disk has been changed),
  2199                          ; then this disk will be write protected.
  2200                          ;
  2201   000d9e 2aec15          CHECKDIR: LD	HL,(CKSUMTBL)
  2202   000da1 eb              	EX	DE,HL
  2203   000da2 2acc15          	LD	HL,(ALLOC1)
  2204   000da5 cd950d          	CALL	SUBHL
  2205   000da8 d0              	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
  2206   000da9 c5              	PUSH	BC
  2207   000daa cdf70c          	CALL	CHECKSUM	;else compute checksum.
  2208   000dad 2abd15          	LD	HL,(CHKVECT)	;get address of checksum table.
  2209   000db0 eb              	EX	DE,HL
  2210   000db1 2aec15          	LD	HL,(CKSUMTBL)
  2211   000db4 19              	ADD	HL,DE		;set (HL) to point to byte for this drive.
  2212   000db5 c1              	POP	BC
  2213   000db6 0c              	INC	C		;set or check ?
  2214   000db7 cac40d          	JP	Z,CHKDIR1
  2215   000dba be              	CP	(HL)		;check them.
  2216   000dbb c8              	RET	Z		;return if they are the same.
  2217   000dbc cd7f0d          	CALL	MOREFLS		;not the same, do we care?
  2218   000dbf d0              	RET	NC
  2219   000dc0 cd2c0d          	CALL	WRTPRTD		;yes, mark this as write protected.
  2220   000dc3 c9              	RET
  2221   000dc4 77              CHKDIR1:LD	(HL),A		;just set the byte.
  2222   000dc5 c9              	RET
  2223                          ;
  2224                          ;   Do a write to the directory of the current disk.
  2225                          ;
  2226   000dc6 cd9c0d          DIRWRITE: CALL	SETDIR		;set checksum byte.
  2227   000dc9 cde00d          	CALL	DIRDMA		;set directory dma address.
  2228   000dcc 0e01            	LD	C,1		;tell the bios to actually write.
  2229   000dce cdb80b          	CALL	DOWRITE		;then do the write.
  2230   000dd1 c3da0d          	JP	DEFDMA
  2231                          ;
  2232                          ;   Read from the directory.
  2233                          ;
  2234   000dd4 cde00d          DIRREAD:CALL	DIRDMA		;set the directory dma address.
  2235   000dd7 cdb20b          	CALL	DOREAD		;and read it.
  2236                          ;
  2237                          ;   Routine to set the dma address to the users choice.
  2238                          ;
  2239   000dda 21b115          DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
  2240   000ddd c3e30d          	JP	DIRDMA1
  2241                          ;
  2242                          ;   Routine to set the dma address for directory work.
  2243                          ;
  2244   000de0 21b915          DIRDMA:	LD	HL,DIRBUF
  2245                          ;
  2246                          ;   Set the dma address. On entry, (HL) points to
  2247                          ; word containing the desired dma address.
  2248                          ;
  2249   000de3 4e              DIRDMA1:LD	C,(HL)
  2250   000de4 23              	INC	HL
  2251   000de5 46              	LD	B,(HL)		;setup (BC) and go to the bios to set it.
  2252   000de6 c32416          	JP	SETDMA
  2253                          ;
  2254                          ;   Move the directory buffer into user's dma space.
  2255                          ;
  2256   000de9 2ab915          MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
  2257   000dec eb              	EX	DE,HL
  2258   000ded 2ab115          	LD	HL,(USERDMA)	; put it here.
  2259   000df0 0e80            	LD	C,128		;this is its length.
  2260   000df2 c34f0b          	JP	DE2HL		;move it now and return.
  2261                          ;
  2262                          ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
  2263                          ;
  2264   000df5 21ea15          CKFILPOS: LD	HL,FILEPOS
  2265   000df8 7e              	LD	A,(HL)
  2266   000df9 23              	INC	HL
  2267   000dfa be              	CP	(HL)		;are both bytes the same?
  2268   000dfb c0              	RET	NZ
  2269   000dfc 3c              	INC	A		;yes, but are they each 0ffh?
  2270   000dfd c9              	RET
  2271                          ;
  2272                          ;   Set location (FILEPOS) to 0ffffh.
  2273                          ;
  2274   000dfe 21ffff          STFILPOS: LD	HL,0FFFFH
  2275   000e01 22ea15          	LD	(FILEPOS),HL
  2276   000e04 c9              	RET
  2277                          ;
  2278                          ;   Move on to the next file position within the current
  2279                          ; directory buffer. If no more exist, set pointer to 0ffffh
  2280                          ; and the calling routine will check for this. Enter with (C)
  2281                          ; equal to 0ffh to cause the checksum byte to be set, else we
  2282                          ; will check this disk and set write protect if checksums are
  2283                          ; not the same (applies only if another directory sector must
  2284                          ; be read).
  2285                          ;
  2286   000e05 2ac815          NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
  2287   000e08 eb              	EX	DE,HL
  2288   000e09 2aea15          	LD	HL,(FILEPOS)	;get current count.
  2289   000e0c 23              	INC	HL		;go on to the next one.
  2290   000e0d 22ea15          	LD	(FILEPOS),HL
  2291   000e10 cd950d          	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
  2292   000e13 d2190e          	JP	NC,NXENT1	;is there more room left?
  2293   000e16 c3fe0d          	JP	STFILPOS	;no. Set this flag and return.
  2294   000e19 3aea15          NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
  2295   000e1c e603            	AND	03H		;only look within this sector (only 4 entries fit).
  2296   000e1e 0605            	LD	B,5		;convert to relative position (32 bytes each).
  2297   000e20 87              NXENT2:	ADD	A,A		;note that this is not efficient code.
  2298   000e21 05              	DEC	B		;5 'ADD A's would be better.
  2299   000e22 c2200e          	JP	NZ,NXENT2
  2300   000e25 32e915          	LD	(FCBPOS),A	;save it as position of fcb.
  2301   000e28 b7              	OR	A
  2302   000e29 c0              	RET	NZ		;return if we are within buffer.
  2303   000e2a c5              	PUSH	BC
  2304   000e2b cdc30b          	CALL	TRKSEC		;we need the next directory sector.
  2305   000e2e cdd40d          	CALL	DIRREAD
  2306   000e31 c1              	POP	BC
  2307   000e32 c39e0d          	JP	CHECKDIR
  2308                          ;
  2309                          ;   Routine to to get a bit from the disk space allocation
  2310                          ; map. It is returned in (A), bit position 0. On entry to here,
  2311                          ; set (BC) to the block number on the disk to check.
  2312                          ; On return, (D) will contain the original bit position for
  2313                          ; this block number and (HL) will point to the address for it.
  2314                          ;
  2315   000e35 79              CKBITMAP: LD	A,C		;determine bit number of interest.
  2316   000e36 e607            	AND	07H		;compute (D)=(E)=(C and 7)+1.
  2317   000e38 3c              	INC	A
  2318   000e39 5f              	LD	E,A		;save particular bit number.
  2319   000e3a 57              	LD	D,A
  2320                          ;
  2321                          ;   compute (BC)=(BC)/8.
  2322                          ;
  2323   000e3b 79              	LD	A,C
  2324   000e3c 0f              	RRCA			;now shift right 3 bits.
  2325   000e3d 0f              	RRCA
  2326   000e3e 0f              	RRCA
  2327   000e3f e61f            	AND	1FH		;and clear bits 7,6,5.
  2328   000e41 4f              	LD	C,A
  2329   000e42 78              	LD	A,B
  2330   000e43 87              	ADD	A,A		;now shift (B) into bits 7,6,5.
  2331   000e44 87              	ADD	A,A
  2332   000e45 87              	ADD	A,A
  2333   000e46 87              	ADD	A,A
  2334   000e47 87              	ADD	A,A
  2335   000e48 b1              	OR	C		;and add in (C).
  2336   000e49 4f              	LD	C,A		;ok, (C) ha been completed.
  2337   000e4a 78              	LD	A,B		;is there a better way of doing this?
  2338   000e4b 0f              	RRCA
  2339   000e4c 0f              	RRCA
  2340   000e4d 0f              	RRCA
  2341   000e4e e61f            	AND	1FH
  2342   000e50 47              	LD	B,A		;and now (B) is completed.
  2343                          ;
  2344                          ;   use this as an offset into the disk space allocation
  2345                          ; table.
  2346                          ;
  2347   000e51 2abf15          	LD	HL,(ALOCVECT)
  2348   000e54 09              	ADD	HL,BC
  2349   000e55 7e              	LD	A,(HL)		;now get correct byte.
  2350   000e56 07              CKBMAP1:RLCA			;get correct bit into position 0.
  2351   000e57 1d              	DEC	E
  2352   000e58 c2560e          	JP	NZ,CKBMAP1
  2353   000e5b c9              	RET
  2354                          ;
  2355                          ;   Set or clear the bit map such that block number (BC) will be marked
  2356                          ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
  2357                          ; 1 then it will be set (don't use anyother values).
  2358                          ;
  2359   000e5c d5              STBITMAP: PUSH	DE
  2360   000e5d cd350e          	CALL	CKBITMAP	;get the byte of interest.
  2361   000e60 e6fe            	AND	0FEH		;clear the affected bit.
  2362   000e62 c1              	POP	BC
  2363   000e63 b1              	OR	C		;and now set it acording to (C).
  2364                          ;
  2365                          ;  entry to restore the original bit position and then store
  2366                          ; in table. (A) contains the value, (D) contains the bit
  2367                          ; position (1-8), and (HL) points to the address within the
  2368                          ; space allocation table for this byte.
  2369                          ;
  2370   000e64 0f              STBMAP1:RRCA			;restore original bit position.
  2371   000e65 15              	DEC	D
  2372   000e66 c2640e          	JP	NZ,STBMAP1
  2373   000e69 77              	LD	(HL),A		;and stor byte in table.
  2374   000e6a c9              	RET
  2375                          ;
  2376                          ;   Set/clear space used bits in allocation map for this file.
  2377                          ; On entry, (C)=1 to set the map and (C)=0 to clear it.
  2378                          ;
  2379   000e6b cd5e0d          SETFILE:CALL	FCB2HL		;get address of fcb
  2380   000e6e 111000          	LD	DE,16
  2381   000e71 19              	ADD	HL,DE		;get to block number bytes.
  2382   000e72 c5              	PUSH	BC
  2383   000e73 0e11            	LD	C,17		;check all 17 bytes (max) of table.
  2384   000e75 d1              SETFL1:	POP	DE
  2385   000e76 0d              	DEC	C		;done all bytes yet?
  2386   000e77 c8              	RET	Z
  2387   000e78 d5              	PUSH	DE
  2388   000e79 3add15          	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
  2389   000e7c b7              	OR	A
  2390   000e7d ca880e          	JP	Z,SETFL2
  2391   000e80 c5              	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
  2392   000e81 e5              	PUSH	HL
  2393   000e82 4e              	LD	C,(HL)		;get low byte from table, always
  2394   000e83 0600            	LD	B,0		;set high byte to zero.
  2395   000e85 c38e0e          	JP	SETFL3
  2396   000e88 0d              SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
  2397   000e89 c5              	PUSH	BC
  2398   000e8a 4e              	LD	C,(HL)		;now get both the low and high bytes.
  2399   000e8b 23              	INC	HL
  2400   000e8c 46              	LD	B,(HL)
  2401   000e8d e5              	PUSH	HL
  2402   000e8e 79              SETFL3:	LD	A,C		;block used?
  2403   000e8f b0              	OR	B
  2404   000e90 ca9d0e          	JP	Z,SETFL4
  2405   000e93 2ac615          	LD	HL,(DSKSIZE)	;is this block number within the
  2406   000e96 7d              	LD	A,L		;space on the disk?
  2407   000e97 91              	SUB	C
  2408   000e98 7c              	LD	A,H
  2409   000e99 98              	SBC	A,B
  2410   000e9a d45c0e          	CALL	NC,STBITMAP	;yes, set the proper bit.
  2411   000e9d e1              SETFL4:	POP	HL		;point to next block number in fcb.
  2412   000e9e 23              	INC	HL
  2413   000e9f c1              	POP	BC
  2414   000ea0 c3750e          	JP	SETFL1
  2415                          ;
  2416                          ;   Construct the space used allocation bit map for the active
  2417                          ; drive. If a file name starts with '$' and it is under the
  2418                          ; current user number, then (STATUS) is set to minus 1. Otherwise
  2419                          ; it is not set at all.
  2420                          ;
  2421   000ea3 2ac615          BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
  2422   000ea6 0e03            	LD	C,3
  2423   000ea8 cdea0c          	CALL	SHIFTR		;(HL)=(HL)/8.
  2424   000eab 23              	INC	HL		;at lease 1 byte.
  2425   000eac 44              	LD	B,H
  2426   000ead 4d              	LD	C,L		;set (BC) to the allocation table length.
  2427                          ;
  2428                          ;   Initialize the bitmap for this drive. Right now, the first
  2429                          ; two bytes are specified by the disk parameter block. However
  2430                          ; a patch could be entered here if it were necessary to setup
  2431                          ; this table in a special mannor. For example, the bios could
  2432                          ; determine locations of 'bad blocks' and set them as already
  2433                          ; 'used' in the map.
  2434                          ;
  2435   000eae 2abf15          	LD	HL,(ALOCVECT)	;now zero out the table now.
  2436   000eb1 3600            BITMAP1:LD	(HL),0
  2437   000eb3 23              	INC	HL
  2438   000eb4 0b              	DEC	BC
  2439   000eb5 78              	LD	A,B
  2440   000eb6 b1              	OR	C
  2441   000eb7 c2b10e          	JP	NZ,BITMAP1
  2442   000eba 2aca15          	LD	HL,(ALLOC0)	;get initial space used by directory.
  2443   000ebd eb              	EX	DE,HL
  2444   000ebe 2abf15          	LD	HL,(ALOCVECT)	;and put this into map.
  2445   000ec1 73              	LD	(HL),E
  2446   000ec2 23              	INC	HL
  2447   000ec3 72              	LD	(HL),D
  2448                          ;
  2449                          ;   End of initialization portion.
  2450                          ;
  2451   000ec4 cda10b          	CALL	HOMEDRV		;now home the drive.
  2452   000ec7 2ab315          	LD	HL,(SCRATCH1)
  2453   000eca 3603            	LD	(HL),3		;force next directory request to read
  2454   000ecc 23              	INC	HL		;in a sector.
  2455   000ecd 3600            	LD	(HL),0
  2456   000ecf cdfe0d          	CALL	STFILPOS	;clear initial file position also.
  2457   000ed2 0eff            BITMAP2:LD	C,0FFH		;read next file name in directory
  2458   000ed4 cd050e          	CALL	NXENTRY		;and set checksum byte.
  2459   000ed7 cdf50d          	CALL	CKFILPOS	;is there another file?
  2460   000eda c8              	RET	Z
  2461   000edb cd5e0d          	CALL	FCB2HL		;yes, get its address.
  2462   000ede 3ee5            	LD	A,0E5H
  2463   000ee0 be              	CP	(HL)		;empty file entry?
  2464   000ee1 cad20e          	JP	Z,BITMAP2
  2465   000ee4 3a410b          	LD	A,(USERNO)	;no, correct user number?
  2466   000ee7 be              	CP	(HL)
  2467   000ee8 c2f60e          	JP	NZ,BITMAP3
  2468   000eeb 23              	INC	HL
  2469   000eec 7e              	LD	A,(HL)		;yes, does name start with a '$'?
  2470   000eed d624            	SUB	'$'
  2471   000eef c2f60e          	JP	NZ,BITMAP3
  2472   000ef2 3d              	DEC	A		;yes, set atatus to minus one.
  2473   000ef3 32450b          	LD	(STATUS),A
  2474   000ef6 0e01            BITMAP3:LD	C,1		;now set this file's space as used in bit map.
  2475   000ef8 cd6b0e          	CALL	SETFILE
  2476   000efb cd8c0d          	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
  2477   000efe c3d20e          	JP	BITMAP2
  2478                          ;
  2479                          ;   Set the status (STATUS) and return.
  2480                          ;
  2481   000f01 3ad415          STSTATUS: LD	A,(FNDSTAT)
  2482   000f04 c3010b          	JP	SETSTAT
  2483                          ;
  2484                          ;   Check extents in (A) and (C). Set the zero flag if they
  2485                          ; are the same. The number of 16k chunks of disk space that
  2486                          ; the directory extent covers is expressad is (EXTMASK+1).
  2487                          ; No registers are modified.
  2488                          ;
  2489   000f07 c5              SAMEXT:	PUSH	BC
  2490   000f08 f5              	PUSH	AF
  2491   000f09 3ac515          	LD	A,(EXTMASK)	;get extent mask and use it to
  2492   000f0c 2f              	CPL			;to compare both extent numbers.
  2493   000f0d 47              	LD	B,A		;save resulting mask here.
  2494   000f0e 79              	LD	A,C		;mask first extent and save in (C).
  2495   000f0f a0              	AND	B
  2496   000f10 4f              	LD	C,A
  2497   000f11 f1              	POP	AF		;now mask second extent and compare
  2498   000f12 a0              	AND	B		;with the first one.
  2499   000f13 91              	SUB	C
  2500   000f14 e61f            	AND	1FH		;(* only check buts 0-4 *)
  2501   000f16 c1              	POP	BC		;the zero flag is set if they are the same.
  2502   000f17 c9              	RET			;restore (BC) and return.
  2503                          ;
  2504                          ;   Search for the first occurence of a file name. On entry,
  2505                          ; register (C) should contain the number of bytes of the fcb
  2506                          ; that must match.
  2507                          ;
  2508   000f18 3eff            FINDFST:LD	A,0FFH
  2509   000f1a 32d415          	LD	(FNDSTAT),A
  2510   000f1d 21d815          	LD	HL,COUNTER	;save character count.
  2511   000f20 71              	LD	(HL),C
  2512   000f21 2a430b          	LD	HL,(PARAMS)	;get filename to match.
  2513   000f24 22d915          	LD	(SAVEFCB),HL	;and save.
  2514   000f27 cdfe0d          	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
  2515   000f2a cda10b          	CALL	HOMEDRV		;home the drive.
  2516                          ;
  2517                          ;   Entry to locate the next occurence of a filename within the
  2518                          ; directory. The disk is not expected to have been changed. If
  2519                          ; it was, then it will be write protected.
  2520                          ;
  2521   000f2d 0e00            FINDNXT:LD	C,0		;write protect the disk if changed.
  2522   000f2f cd050e          	CALL	NXENTRY		;get next filename entry in directory.
  2523   000f32 cdf50d          	CALL	CKFILPOS	;is file position = 0ffffh?
  2524   000f35 ca940f          	JP	Z,FNDNXT6	;yes, exit now then.
  2525   000f38 2ad915          	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
  2526   000f3b eb              	EX	DE,HL
  2527   000f3c 1a              	LD	A,(DE)
  2528   000f3d fee5            	CP	0E5H		;empty directory entry?
  2529   000f3f ca4a0f          	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
  2530   000f42 d5              	PUSH	DE
  2531   000f43 cd7f0d          	CALL	MOREFLS		;more files in directory?
  2532   000f46 d1              	POP	DE
  2533   000f47 d2940f          	JP	NC,FNDNXT6	;no more. Exit now.
  2534   000f4a cd5e0d          FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
  2535   000f4d 3ad815          	LD	A,(COUNTER)	;get number of bytes (characters) to check.
  2536   000f50 4f              	LD	C,A
  2537   000f51 0600            	LD	B,0		;initialize byte position counter.
  2538   000f53 79              FNDNXT2:LD	A,C		;are we done with the compare?
  2539   000f54 b7              	OR	A
  2540   000f55 ca830f          	JP	Z,FNDNXT5
  2541   000f58 1a              	LD	A,(DE)		;no, check next byte.
  2542   000f59 fe3f            	CP	'?'		;don't care about this character?
  2543   000f5b ca7c0f          	JP	Z,FNDNXT4
  2544   000f5e 78              	LD	A,B		;get bytes position in fcb.
  2545   000f5f fe0d            	CP	13		;don't care about the thirteenth byte either.
  2546   000f61 ca7c0f          	JP	Z,FNDNXT4
  2547   000f64 fe0c            	CP	12		;extent byte?
  2548   000f66 1a              	LD	A,(DE)
  2549   000f67 ca730f          	JP	Z,FNDNXT3
  2550   000f6a 96              	SUB	(HL)		;otherwise compare characters.
  2551   000f6b e67f            	AND	7FH
  2552   000f6d c22d0f          	JP	NZ,FINDNXT	;not the same, check next entry.
  2553   000f70 c37c0f          	JP	FNDNXT4		;so far so good, keep checking.
  2554   000f73 c5              FNDNXT3:PUSH	BC		;check the extent byte here.
  2555   000f74 4e              	LD	C,(HL)
  2556   000f75 cd070f          	CALL	SAMEXT
  2557   000f78 c1              	POP	BC
  2558   000f79 c22d0f          	JP	NZ,FINDNXT	;not the same, look some more.
  2559                          ;
  2560                          ;   So far the names compare. Bump pointers to the next byte
  2561                          ; and continue until all (C) characters have been checked.
  2562                          ;
  2563   000f7c 13              FNDNXT4:INC	DE		;bump pointers.
  2564   000f7d 23              	INC	HL
  2565   000f7e 04              	INC	B
  2566   000f7f 0d              	DEC	C		;adjust character counter.
  2567   000f80 c3530f          	JP	FNDNXT2
  2568   000f83 3aea15          FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
  2569   000f86 e603            	AND	03H
  2570   000f88 32450b          	LD	(STATUS),A
  2571   000f8b 21d415          	LD	HL,FNDSTAT
  2572   000f8e 7e              	LD	A,(HL)
  2573   000f8f 17              	RLA
  2574   000f90 d0              	RET	NC
  2575   000f91 af              	XOR	A
  2576   000f92 77              	LD	(HL),A
  2577   000f93 c9              	RET
  2578                          ;
  2579                          ;   Filename was not found. Set appropriate status.
  2580                          ;
  2581   000f94 cdfe0d          FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
  2582   000f97 3eff            	LD	A,0FFH		;say not located.
  2583   000f99 c3010b          	JP	SETSTAT
  2584                          ;
  2585                          ;   Erase files from the directory. Only the first byte of the
  2586                          ; fcb will be affected. It is set to (E5).
  2587                          ;
  2588   000f9c cd540d          ERAFILE:CALL	CHKWPRT		;is disk write protected?
  2589   000f9f 0e0c            	LD	C,12		;only compare file names.
  2590   000fa1 cd180f          	CALL	FINDFST		;get first file name.
  2591   000fa4 cdf50d          ERAFIL1:CALL	CKFILPOS	;any found?
  2592   000fa7 c8              	RET	Z		;nope, we must be done.
  2593   000fa8 cd440d          	CALL	CHKROFL		;is file read only?
  2594   000fab cd5e0d          	CALL	FCB2HL		;nope, get address of fcb and
  2595   000fae 36e5            	LD	(HL),0E5H	;set first byte to 'empty'.
  2596   000fb0 0e00            	LD	C,0		;clear the space from the bit map.
  2597   000fb2 cd6b0e          	CALL	SETFILE
  2598   000fb5 cdc60d          	CALL	DIRWRITE	;now write the directory sector back out.
  2599   000fb8 cd2d0f          	CALL	FINDNXT		;find the next file name.
  2600   000fbb c3a40f          	JP	ERAFIL1		;and repeat process.
  2601                          ;
  2602                          ;   Look through the space allocation map (bit map) for the
  2603                          ; next available block. Start searching at block number (BC-1).
  2604                          ; The search procedure is to look for an empty block that is
  2605                          ; before the starting block. If not empty, look at a later
  2606                          ; block number. In this way, we return the closest empty block
  2607                          ; on either side of the 'target' block number. This will speed
  2608                          ; access on random devices. For serial devices, this should be
  2609                          ; changed to look in the forward direction first and then start
  2610                          ; at the front and search some more.
  2611                          ;
  2612                          ;   On return, (DE)= block number that is empty and (HL) =0
  2613                          ; if no empry block was found.
  2614                          ;
  2615   000fbe 50              FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
  2616   000fbf 59              	LD	E,C
  2617                          ;
  2618                          ;   Look before target block. Registers (BC) are used as the lower
  2619                          ; pointer and (DE) as the upper pointer.
  2620                          ;
  2621   000fc0 79              FNDSPA1:LD	A,C		;is block 0 specified?
  2622   000fc1 b0              	OR	B
  2623   000fc2 cad10f          	JP	Z,FNDSPA2
  2624   000fc5 0b              	DEC	BC		;nope, check previous block.
  2625   000fc6 d5              	PUSH	DE
  2626   000fc7 c5              	PUSH	BC
  2627   000fc8 cd350e          	CALL	CKBITMAP
  2628   000fcb 1f              	RRA			;is this block empty?
  2629   000fcc d2ec0f          	JP	NC,FNDSPA3	;yes. use this.
  2630                          ;
  2631                          ;   Note that the above logic gets the first block that it finds
  2632                          ; that is empty. Thus a file could be written 'backward' making
  2633                          ; it very slow to access. This could be changed to look for the
  2634                          ; first empty block and then continue until the start of this
  2635                          ; empty space is located and then used that starting block.
  2636                          ; This should help speed up access to some files especially on
  2637                          ; a well used disk with lots of fairly small 'holes'.
  2638                          ;
  2639   000fcf c1              	POP	BC		;nope, check some more.
  2640   000fd0 d1              	POP	DE
  2641                          ;
  2642                          ;   Now look after target block.
  2643                          ;
  2644   000fd1 2ac615          FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
  2645   000fd4 7b              	LD	A,E
  2646   000fd5 95              	SUB	L
  2647   000fd6 7a              	LD	A,D
  2648   000fd7 9c              	SBC	A,H
  2649   000fd8 d2f40f          	JP	NC,FNDSPA4
  2650   000fdb 13              	INC	DE		;yes, move on to next one.
  2651   000fdc c5              	PUSH	BC
  2652   000fdd d5              	PUSH	DE
  2653   000fde 42              	LD	B,D
  2654   000fdf 4b              	LD	C,E
  2655   000fe0 cd350e          	CALL	CKBITMAP	;check it.
  2656   000fe3 1f              	RRA			;empty?
  2657   000fe4 d2ec0f          	JP	NC,FNDSPA3
  2658   000fe7 d1              	POP	DE		;nope, continue searching.
  2659   000fe8 c1              	POP	BC
  2660   000fe9 c3c00f          	JP	FNDSPA1
  2661                          ;
  2662                          ;   Empty block found. Set it as used and return with (HL)
  2663                          ; pointing to it (true?).
  2664                          ;
  2665   000fec 17              FNDSPA3:RLA			;reset byte.
  2666   000fed 3c              	INC	A		;and set bit 0.
  2667   000fee cd640e          	CALL	STBMAP1		;update bit map.
  2668   000ff1 e1              	POP	HL		;set return registers.
  2669   000ff2 d1              	POP	DE
  2670   000ff3 c9              	RET
  2671                          ;
  2672                          ;   Free block was not found. If (BC) is not zero, then we have
  2673                          ; not checked all of the disk space.
  2674                          ;
  2675   000ff4 79              FNDSPA4:LD	A,C
  2676   000ff5 b0              	OR	B
  2677   000ff6 c2c00f          	JP	NZ,FNDSPA1
  2678   000ff9 210000          	LD	HL,0		;set 'not found' status.
  2679   000ffc c9              	RET
  2680                          ;
  2681                          ;   Move a complete fcb entry into the directory and write it.
  2682                          ;
  2683   000ffd 0e00            FCBSET:	LD	C,0
  2684   000fff 1e20            	LD	E,32		;length of each entry.
  2685                          ;
  2686                          ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
  2687                          ; fcb in directory starting at relative byte (C). This updated
  2688                          ; directory buffer is then written to the disk.
  2689                          ;
  2690   001001 d5              UPDATE:	PUSH	DE
  2691   001002 0600            	LD	B,0		;set (BC) to relative byte position.
  2692   001004 2a430b          	LD	HL,(PARAMS)	;get address of fcb.
  2693   001007 09              	ADD	HL,BC		;compute starting byte.
  2694   001008 eb              	EX	DE,HL
  2695   001009 cd5e0d          	CALL	FCB2HL		;get address of fcb to update in directory.
  2696   00100c c1              	POP	BC		;set (C) to number of bytes to change.
  2697   00100d cd4f0b          	CALL	DE2HL
  2698   001010 cdc30b          UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
  2699   001013 c3c60d          	JP	DIRWRITE	;then write this sector out.
  2700                          ;
  2701                          ;   Routine to change the name of all files on the disk with a
  2702                          ; specified name. The fcb contains the current name as the
  2703                          ; first 12 characters and the new name 16 bytes into the fcb.
  2704                          ;
  2705   001016 cd540d          CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
  2706   001019 0e0c            	LD	C,12		;match first 12 bytes of fcb only.
  2707   00101b cd180f          	CALL	FINDFST		;get first name.
  2708   00101e 2a430b          	LD	HL,(PARAMS)	;get address of fcb.
  2709   001021 7e              	LD	A,(HL)		;get user number.
  2710   001022 111000          	LD	DE,16		;move over to desired name.
  2711   001025 19              	ADD	HL,DE
  2712   001026 77              	LD	(HL),A		;keep same user number.
  2713   001027 cdf50d          CHGNAM1:CALL	CKFILPOS	;any matching file found?
  2714   00102a c8              	RET	Z		;no, we must be done.
  2715   00102b cd440d          	CALL	CHKROFL		;check for read only file.
  2716   00102e 0e10            	LD	C,16		;start 16 bytes into fcb.
  2717   001030 1e0c            	LD	E,12		;and update the first 12 bytes of directory.
  2718   001032 cd0110          	CALL	UPDATE
  2719   001035 cd2d0f          	CALL	FINDNXT		;get te next file name.
  2720   001038 c32710          	JP	CHGNAM1		;and continue.
  2721                          ;
  2722                          ;   Update a files attributes. The procedure is to search for
  2723                          ; every file with the same name as shown in fcb (ignoring bit 7)
  2724                          ; and then to update it (which includes bit 7). No other changes
  2725                          ; are made.
  2726                          ;
  2727   00103b 0e0c            SAVEATTR: LD	C,12		;match first 12 bytes.
  2728   00103d cd180f          	CALL	FINDFST		;look for first filename.
  2729   001040 cdf50d          SAVATR1:CALL	CKFILPOS	;was one found?
  2730   001043 c8              	RET	Z		;nope, we must be done.
  2731   001044 0e00            	LD	C,0		;yes, update the first 12 bytes now.
  2732   001046 1e0c            	LD	E,12
  2733   001048 cd0110          	CALL	UPDATE		;update filename and write directory.
  2734   00104b cd2d0f          	CALL	FINDNXT		;and get the next file.
  2735   00104e c34010          	JP	SAVATR1		;then continue until done.
  2736                          ;
  2737                          ;  Open a file (name specified in fcb).
  2738                          ;
  2739   001051 0e0f            OPENIT:	LD	C,15		;compare the first 15 bytes.
  2740   001053 cd180f          	CALL	FINDFST		;get the first one in directory.
  2741   001056 cdf50d          	CALL	CKFILPOS	;any at all?
  2742   001059 c8              	RET	Z
  2743   00105a cda60c          OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
  2744   00105d 7e              	LD	A,(HL)		;and get it.
  2745   00105e f5              	PUSH	AF		;save it and address.
  2746   00105f e5              	PUSH	HL
  2747   001060 cd5e0d          	CALL	FCB2HL		;point to fcb in directory.
  2748   001063 eb              	EX	DE,HL
  2749   001064 2a430b          	LD	HL,(PARAMS)	;this is the users copy.
  2750   001067 0e20            	LD	C,32		;move it into users space.
  2751   001069 d5              	PUSH	DE
  2752   00106a cd4f0b          	CALL	DE2HL
  2753   00106d cd780d          	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
  2754   001070 d1              	POP	DE		;now get the extent byte from this fcb.
  2755   001071 210c00          	LD	HL,12
  2756   001074 19              	ADD	HL,DE
  2757   001075 4e              	LD	C,(HL)		;into (C).
  2758   001076 210f00          	LD	HL,15		;now get the record count byte into (B).
  2759   001079 19              	ADD	HL,DE
  2760   00107a 46              	LD	B,(HL)
  2761   00107b e1              	POP	HL		;keep the same extent as the user had originally.
  2762   00107c f1              	POP	AF
  2763   00107d 77              	LD	(HL),A
  2764   00107e 79              	LD	A,C		;is it the same as in the directory fcb?
  2765   00107f be              	CP	(HL)
  2766   001080 78              	LD	A,B		;if yes, then use the same record count.
  2767   001081 ca8b10          	JP	Z,OPENIT2
  2768   001084 3e00            	LD	A,0		;if the user specified an extent greater than
  2769   001086 da8b10          	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
  2770   001089 3e80            	LD	A,128		;otherwise set to maximum.
  2771   00108b 2a430b          OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
  2772   00108e 110f00          	LD	DE,15
  2773   001091 19              	ADD	HL,DE		;compute relative position.
  2774   001092 77              	LD	(HL),A		;and set the record count.
  2775   001093 c9              	RET
  2776                          ;
  2777                          ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
  2778                          ; point to a zero value (16 bit).
  2779                          ;   Return with zero flag set it (DE) was moved. Registers (DE)
  2780                          ; and (HL) are not changed. However (A) is.
  2781                          ;
  2782   001094 7e              MOVEWORD: LD	A,(HL)		;check for a zero word.
  2783   001095 23              	INC	HL
  2784   001096 b6              	OR	(HL)		;both bytes zero?
  2785   001097 2b              	DEC	HL
  2786   001098 c0              	RET	NZ		;nope, just return.
  2787   001099 1a              	LD	A,(DE)		;yes, move two bytes from (DE) into
  2788   00109a 77              	LD	(HL),A		;this zero space.
  2789   00109b 13              	INC	DE
  2790   00109c 23              	INC	HL
  2791   00109d 1a              	LD	A,(DE)
  2792   00109e 77              	LD	(HL),A
  2793   00109f 1b              	DEC	DE		;don't disturb these registers.
  2794   0010a0 2b              	DEC	HL
  2795   0010a1 c9              	RET
  2796                          ;
  2797                          ;   Get here to close a file specified by (fcb).
  2798                          ;
  2799   0010a2 af              CLOSEIT:XOR	A		;clear status and file position bytes.
  2800   0010a3 32450b          	LD	(STATUS),A
  2801   0010a6 32ea15          	LD	(FILEPOS),A
  2802   0010a9 32eb15          	LD	(FILEPOS+1),A
  2803   0010ac cd1e0d          	CALL	GETWPRT		;get write protect bit for this drive.
  2804   0010af c0              	RET	NZ		;just return if it is set.
  2805   0010b0 cd690d          	CALL	GETS2		;else get the 's2' byte.
  2806   0010b3 e680            	AND	80H		;and look at bit 7 (file unmodified?).
  2807   0010b5 c0              	RET	NZ		;just return if set.
  2808   0010b6 0e0f            	LD	C,15		;else look up this file in directory.
  2809   0010b8 cd180f          	CALL	FINDFST
  2810   0010bb cdf50d          	CALL	CKFILPOS	;was it found?
  2811   0010be c8              	RET	Z		;just return if not.
  2812   0010bf 011000          	LD	BC,16		;set (HL) pointing to records used section.
  2813   0010c2 cd5e0d          	CALL	FCB2HL
  2814   0010c5 09              	ADD	HL,BC
  2815   0010c6 eb              	EX	DE,HL
  2816   0010c7 2a430b          	LD	HL,(PARAMS)	;do the same for users specified fcb.
  2817   0010ca 09              	ADD	HL,BC
  2818   0010cb 0e10            	LD	C,16		;this many bytes are present in this extent.
  2819   0010cd 3add15          CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
  2820   0010d0 b7              	OR	A
  2821   0010d1 cae810          	JP	Z,CLOSEIT4
  2822   0010d4 7e              	LD	A,(HL)		;just 8 bit. Get one from users fcb.
  2823   0010d5 b7              	OR	A
  2824   0010d6 1a              	LD	A,(DE)		;now get one from directory fcb.
  2825   0010d7 c2db10          	JP	NZ,CLOSEIT2
  2826   0010da 77              	LD	(HL),A		;users byte was zero. Update from directory.
  2827   0010db b7              CLOSEIT2: OR	A
  2828   0010dc c2e110          	JP	NZ,CLOSEIT3
  2829   0010df 7e              	LD	A,(HL)		;directories byte was zero, update from users fcb.
  2830   0010e0 12              	LD	(DE),A
  2831   0010e1 be              CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
  2832   0010e2 c21f11          	JP	NZ,CLOSEIT7	;then close error if they are not the same.
  2833   0010e5 c3fd10          	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
  2834   0010e8 cd9410          CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
  2835   0010eb eb              	EX	DE,HL
  2836   0010ec cd9410          	CALL	MOVEWORD	;update directories fcb if it is zero.
  2837   0010ef eb              	EX	DE,HL
  2838   0010f0 1a              	LD	A,(DE)		;if these two values are no different,
  2839   0010f1 be              	CP	(HL)		;then a close error occured.
  2840   0010f2 c21f11          	JP	NZ,CLOSEIT7
  2841   0010f5 13              	INC	DE		;check second byte.
  2842   0010f6 23              	INC	HL
  2843   0010f7 1a              	LD	A,(DE)
  2844   0010f8 be              	CP	(HL)
  2845   0010f9 c21f11          	JP	NZ,CLOSEIT7
  2846   0010fc 0d              	DEC	C		;remember 16 bit values.
  2847   0010fd 13              CLOSEIT5: INC	DE		;bump to next item in table.
  2848   0010fe 23              	INC	HL
  2849   0010ff 0d              	DEC	C		;there are 16 entries only.
  2850   001100 c2cd10          	JP	NZ,CLOSEIT1	;continue if more to do.
  2851   001103 01ecff          	LD	BC,0FFECH	;backup 20 places (extent byte).
  2852   001106 09              	ADD	HL,BC
  2853   001107 eb              	EX	DE,HL
  2854   001108 09              	ADD	HL,BC
  2855   001109 1a              	LD	A,(DE)
  2856   00110a be              	CP	(HL)		;directory's extent already greater than the
  2857   00110b da1711          	JP	C,CLOSEIT6	;users extent?
  2858   00110e 77              	LD	(HL),A		;no, update directory extent.
  2859   00110f 010300          	LD	BC,3		;and update the record count byte in
  2860   001112 09              	ADD	HL,BC		;directories fcb.
  2861   001113 eb              	EX	DE,HL
  2862   001114 09              	ADD	HL,BC
  2863   001115 7e              	LD	A,(HL)		;get from user.
  2864   001116 12              	LD	(DE),A		;and put in directory.
  2865   001117 3eff            CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
  2866   001119 32d215          	LD	(CLOSEFLG),A
  2867   00111c c31010          	JP	UPDATE1		;update the directory now.
  2868   00111f 21450b          CLOSEIT7: LD	HL,STATUS	;set return status and then return.
  2869   001122 35              	DEC	(HL)
  2870   001123 c9              	RET
  2871                          ;
  2872                          ;   Routine to get the next empty space in the directory. It
  2873                          ; will then be cleared for use.
  2874                          ;
  2875   001124 cd540d          GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
  2876   001127 2a430b          	LD	HL,(PARAMS)	;save current parameters (fcb).
  2877   00112a e5              	PUSH	HL
  2878   00112b 21ac15          	LD	HL,EMPTYFCB	;use special one for empty space.
  2879   00112e 22430b          	LD	(PARAMS),HL
  2880   001131 0e01            	LD	C,1		;search for first empty spot in directory.
  2881   001133 cd180f          	CALL	FINDFST		;(* only check first byte *)
  2882   001136 cdf50d          	CALL	CKFILPOS	;none?
  2883   001139 e1              	POP	HL
  2884   00113a 22430b          	LD	(PARAMS),HL	;restore original fcb address.
  2885   00113d c8              	RET	Z		;return if no more space.
  2886   00113e eb              	EX	DE,HL
  2887   00113f 210f00          	LD	HL,15		;point to number of records for this file.
  2888   001142 19              	ADD	HL,DE
  2889   001143 0e11            	LD	C,17		;and clear all of this space.
  2890   001145 af              	XOR	A
  2891   001146 77              GETMT1:	LD	(HL),A
  2892   001147 23              	INC	HL
  2893   001148 0d              	DEC	C
  2894   001149 c24611          	JP	NZ,GETMT1
  2895   00114c 210d00          	LD	HL,13		;clear the 's1' byte also.
  2896   00114f 19              	ADD	HL,DE
  2897   001150 77              	LD	(HL),A
  2898   001151 cd8c0d          	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
  2899   001154 cdfd0f          	CALL	FCBSET		;write out this fcb entry to directory.
  2900   001157 c3780d          	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
  2901                          ;
  2902                          ;   Routine to close the current extent and open the next one
  2903                          ; for reading.
  2904                          ;
  2905   00115a af              GETNEXT:XOR	A
  2906   00115b 32d215          	LD	(CLOSEFLG),A	;clear close flag.
  2907   00115e cda210          	CALL	CLOSEIT		;close this extent.
  2908   001161 cdf50d          	CALL	CKFILPOS
  2909   001164 c8              	RET	Z		;not there???
  2910   001165 2a430b          	LD	HL,(PARAMS)	;get extent byte.
  2911   001168 010c00          	LD	BC,12
  2912   00116b 09              	ADD	HL,BC
  2913   00116c 7e              	LD	A,(HL)		;and increment it.
  2914   00116d 3c              	INC	A
  2915   00116e e61f            	AND	1FH		;keep within range 0-31.
  2916   001170 77              	LD	(HL),A
  2917   001171 ca8311          	JP	Z,GTNEXT1	;overflow?
  2918   001174 47              	LD	B,A		;mask extent byte.
  2919   001175 3ac515          	LD	A,(EXTMASK)
  2920   001178 a0              	AND	B
  2921   001179 21d215          	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
  2922   00117c a6              	AND	(HL)
  2923   00117d ca8e11          	JP	Z,GTNEXT2	;if zero, we must read in next extent.
  2924   001180 c3ac11          	JP	GTNEXT3		;else, it is already in memory.
  2925   001183 010200          GTNEXT1:LD	BC,2		;Point to the 's2' byte.
  2926   001186 09              	ADD	HL,BC
  2927   001187 34              	INC	(HL)		;and bump it.
  2928   001188 7e              	LD	A,(HL)		;too many extents?
  2929   001189 e60f            	AND	0FH
  2930   00118b cab611          	JP	Z,GTNEXT5	;yes, set error code.
  2931                          ;
  2932                          ;   Get here to open the next extent.
  2933                          ;
  2934   00118e 0e0f            GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
  2935   001190 cd180f          	CALL	FINDFST		;find the first one.
  2936   001193 cdf50d          	CALL	CKFILPOS	;none available?
  2937   001196 c2ac11          	JP	NZ,GTNEXT3
  2938   001199 3ad315          	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
  2939   00119c 3c              	INC	A		;0ffh means reading (so not possible).
  2940   00119d cab611          	JP	Z,GTNEXT5	;or an error.
  2941   0011a0 cd2411          	CALL	GETEMPTY	;we are writing, get an empty entry.
  2942   0011a3 cdf50d          	CALL	CKFILPOS	;none?
  2943   0011a6 cab611          	JP	Z,GTNEXT5	;error if true.
  2944   0011a9 c3af11          	JP	GTNEXT4		;else we are almost done.
  2945   0011ac cd5a10          GTNEXT3:CALL	OPENIT1		;open this extent.
  2946   0011af cdbb0c          GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
  2947   0011b2 af              	XOR	A		;clear status and return.
  2948   0011b3 c3010b          	JP	SETSTAT
  2949                          ;
  2950                          ;   Error in extending the file. Too many extents were needed
  2951                          ; or not enough space on the disk.
  2952                          ;
  2953   0011b6 cd050b          GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
  2954   0011b9 c3780d          	JP	SETS2B7		;so this is not written on a close.
  2955                          ;
  2956                          ;   Read a sequential file.
  2957                          ;
  2958   0011bc 3e01            RDSEQ:	LD	A,1		;set sequential access mode.
  2959   0011be 32d515          	LD	(MODE),A
  2960   0011c1 3eff            RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
  2961   0011c3 32d315          	LD	(RDWRTFLG),A
  2962   0011c6 cdbb0c          	CALL	STRDATA		;put rec# and ext# into fcb.
  2963   0011c9 3ae315          	LD	A,(SAVNREC)	;get next record to read.
  2964   0011cc 21e115          	LD	HL,SAVNXT	;get number of records in extent.
  2965   0011cf be              	CP	(HL)		;within this extent?
  2966   0011d0 dae611          	JP	C,RDSEQ2
  2967   0011d3 fe80            	CP	128		;no. Is this extent fully used?
  2968   0011d5 c2fb11          	JP	NZ,RDSEQ3	;no. End-of-file.
  2969   0011d8 cd5a11          	CALL	GETNEXT		;yes, open the next one.
  2970   0011db af              	XOR	A		;reset next record to read.
  2971   0011dc 32e315          	LD	(SAVNREC),A
  2972   0011df 3a450b          	LD	A,(STATUS)	;check on open, successful?
  2973   0011e2 b7              	OR	A
  2974   0011e3 c2fb11          	JP	NZ,RDSEQ3	;no, error.
  2975   0011e6 cd770c          RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
  2976   0011e9 cd840c          	CALL	CHKBLK		;check it. Within bounds?
  2977   0011ec cafb11          	JP	Z,RDSEQ3	;no, error.
  2978   0011ef cd8a0c          	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
  2979   0011f2 cdd10b          	CALL	TRKSEC1		;set the track and sector for this block #.
  2980   0011f5 cdb20b          	CALL	DOREAD		;and read it.
  2981   0011f8 c3d20c          	JP	SETNREC		;and set the next record to be accessed.
  2982                          ;
  2983                          ;   Read error occured. Set status and return.
  2984                          ;
  2985   0011fb c3050b          RDSEQ3:	JP	IOERR1
  2986                          ;
  2987                          ;   Write the next sequential record.
  2988                          ;
  2989   0011fe 3e01            WTSEQ:	LD	A,1		;set sequential access mode.
  2990   001200 32d515          	LD	(MODE),A
  2991   001203 3e00            WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
  2992   001205 32d315          	LD	(RDWRTFLG),A
  2993   001208 cd540d          	CALL	CHKWPRT		;check write protect status.
  2994   00120b 2a430b          	LD	HL,(PARAMS)
  2995   00120e cd470d          	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
  2996   001211 cdbb0c          	CALL	STRDATA		;put updated data into fcb.
  2997   001214 3ae315          	LD	A,(SAVNREC)	;get record number to write.
  2998   001217 fe80            	CP	128		;within range?
  2999   001219 d2050b          	JP	NC,IOERR1	;no, error(?).
  3000   00121c cd770c          	CALL	COMBLK		;compute block number.
  3001   00121f cd840c          	CALL	CHKBLK		;check number.
  3002   001222 0e00            	LD	C,0		;is there one to write to?
  3003   001224 c26e12          	JP	NZ,WTSEQ6	;yes, go do it.
  3004   001227 cd3e0c          	CALL	GETBLOCK	;get next block number within fcb to use.
  3005   00122a 32d715          	LD	(RELBLOCK),A	;and save.
  3006   00122d 010000          	LD	BC,0		;start looking for space from the start
  3007   001230 b7              	OR	A		;if none allocated as yet.
  3008   001231 ca3b12          	JP	Z,WTSEQ2
  3009   001234 4f              	LD	C,A		;extract previous block number from fcb
  3010   001235 0b              	DEC	BC		;so we can be closest to it.
  3011   001236 cd5e0c          	CALL	EXTBLK
  3012   001239 44              	LD	B,H
  3013   00123a 4d              	LD	C,L
  3014   00123b cdbe0f          WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
  3015   00123e 7d              	LD	A,L		;check for a zero number.
  3016   00123f b4              	OR	H
  3017   001240 c24812          	JP	NZ,WTSEQ3
  3018   001243 3e02            	LD	A,2		;no more space?
  3019   001245 c3010b          	JP	SETSTAT
  3020   001248 22e515          WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
  3021   00124b eb              	EX	DE,HL		;put block number into (DE).
  3022   00124c 2a430b          	LD	HL,(PARAMS)	;now we must update the fcb for this
  3023   00124f 011000          	LD	BC,16		;newly allocated block.
  3024   001252 09              	ADD	HL,BC
  3025   001253 3add15          	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
  3026   001256 b7              	OR	A
  3027   001257 3ad715          	LD	A,(RELBLOCK)	;(* update this entry *)
  3028   00125a ca6412          	JP	Z,WTSEQ4	;zero means 16 bit ones.
  3029   00125d cd640d          	CALL	ADDA2HL		;(HL)=(HL)+(A)
  3030   001260 73              	LD	(HL),E		;store new block number.
  3031   001261 c36c12          	JP	WTSEQ5
  3032   001264 4f              WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
  3033   001265 0600            	LD	B,0
  3034   001267 09              	ADD	HL,BC
  3035   001268 09              	ADD	HL,BC
  3036   001269 73              	LD	(HL),E		;stuff block number (DE) there.
  3037   00126a 23              	INC	HL
  3038   00126b 72              	LD	(HL),D
  3039   00126c 0e02            WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
  3040   00126e 3a450b          WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
  3041   001271 b7              	OR	A
  3042   001272 c0              	RET	NZ
  3043   001273 c5              	PUSH	BC		;yes, save write flag for bios (register C).
  3044   001274 cd8a0c          	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
  3045   001277 3ad515          	LD	A,(MODE)	;get access mode flag (1=sequential,
  3046   00127a 3d              	DEC	A		;0=random, 2=special?).
  3047   00127b 3d              	DEC	A
  3048   00127c c2bb12          	JP	NZ,WTSEQ9
  3049                          ;
  3050                          ;   Special random i/o from function #40. Maybe for M/PM, but the
  3051                          ; current block, if it has not been written to, will be zeroed
  3052                          ; out and then written (reason?).
  3053                          ;
  3054   00127f c1              	POP	BC
  3055   001280 c5              	PUSH	BC
  3056   001281 79              	LD	A,C		;get write status flag (2=writing unused space).
  3057   001282 3d              	DEC	A
  3058   001283 3d              	DEC	A
  3059   001284 c2bb12          	JP	NZ,WTSEQ9
  3060   001287 e5              	PUSH	HL
  3061   001288 2ab915          	LD	HL,(DIRBUF)	;zero out the directory buffer.
  3062   00128b 57              	LD	D,A		;note that (A) is zero here.
  3063   00128c 77              WTSEQ7:	LD	(HL),A
  3064   00128d 23              	INC	HL
  3065   00128e 14              	INC	D		;do 128 bytes.
  3066   00128f f28c12          	JP	P,WTSEQ7
  3067   001292 cde00d          	CALL	DIRDMA		;tell the bios the dma address for directory access.
  3068   001295 2ae715          	LD	HL,(LOGSECT)	;get sector that starts current block.
  3069   001298 0e02            	LD	C,2		;set 'writing to unused space' flag.
  3070   00129a 22e515          WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
  3071   00129d c5              	PUSH	BC
  3072   00129e cdd10b          	CALL	TRKSEC1		;determine its track and sector numbers.
  3073   0012a1 c1              	POP	BC
  3074   0012a2 cdb80b          	CALL	DOWRITE		;now write out 128 bytes of zeros.
  3075   0012a5 2ae515          	LD	HL,(BLKNMBR)	;get sector number.
  3076   0012a8 0e00            	LD	C,0		;set normal write flag.
  3077   0012aa 3ac415          	LD	A,(BLKMASK)	;determine if we have written the entire
  3078   0012ad 47              	LD	B,A		;physical block.
  3079   0012ae a5              	AND	L
  3080   0012af b8              	CP	B
  3081   0012b0 23              	INC	HL		;prepare for the next one.
  3082   0012b1 c29a12          	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
  3083   0012b4 e1              	POP	HL		;reset next sector number.
  3084   0012b5 22e515          	LD	(BLKNMBR),HL
  3085   0012b8 cdda0d          	CALL	DEFDMA		;and reset dma address.
  3086                          ;
  3087                          ;   Normal disk write. Set the desired track and sector then
  3088                          ; do the actual write.
  3089                          ;
  3090   0012bb cdd10b          WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
  3091   0012be c1              	POP	BC		;get write status flag.
  3092   0012bf c5              	PUSH	BC
  3093   0012c0 cdb80b          	CALL	DOWRITE		;and write this out.
  3094   0012c3 c1              	POP	BC
  3095   0012c4 3ae315          	LD	A,(SAVNREC)	;get number of records in file.
  3096   0012c7 21e115          	LD	HL,SAVNXT	;get last record written.
  3097   0012ca be              	CP	(HL)
  3098   0012cb dad212          	JP	C,WTSEQ10
  3099   0012ce 77              	LD	(HL),A		;we have to update record count.
  3100   0012cf 34              	INC	(HL)
  3101   0012d0 0e02            	LD	C,2
  3102                          ;
  3103                          ;*   This area has been patched to correct disk update problem
  3104                          ;* when using blocking and de-blocking in the BIOS.
  3105                          ;
  3106   0012d2 00              WTSEQ10:NOP			;was 'dcr c'
  3107   0012d3 00              	NOP			;was 'dcr c'
  3108   0012d4 210000          	LD	HL,0		;was 'jnz wtseq99'
  3109                          ;
  3110                          ; *   End of patch.
  3111                          ;
  3112   0012d7 f5              	PUSH	AF
  3113   0012d8 cd690d          	CALL	GETS2		;set 'extent written to' flag.
  3114   0012db e67f            	AND	7FH		;(* clear bit 7 *)
  3115   0012dd 77              	LD	(HL),A
  3116   0012de f1              	POP	AF		;get record count for this extent.
  3117   0012df fe7f            WTSEQ99:CP	127		;is it full?
  3118   0012e1 c20013          	JP	NZ,WTSEQ12
  3119   0012e4 3ad515          	LD	A,(MODE)	;yes, are we in sequential mode?
  3120   0012e7 fe01            	CP	1
  3121   0012e9 c20013          	JP	NZ,WTSEQ12
  3122   0012ec cdd20c          	CALL	SETNREC		;yes, set next record number.
  3123   0012ef cd5a11          	CALL	GETNEXT		;and get next empty space in directory.
  3124   0012f2 21450b          	LD	HL,STATUS	;ok?
  3125   0012f5 7e              	LD	A,(HL)
  3126   0012f6 b7              	OR	A
  3127   0012f7 c2fe12          	JP	NZ,WTSEQ11
  3128   0012fa 3d              	DEC	A		;yes, set record count to -1.
  3129   0012fb 32e315          	LD	(SAVNREC),A
  3130   0012fe 3600            WTSEQ11:LD	(HL),0		;clear status.
  3131   001300 c3d20c          WTSEQ12:JP	SETNREC		;set next record to access.
  3132                          ;
  3133                          ;   For random i/o, set the fcb for the desired record number
  3134                          ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
  3135                          ; used as follows:
  3136                          ;
  3137                          ;       fcb+35            fcb+34            fcb+33
  3138                          ;  |     'r-2'      |      'r-1'      |      'r-0'     |
  3139                          ;  |7             0 | 7             0 | 7             0|
  3140                          ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
  3141                          ;  |    overflow   | | extra |  extent   |   record #  |
  3142                          ;  | ______________| |_extent|__number___|_____________|
  3143                          ;                     also 's2'
  3144                          ;
  3145                          ;   On entry, register (C) contains 0ffh if this is a read
  3146                          ; and thus we can not access unwritten disk space. Otherwise,
  3147                          ; another extent will be opened (for writing) if required.
  3148                          ;
  3149   001303 af              POSITION: XOR	A		;set random i/o flag.
  3150   001304 32d515          	LD	(MODE),A
  3151                          ;
  3152                          ;   Special entry (function #40). M/PM ?
  3153                          ;
  3154   001307 c5              POSITN1:PUSH	BC		;save read/write flag.
  3155   001308 2a430b          	LD	HL,(PARAMS)	;get address of fcb.
  3156   00130b eb              	EX	DE,HL
  3157   00130c 212100          	LD	HL,33		;now get byte 'r0'.
  3158   00130f 19              	ADD	HL,DE
  3159   001310 7e              	LD	A,(HL)
  3160   001311 e67f            	AND	7FH		;keep bits 0-6 for the record number to access.
  3161   001313 f5              	PUSH	AF
  3162   001314 7e              	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
  3163   001315 17              	RLA
  3164   001316 23              	INC	HL
  3165   001317 7e              	LD	A,(HL)
  3166   001318 17              	RLA
  3167   001319 e61f            	AND	1FH		;and save this in bits 0-4 of (C).
  3168   00131b 4f              	LD	C,A		;this is the extent byte.
  3169   00131c 7e              	LD	A,(HL)		;now get the extra extent byte.
  3170   00131d 1f              	RRA
  3171   00131e 1f              	RRA
  3172   00131f 1f              	RRA
  3173   001320 1f              	RRA
  3174   001321 e60f            	AND	0FH
  3175   001323 47              	LD	B,A		;and save it in (B).
  3176   001324 f1              	POP	AF		;get record number back to (A).
  3177   001325 23              	INC	HL		;check overflow byte 'r2'.
  3178   001326 6e              	LD	L,(HL)
  3179   001327 2c              	INC	L
  3180   001328 2d              	DEC	L
  3181   001329 2e06            	LD	L,6		;prepare for error.
  3182   00132b c28b13          	JP	NZ,POSITN5	;out of disk space error.
  3183   00132e 212000          	LD	HL,32		;store record number into fcb.
  3184   001331 19              	ADD	HL,DE
  3185   001332 77              	LD	(HL),A
  3186   001333 210c00          	LD	HL,12		;and now check the extent byte.
  3187   001336 19              	ADD	HL,DE
  3188   001337 79              	LD	A,C
  3189   001338 96              	SUB	(HL)		;same extent as before?
  3190   001339 c24713          	JP	NZ,POSITN2
  3191   00133c 210e00          	LD	HL,14		;yes, check extra extent byte 's2' also.
  3192   00133f 19              	ADD	HL,DE
  3193   001340 78              	LD	A,B
  3194   001341 96              	SUB	(HL)
  3195   001342 e67f            	AND	7FH
  3196   001344 ca7f13          	JP	Z,POSITN3	;same, we are almost done then.
  3197                          ;
  3198                          ;  Get here when another extent is required.
  3199                          ;
  3200   001347 c5              POSITN2:PUSH	BC
  3201   001348 d5              	PUSH	DE
  3202   001349 cda210          	CALL	CLOSEIT		;close current extent.
  3203   00134c d1              	POP	DE
  3204   00134d c1              	POP	BC
  3205   00134e 2e03            	LD	L,3		;prepare for error.
  3206   001350 3a450b          	LD	A,(STATUS)
  3207   001353 3c              	INC	A
  3208   001354 ca8413          	JP	Z,POSITN4	;close error.
  3209   001357 210c00          	LD	HL,12		;put desired extent into fcb now.
  3210   00135a 19              	ADD	HL,DE
  3211   00135b 71              	LD	(HL),C
  3212   00135c 210e00          	LD	HL,14		;and store extra extent byte 's2'.
  3213   00135f 19              	ADD	HL,DE
  3214   001360 70              	LD	(HL),B
  3215   001361 cd5110          	CALL	OPENIT		;try and get this extent.
  3216   001364 3a450b          	LD	A,(STATUS)	;was it there?
  3217   001367 3c              	INC	A
  3218   001368 c27f13          	JP	NZ,POSITN3
  3219   00136b c1              	POP	BC		;no. can we create a new one (writing?).
  3220   00136c c5              	PUSH	BC
  3221   00136d 2e04            	LD	L,4		;prepare for error.
  3222   00136f 0c              	INC	C
  3223   001370 ca8413          	JP	Z,POSITN4	;nope, reading unwritten space error.
  3224   001373 cd2411          	CALL	GETEMPTY	;yes we can, try to find space.
  3225   001376 2e05            	LD	L,5		;prepare for error.
  3226   001378 3a450b          	LD	A,(STATUS)
  3227   00137b 3c              	INC	A
  3228   00137c ca8413          	JP	Z,POSITN4	;out of space?
  3229                          ;
  3230                          ;   Normal return location. Clear error code and return.
  3231                          ;
  3232   00137f c1              POSITN3:POP	BC		;restore stack.
  3233   001380 af              	XOR	A		;and clear error code byte.
  3234   001381 c3010b          	JP	SETSTAT
  3235                          ;
  3236                          ;   Error. Set the 's2' byte to indicate this (why?).
  3237                          ;
  3238   001384 e5              POSITN4:PUSH	HL
  3239   001385 cd690d          	CALL	GETS2
  3240   001388 36c0            	LD	(HL),0C0H
  3241   00138a e1              	POP	HL
  3242                          ;
  3243                          ;   Return with error code (presently in L).
  3244                          ;
  3245   00138b c1              POSITN5:POP	BC
  3246   00138c 7d              	LD	A,L		;get error code.
  3247   00138d 32450b          	LD	(STATUS),A
  3248   001390 c3780d          	JP	SETS2B7
  3249                          ;
  3250                          ;   Read a random record.
  3251                          ;
  3252   001393 0eff            READRAN:LD	C,0FFH		;set 'read' status.
  3253   001395 cd0313          	CALL	POSITION	;position the file to proper record.
  3254   001398 ccc111          	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
  3255   00139b c9              	RET
  3256                          ;
  3257                          ;   Write to a random record.
  3258                          ;
  3259   00139c 0e00            WRITERAN: LD	C,0		;set 'writing' flag.
  3260   00139e cd0313          	CALL	POSITION	;position the file to proper record.
  3261   0013a1 cc0312          	CALL	Z,WTSEQ1	;and write as usual (if no errors).
  3262   0013a4 c9              	RET
  3263                          ;
  3264                          ;   Compute the random record number. Enter with (HL) pointing
  3265                          ; to a fcb an (DE) contains a relative location of a record
  3266                          ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
  3267                          ; byte, and (A) the 'r2' byte.
  3268                          ;
  3269                          ;   On return, the zero flag is set if the record is within
  3270                          ; bounds. Otherwise, an overflow occured.
  3271                          ;
  3272   0013a5 eb              COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
  3273   0013a6 19              	ADD	HL,DE		;compute relative position of record #.
  3274   0013a7 4e              	LD	C,(HL)		;get record number into (BC).
  3275   0013a8 0600            	LD	B,0
  3276   0013aa 210c00          	LD	HL,12		;now get extent.
  3277   0013ad 19              	ADD	HL,DE
  3278   0013ae 7e              	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
  3279   0013af 0f              	RRCA			;move lower bit into bit 7.
  3280   0013b0 e680            	AND	80H		;and ignore all other bits.
  3281   0013b2 81              	ADD	A,C		;add to our record number.
  3282   0013b3 4f              	LD	C,A
  3283   0013b4 3e00            	LD	A,0		;take care of any carry.
  3284   0013b6 88              	ADC	A,B
  3285   0013b7 47              	LD	B,A
  3286   0013b8 7e              	LD	A,(HL)		;now get the upper bits of extent into
  3287   0013b9 0f              	RRCA			;bit positions 0-3.
  3288   0013ba e60f            	AND	0FH		;and ignore all others.
  3289   0013bc 80              	ADD	A,B		;add this in to 'r1' byte.
  3290   0013bd 47              	LD	B,A
  3291   0013be 210e00          	LD	HL,14		;get the 's2' byte (extra extent).
  3292   0013c1 19              	ADD	HL,DE
  3293   0013c2 7e              	LD	A,(HL)
  3294   0013c3 87              	ADD	A,A		;and shift it left 4 bits (bits 4-7).
  3295   0013c4 87              	ADD	A,A
  3296   0013c5 87              	ADD	A,A
  3297   0013c6 87              	ADD	A,A
  3298   0013c7 f5              	PUSH	AF		;save carry flag (bit 0 of flag byte).
  3299   0013c8 80              	ADD	A,B		;now add extra extent into 'r1'.
  3300   0013c9 47              	LD	B,A
  3301   0013ca f5              	PUSH	AF		;and save carry (overflow byte 'r2').
  3302   0013cb e1              	POP	HL		;bit 0 of (L) is the overflow indicator.
  3303   0013cc 7d              	LD	A,L
  3304   0013cd e1              	POP	HL		;and same for first carry flag.
  3305   0013ce b5              	OR	L		;either one of these set?
  3306   0013cf e601            	AND	01H		;only check the carry flags.
  3307   0013d1 c9              	RET
  3308                          ;
  3309                          ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
  3310                          ; reflect the last record used for a random (or other) file.
  3311                          ; This reads the directory and looks at all extents computing
  3312                          ; the largerst record number for each and keeping the maximum
  3313                          ; value only. Then 'r0', 'r1', and 'r2' will reflect this
  3314                          ; maximum record number. This is used to compute the space used
  3315                          ; by a random file.
  3316                          ;
  3317   0013d2 0e0c            RANSIZE:LD	C,12		;look thru directory for first entry with
  3318   0013d4 cd180f          	CALL	FINDFST		;this name.
  3319   0013d7 2a430b          	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
  3320   0013da 112100          	LD	DE,33
  3321   0013dd 19              	ADD	HL,DE
  3322   0013de e5              	PUSH	HL
  3323   0013df 72              	LD	(HL),D		;note that (D)=0.
  3324   0013e0 23              	INC	HL
  3325   0013e1 72              	LD	(HL),D
  3326   0013e2 23              	INC	HL
  3327   0013e3 72              	LD	(HL),D
  3328   0013e4 cdf50d          RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
  3329   0013e7 ca0c14          	JP	Z,RANSIZ3	;no, we are done.
  3330   0013ea cd5e0d          	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
  3331   0013ed 110f00          	LD	DE,15		;point to last record in extent.
  3332   0013f0 cda513          	CALL	COMPRAND	;and compute random parameters.
  3333   0013f3 e1              	POP	HL
  3334   0013f4 e5              	PUSH	HL		;now check these values against those
  3335   0013f5 5f              	LD	E,A		;already in fcb.
  3336   0013f6 79              	LD	A,C		;the carry flag will be set if those
  3337   0013f7 96              	SUB	(HL)		;in the fcb represent a larger size than
  3338   0013f8 23              	INC	HL		;this extent does.
  3339   0013f9 78              	LD	A,B
  3340   0013fa 9e              	SBC	A,(HL)
  3341   0013fb 23              	INC	HL
  3342   0013fc 7b              	LD	A,E
  3343   0013fd 9e              	SBC	A,(HL)
  3344   0013fe da0614          	JP	C,RANSIZ2
  3345   001401 73              	LD	(HL),E		;we found a larger (in size) extent.
  3346   001402 2b              	DEC	HL		;stuff these values into fcb.
  3347   001403 70              	LD	(HL),B
  3348   001404 2b              	DEC	HL
  3349   001405 71              	LD	(HL),C
  3350   001406 cd2d0f          RANSIZ2:CALL	FINDNXT		;now get the next extent.
  3351   001409 c3e413          	JP	RANSIZ1		;continue til all done.
  3352   00140c e1              RANSIZ3:POP	HL		;we are done, restore the stack and
  3353   00140d c9              	RET			;return.
  3354                          ;
  3355                          ;   Function to return the random record position of a given
  3356                          ; file which has been read in sequential mode up to now.
  3357                          ;
  3358   00140e 2a430b          SETRAN:	LD	HL,(PARAMS)	;point to fcb.
  3359   001411 112000          	LD	DE,32		;and to last used record.
  3360   001414 cda513          	CALL	COMPRAND	;compute random position.
  3361   001417 212100          	LD	HL,33		;now stuff these values into fcb.
  3362   00141a 19              	ADD	HL,DE
  3363   00141b 71              	LD	(HL),C		;move 'r0'.
  3364   00141c 23              	INC	HL
  3365   00141d 70              	LD	(HL),B		;and 'r1'.
  3366   00141e 23              	INC	HL
  3367   00141f 77              	LD	(HL),A		;and lastly 'r2'.
  3368   001420 c9              	RET
  3369                          ;
  3370                          ;   This routine select the drive specified in (ACTIVE) and
  3371                          ; update the login vector and bitmap table if this drive was
  3372                          ; not already active.
  3373                          ;
  3374   001421 2aaf15          LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
  3375   001424 3a420b          	LD	A,(ACTIVE)	;get the default drive.
  3376   001427 4f              	LD	C,A
  3377   001428 cdea0c          	CALL	SHIFTR		;position active bit for this drive
  3378   00142b e5              	PUSH	HL		;into bit 0.
  3379   00142c eb              	EX	DE,HL
  3380   00142d cd590b          	CALL	SELECT		;select this drive.
  3381   001430 e1              	POP	HL
  3382   001431 cc470b          	CALL	Z,SLCTERR	;valid drive?
  3383   001434 7d              	LD	A,L		;is this a newly activated drive?
  3384   001435 1f              	RRA
  3385   001436 d8              	RET	C
  3386   001437 2aaf15          	LD	HL,(LOGIN)	;yes, update the login vector.
  3387   00143a 4d              	LD	C,L
  3388   00143b 44              	LD	B,H
  3389   00143c cd0b0d          	CALL	SETBIT
  3390   00143f 22af15          	LD	(LOGIN),HL	;and save.
  3391   001442 c3a30e          	JP	BITMAP		;now update the bitmap.
  3392                          ;
  3393                          ;   Function to set the active disk number.
  3394                          ;
  3395   001445 3ad615          SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
  3396   001448 21420b          	LD	HL,ACTIVE	;represents a change in drives.
  3397   00144b be              	CP	(HL)
  3398   00144c c8              	RET	Z
  3399   00144d 77              	LD	(HL),A		;yes it does, log it in.
  3400   00144e c32114          	JP	LOGINDRV
  3401                          ;
  3402                          ;   This is the 'auto disk select' routine. The firsst byte
  3403                          ; of the fcb is examined for a drive specification. If non
  3404                          ; zero then the drive will be selected and loged in.
  3405                          ;
  3406   001451 3eff            AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
  3407   001453 32de15          	LD	(AUTO),A
  3408   001456 2a430b          	LD	HL,(PARAMS)	;get drive specified.
  3409   001459 7e              	LD	A,(HL)
  3410   00145a e61f            	AND	1FH		;look at lower 5 bits.
  3411   00145c 3d              	DEC	A		;adjust for (1=A, 2=B) etc.
  3412   00145d 32d615          	LD	(EPARAM),A	;and save for the select routine.
  3413   001460 fe1e            	CP	1EH		;check for 'no change' condition.
  3414   001462 d27514          	JP	NC,AUTOSL1	;yes, don't change.
  3415   001465 3a420b          	LD	A,(ACTIVE)	;we must change, save currently active
  3416   001468 32df15          	LD	(OLDDRV),A	;drive.
  3417   00146b 7e              	LD	A,(HL)		;and save first byte of fcb also.
  3418   00146c 32e015          	LD	(AUTOFLAG),A	;this must be non-zero.
  3419   00146f e6e0            	AND	0E0H		;whats this for (bits 6,7 are used for
  3420   001471 77              	LD	(HL),A		;something)?
  3421   001472 cd4514          	CALL	SETDSK		;select and log in this drive.
  3422   001475 3a410b          AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
  3423   001478 2a430b          	LD	HL,(PARAMS)	;(* upper half of first byte *)
  3424   00147b b6              	OR	(HL)
  3425   00147c 77              	LD	(HL),A
  3426   00147d c9              	RET			;and return (all done).
  3427                          ;
  3428                          ;   Function to return the current cp/m version number.
  3429                          ;
  3430   00147e 3e22            GETVER:	LD	A,022H		;version 2.2
  3431   001480 c3010b          	JP	SETSTAT
  3432                          ;
  3433                          ;   Function to reset the disk system.
  3434                          ;
  3435   001483 210000          RSTDSK:	LD	HL,0		;clear write protect status and log
  3436   001486 22ad15          	LD	(WRTPRT),HL	;in vector.
  3437   001489 22af15          	LD	(LOGIN),HL
  3438   00148c af              	XOR	A		;select drive 'A'.
  3439   00148d 32420b          	LD	(ACTIVE),A
  3440   001490 218000          	LD	HL,TBUFF	;setup default dma address.
  3441   001493 22b115          	LD	(USERDMA),HL
  3442   001496 cdda0d          	CALL	DEFDMA
  3443   001499 c32114          	JP	LOGINDRV	;now log in drive 'A'.
  3444                          ;
  3445                          ;   Function to open a specified file.
  3446                          ;
  3447   00149c cd720d          OPENFIL:CALL	CLEARS2		;clear 's2' byte.
  3448   00149f cd5114          	CALL	AUTOSEL		;select proper disk.
  3449   0014a2 c35110          	JP	OPENIT		;and open the file.
  3450                          ;
  3451                          ;   Function to close a specified file.
  3452                          ;
  3453   0014a5 cd5114          CLOSEFIL: CALL	AUTOSEL		;select proper disk.
  3454   0014a8 c3a210          	JP	CLOSEIT		;and close the file.
  3455                          ;
  3456                          ;   Function to return the first occurence of a specified file
  3457                          ; name. If the first byte of the fcb is '?' then the name will
  3458                          ; not be checked (get the first entry no matter what).
  3459                          ;
  3460   0014ab 0e00            GETFST:	LD	C,0		;prepare for special search.
  3461   0014ad eb              	EX	DE,HL
  3462   0014ae 7e              	LD	A,(HL)		;is first byte a '?'?
  3463   0014af fe3f            	CP	'?'
  3464   0014b1 cac214          	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
  3465   0014b4 cda60c          	CALL	SETEXT		;get the extension byte from fcb.
  3466   0014b7 7e              	LD	A,(HL)		;is it '?'? if yes, then we want
  3467   0014b8 fe3f            	CP	'?'		;an entry with a specific 's2' byte.
  3468   0014ba c4720d          	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
  3469   0014bd cd5114          	CALL	AUTOSEL		;select proper drive.
  3470   0014c0 0e0f            	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
  3471   0014c2 cd180f          GETFST1:CALL	FINDFST		;find an entry and then move it into
  3472   0014c5 c3e90d          	JP	MOVEDIR		;the users dma space.
  3473                          ;
  3474                          ;   Function to return the next occurence of a file name.
  3475                          ;
  3476   0014c8 2ad915          GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
  3477   0014cb 22430b          	LD	(PARAMS),HL	;other dbos calls are allowed.
  3478   0014ce cd5114          	CALL	AUTOSEL		;no error will be returned, but the
  3479   0014d1 cd2d0f          	CALL	FINDNXT		;results will be wrong.
  3480   0014d4 c3e90d          	JP	MOVEDIR
  3481                          ;
  3482                          ;   Function to delete a file by name.
  3483                          ;
  3484   0014d7 cd5114          DELFILE:CALL	AUTOSEL		;select proper drive.
  3485   0014da cd9c0f          	CALL	ERAFILE		;erase the file.
  3486   0014dd c3010f          	JP	STSTATUS	;set status and return.
  3487                          ;
  3488                          ;   Function to execute a sequential read of the specified
  3489                          ; record number.
  3490                          ;
  3491   0014e0 cd5114          READSEQ:CALL	AUTOSEL		;select proper drive then read.
  3492   0014e3 c3bc11          	JP	RDSEQ
  3493                          ;
  3494                          ;   Function to write the net sequential record.
  3495                          ;
  3496   0014e6 cd5114          WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
  3497   0014e9 c3fe11          	JP	WTSEQ
  3498                          ;
  3499                          ;   Create a file function.
  3500                          ;
  3501   0014ec cd720d          FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
  3502   0014ef cd5114          	CALL	AUTOSEL		;select proper drive and get the next
  3503   0014f2 c32411          	JP	GETEMPTY	;empty directory space.
  3504                          ;
  3505                          ;   Function to rename a file.
  3506                          ;
  3507   0014f5 cd5114          RENFILE:CALL	AUTOSEL		;select proper drive and then switch
  3508   0014f8 cd1610          	CALL	CHGNAMES	;file names.
  3509   0014fb c3010f          	JP	STSTATUS
  3510                          ;
  3511                          ;   Function to return the login vector.
  3512                          ;
  3513   0014fe 2aaf15          GETLOG:	LD	HL,(LOGIN)
  3514   001501 c32915          	JP	GETPRM1
  3515                          ;
  3516                          ;   Function to return the current disk assignment.
  3517                          ;
  3518   001504 3a420b          GETCRNT:LD	A,(ACTIVE)
  3519   001507 c3010b          	JP	SETSTAT
  3520                          ;
  3521                          ;   Function to set the dma address.
  3522                          ;
  3523   00150a eb              PUTDMA:	EX	DE,HL
  3524   00150b 22b115          	LD	(USERDMA),HL	;save in our space and then get to
  3525   00150e c3da0d          	JP	DEFDMA		;the bios with this also.
  3526                          ;
  3527                          ;   Function to return the allocation vector.
  3528                          ;
  3529   001511 2abf15          GETALOC:LD	HL,(ALOCVECT)
  3530   001514 c32915          	JP	GETPRM1
  3531                          ;
  3532                          ;   Function to return the read-only status vector.
  3533                          ;
  3534   001517 2aad15          GETROV:	LD	HL,(WRTPRT)
  3535   00151a c32915          	JP	GETPRM1
  3536                          ;
  3537                          ;   Function to set the file attributes (read-only, system).
  3538                          ;
  3539   00151d cd5114          SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
  3540   001520 cd3b10          	CALL	SAVEATTR
  3541   001523 c3010f          	JP	STSTATUS
  3542                          ;
  3543                          ;   Function to return the address of the disk parameter block
  3544                          ; for the current drive.
  3545                          ;
  3546   001526 2abb15          GETPARM:LD	HL,(DISKPB)
  3547   001529 22450b          GETPRM1:LD	(STATUS),HL
  3548   00152c c9              	RET
  3549                          ;
  3550                          ;   Function to get or set the user number. If (E) was (FF)
  3551                          ; then this is a request to return the current user number.
  3552                          ; Else set the user number from (E).
  3553                          ;
  3554   00152d 3ad615          GETUSER:LD	A,(EPARAM)	;get parameter.
  3555   001530 feff            	CP	0FFH		;get user number?
  3556   001532 c23b15          	JP	NZ,SETUSER
  3557   001535 3a410b          	LD	A,(USERNO)	;yes, just do it.
  3558   001538 c3010b          	JP	SETSTAT
  3559   00153b e61f            SETUSER:AND	1FH		;no, we should set it instead. keep low
  3560   00153d 32410b          	LD	(USERNO),A	;bits (0-4) only.
  3561   001540 c9              	RET
  3562                          ;
  3563                          ;   Function to read a random record from a file.
  3564                          ;
  3565   001541 cd5114          RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
  3566   001544 c39313          	JP	READRAN
  3567                          ;
  3568                          ;   Function to compute the file size for random files.
  3569                          ;
  3570   001547 cd5114          WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
  3571   00154a c39c13          	JP	WRITERAN
  3572                          ;
  3573                          ;   Function to compute the size of a random file.
  3574                          ;
  3575   00154d cd5114          FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
  3576   001550 c3d213          	JP	RANSIZE
  3577                          ;
  3578                          ;   Function #37. This allows a program to log off any drives.
  3579                          ; On entry, set (DE) to contain a word with bits set for those
  3580                          ; drives that are to be logged off. The log-in vector and the
  3581                          ; write protect vector will be updated. This must be a M/PM
  3582                          ; special function.
  3583                          ;
  3584   001553 2a430b          LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
  3585   001556 7d              	LD	A,L		;for each bit that is set, we want
  3586   001557 2f              	CPL			;to clear that bit in (LOGIN)
  3587   001558 5f              	LD	E,A		;and (WRTPRT).
  3588   001559 7c              	LD	A,H
  3589   00155a 2f              	CPL
  3590   00155b 2aaf15          	LD	HL,(LOGIN)	;reset the login vector.
  3591   00155e a4              	AND	H
  3592   00155f 57              	LD	D,A
  3593   001560 7d              	LD	A,L
  3594   001561 a3              	AND	E
  3595   001562 5f              	LD	E,A
  3596   001563 2aad15          	LD	HL,(WRTPRT)
  3597   001566 eb              	EX	DE,HL
  3598   001567 22af15          	LD	(LOGIN),HL	;and save.
  3599   00156a 7d              	LD	A,L		;now do the write protect vector.
  3600   00156b a3              	AND	E
  3601   00156c 6f              	LD	L,A
  3602   00156d 7c              	LD	A,H
  3603   00156e a2              	AND	D
  3604   00156f 67              	LD	H,A
  3605   001570 22ad15          	LD	(WRTPRT),HL	;and save. all done.
  3606   001573 c9              	RET
  3607                          ;
  3608                          ;   Get here to return to the user.
  3609                          ;
  3610   001574 3ade15          GOBACK:	LD	A,(AUTO)	;was auto select activated?
  3611   001577 b7              	OR	A
  3612   001578 ca9115          	JP	Z,GOBACK1
  3613   00157b 2a430b          	LD	HL,(PARAMS)	;yes, but was a change made?
  3614   00157e 3600            	LD	(HL),0		;(* reset first byte of fcb *)
  3615   001580 3ae015          	LD	A,(AUTOFLAG)
  3616   001583 b7              	OR	A
  3617   001584 ca9115          	JP	Z,GOBACK1
  3618   001587 77              	LD	(HL),A		;yes, reset first byte properly.
  3619   001588 3adf15          	LD	A,(OLDDRV)	;and get the old drive and select it.
  3620   00158b 32d615          	LD	(EPARAM),A
  3621   00158e cd4514          	CALL	SETDSK
  3622   001591 2a0f0b          GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
  3623   001594 f9              	LD	SP,HL
  3624   001595 2a450b          	LD	HL,(STATUS)	;get return status.
  3625   001598 7d              	LD	A,L		;force version 1.4 compatability.
  3626   001599 44              	LD	B,H
  3627   00159a c9              	RET			;and go back to user.
  3628                          ;
  3629                          ;   Function #40. This is a special entry to do random i/o.
  3630                          ; For the case where we are writing to unused disk space, this
  3631                          ; space will be zeroed out first. This must be a M/PM special
  3632                          ; purpose function, because why would any normal program even
  3633                          ; care about the previous contents of a sector about to be
  3634                          ; written over.
  3635                          ;
  3636   00159b cd5114          WTSPECL:CALL	AUTOSEL		;select proper drive.
  3637   00159e 3e02            	LD	A,2		;use special write mode.
  3638   0015a0 32d515          	LD	(MODE),A
  3639   0015a3 0e00            	LD	C,0		;set write indicator.
  3640   0015a5 cd0713          	CALL	POSITN1		;position the file.
  3641   0015a8 cc0312          	CALL	Z,WTSEQ1	;and write (if no errors).
  3642   0015ab c9              	RET
  3643                          ;
  3644                          ;**************************************************************
  3645                          ;*
  3646                          ;*     BDOS data storage pool.
  3647                          ;*
  3648                          ;**************************************************************
  3649                          ;
  3650   0015ac e5              EMPTYFCB: DB	0E5H		;empty directory segment indicator.
  3651   0015ad 0000            WRTPRT:	DW	0		;write protect status for all 16 drives.
  3652   0015af 0000            LOGIN:	DW	0		;drive active word (1 bit per drive).
  3653   0015b1 8000            USERDMA:DW	080H		;user's dma address (defaults to 80h).
  3654                          ;
  3655                          ;   Scratch areas from parameter block.
  3656                          ;
  3657   0015b3 0000            SCRATCH1: DW	0		;relative position within dir segment for file (0-3).
  3658   0015b5 0000            SCRATCH2: DW	0		;last selected track number.
  3659   0015b7 0000            SCRATCH3: DW	0		;last selected sector number.
  3660                          ;
  3661                          ;   Disk storage areas from parameter block.
  3662                          ;
  3663   0015b9 0000            DIRBUF:	DW	0		;address of directory buffer to use.
  3664   0015bb 0000            DISKPB:	DW	0		;contains address of disk parameter block.
  3665   0015bd 0000            CHKVECT:DW	0		;address of check vector.
  3666   0015bf 0000            ALOCVECT: DW	0		;address of allocation vector (bit map).
  3667                          ;
  3668                          ;   Parameter block returned from the bios.
  3669                          ;
  3670   0015c1 0000            SECTORS:DW	0		;sectors per track from bios.
  3671   0015c3 00              BLKSHFT:DB	0		;block shift.
  3672   0015c4 00              BLKMASK:DB	0		;block mask.
  3673   0015c5 00              EXTMASK:DB	0		;extent mask.
  3674   0015c6 0000            DSKSIZE:DW	0		;disk size from bios (number of blocks-1).
  3675   0015c8 0000            DIRSIZE:DW	0		;directory size.
  3676   0015ca 0000            ALLOC0:	DW	0		;storage for first bytes of bit map (dir space used).
  3677   0015cc 0000            ALLOC1:	DW	0
  3678   0015ce 0000            OFFSET:	DW	0		;first usable track number.
  3679   0015d0 0000            XLATE:	DW	0		;sector translation table address.
  3680                          ;
  3681                          ;
  3682   0015d2 00              CLOSEFLG: DB	0		;close flag (=0ffh is extent written ok).
  3683   0015d3 00              RDWRTFLG: DB	0		;read/write flag (0ffh=read, 0=write).
  3684   0015d4 00              FNDSTAT:DB	0		;filename found status (0=found first entry).
  3685   0015d5 00              MODE:	DB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
  3686   0015d6 00              EPARAM:	DB	0		;storage for register (E) on entry to bdos.
  3687   0015d7 00              RELBLOCK: DB	0		;relative position within fcb of block number written.
  3688   0015d8 00              COUNTER:DB	0		;byte counter for directory name searches.
  3689   0015d9 00000000        SAVEFCB:DW	0,0		;save space for address of fcb (for directory searches).
  3690   0015dd 00              BIGDISK:DB	0		;if =0 then disk is > 256 blocks long.
  3691   0015de 00              AUTO:	DB	0		;if non-zero, then auto select activated.
  3692   0015df 00              OLDDRV:	DB	0		;on auto select, storage for previous drive.
  3693   0015e0 00              AUTOFLAG: DB	0		;if non-zero, then auto select changed drives.
  3694   0015e1 00              SAVNXT:	DB	0		;storage for next record number to access.
  3695   0015e2 00              SAVEXT:	DB	0		;storage for extent number of file.
  3696   0015e3 0000            SAVNREC:DW	0		;storage for number of records in file.
  3697   0015e5 0000            BLKNMBR:DW	0		;block number (physical sector) used within a file or logical sect
  3698   0015e7 0000            LOGSECT:DW	0		;starting logical (128 byte) sector of block (physical sector).
  3699   0015e9 00              FCBPOS:	DB	0		;relative position within buffer for fcb of file of interest.
  3700   0015ea 0000            FILEPOS:DW	0		;files position within directory (0 to max entries -1).
  3701                          ;
  3702                          ;   Disk directory buffer checksum bytes. One for each of the
  3703                          ; 16 possible drives.
  3704                          ;
  3705   0015ec 0000000000000000CKSUMTBL: DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
  3706                          ;
  3707                          ;   Extra space ?
  3708                          ;
  3709   0015fc 00000000        	DB	0,0,0,0
  3710                          ;
  3711                          ;**************************************************************
  3712                          ;*
  3713                          ;*        B I O S   J U M P   T A B L E
  3714                          ;*
  3715                          ;**************************************************************
  3716                          ;
  3717                          ;BOOT:	JP	0		;NOTE WE USE FAKE DESTINATIONS
  3718                          ;WBOOT:	JP	0
  3719                          ;CONST:	JP	0
  3720                          ;CONIN:	JP	0
  3721                          ;CONOUT:	JP	0
  3722                          ;LIST:	JP	0
  3723                          ;PUNCH:	JP	0
  3724                          ;READER:	JP	0
  3725                          ;HOME:	JP	0
  3726                          ;SELDSK:	JP	0
  3727                          ;SETTRK:	JP	0
  3728                          ;SETSEC:	JP	0
  3729                          ;SETDMA:	JP	0
  3730                          ;READ:	JP	0
  3731                          ;WRITE:	JP	0
  3732                          ;PRSTAT:	JP	0
  3733                          ;SECTRN:	JP	0
  3734                          ;
  3735                          ;*
  3736                          ;******************   E N D   O F   C P / M   *****************
  3737                          ;*
  3738                          
  3739                          	include "cpm22bios.asm"
cpm22bios.asm:
     1                          	include "mc68681.asm"
mc68681.asm:
     1                          ;--------------------------------------------------------------------------------
     2                          ; equates for MC68681 DUART
     3                          ;
     4                          ; see ./doc/scc68681.pdf
     5                          ;--------------------------------------------------------------------------------
     6                          MODEA		equ	0
     7                          STATA		equ	1
     8                          CLOCKA		equ	1
     9                          COMMA		equ	2
    10                          RECA		equ	3
    11                          TRANSA		equ	3
    12                          IPCHANGE	equ	4
    13                          AUXCTRL		equ	4
    14                          ISR		equ	5
    15                          IMR		equ	5
    16                          CNTMSB		equ	6
    17                          CNTLSB		equ	7
    18                          MODEB		equ	8
    19                          STATB		equ	9
    20                          CLOCKB		equ	9
    21                          COMMB		equ	10
    22                          RECB		equ	11
    23                          TRANSB		equ	11
    24                          IVR		equ	12
    25                          INPORT		equ	13
    26                          OPCTRL		equ	13
    27                          STRTCNT		equ	14
    28                          OPSET		equ	14
    29                          STOPCNT		equ	15
    30                          OPRES		equ	15
    31                          
cpm22bios.asm:
     2                          
     3                          ;
     4                          ;	skeletal cbios for first level of CP/M 2.0 alteration
     5                          ;
     6                          msize		equ	64		;cp/m version memory size in kilobytes
     7                          ;
     8                          ;	"bias" is address offset from 3400h for memory systems
     9                          ;	than 16k (referred to as"b" throughout the text)
    10                          ;
    11                          bias		equ	(msize-20)*1024	;$B000
    12                          ccp		equ	3400h+bias	;base of ccp	($E400)
    13                          bdos		equ	ccp+806h	;base of bdos	($EC06)
    14                          bios		equ	ccp+1600h	;base of bios	($FA00)
    15                          cdisk		equ	0004h		;current disk number 0=a,... l5=p
    16                          iobyte		equ	0003h		;intel i/o byte
    17                          INBUFFE		equ	0DC06h
    18                          ;
    19                          	IFDEF STANDALONE
    20                          	org	bios		;origin of this program
    21                          	ENDIF
    22                          
    23                          
    24                          nsects		equ	$1600/128	;warm start sector count (44 sectors for BDOS + CCP)
    25                          ;
    26                          ;		jump vector for individual subroutines
    27                          ;
    28   001600 c38216          		jp	boot	;cold start
    29   001603 c38216          WBOOT:		jp	bwboot	;warm start
    30   001606 c3f516          CONST:		jp	bconst	;console status
    31   001609 c3fd16          CONIN:		jp	bconin	;console character in
    32   00160c c30717          CONOUT:		jp	bconout	;console character out
    33   00160f c31117          LIST:		jp	blist	;list character out
    34   001612 c31517          PUNCH:		jp	bpunch	;punch character out
    35   001615 c31717          READER:		jp	breader	;reader character out
    36   001618 c31c17          HOME:		jp	bhome	;lde head to home position
    37   00161b c32217          SELDSK:		jp	bseldsk	;select disk
    38   00161e c33617          SETTRK:		jp	bsettrk	;set track number
    39   001621 c33b17          SETSEC:		jp	bsetsec	;set sector number
    40   001624 c34317          SETDMA:		jp	bsetdma	;set dma address
    41   001627 c34817          READ:		jp	bread	;read disk
    42   00162a c37a17          WRITE:		jp	bwrite	;write disk
    43   00162d c31317          LISTST:		jp	blistst	;return list status
    44   001630 c34017          SECTRN:		jp	bsectran	;sector translate
    45                          ;
    46                          ;	dw	track
    47                          ;	fixed data tables for four-drive standard
    48                          ;	ibm-compatible 8" disks
    49                          ;
    50                          ;		disk Parameter header for disk 00
    51   001633 00000000        dpbase:		dw	0000h, 0000h
    52   001637 00000000        		dw	0000h, 0000h
    53   00163b 0e187316        		dw	dirbf, dpblk
    54   00163f 0a198e18        		dw	chk00, all00
    55                          ;		disk parameter header for disk 01
    56   001643 00000000        		dw	0000h, 0000h
    57   001647 00000000        		dw	0000h, 0000h
    58   00164b 0e187316        		dw	dirbf, dpblk
    59   00164f 1a19ad18        		dw	chk01, all01
    60                          ;		disk parameter header for disk 02
    61   001653 00000000        		dw	0000h, 0000h
    62   001657 00000000        		dw	0000h, 0000h
    63   00165b 0e187316        		dw	dirbf, dpblk
    64   00165f 2a19cc18        		dw	chk02, all02
    65                          ;		disk parameter header for disk 03
    66   001663 00000000        		dw	0000h, 0000h
    67   001667 00000000        		dw	0000h, 0000h
    68   00166b 0e187316        		dw	dirbf, dpblk
    69   00166f 3a19eb18        		dw	chk03, all03
    70                          ;
    71                          ;		sector translate vector
    72                          ;trans:		db	 1,  7, 13, 19	;sectors  1,  2,  3,  4
    73                          ;		db	25,  5, 11, 17	;sectors  5,  6,  7,  6
    74                          ;		db	23,  3,  9, 15	;sectors  9, 10, 11, 12
    75                          ;		db	21,  2,  8, 14	;sectors 13, 14, 15, 16
    76                          ;		db	20, 26,  6, 12	;sectors 17, 18, 19, 20
    77                          ;		db	18, 24,  4, 10	;sectors 21, 22, 23, 24
    78                          ;		db	16, 22		;sectors 25, 26
    79                          ;
    80                          dpblk:		;disk parameter block, common to all disks
    81   001673 1a00            		dw	26		;sectors per track
    82   001675 03              		db	3		;block shift factor
    83   001676 07              		db	7		;block mask
    84   001677 00              		db	0		;null mask
    85   001678 f200            		dw	242		;disk size-1
    86   00167a 3f00            		dw	63		;directory max
    87   00167c c0              		db	192		;alloc 0
    88   00167d 00              		db	0		;alloc 1
    89   00167e 1000            		dw	16		;check size
    90   001680 0200            		dw	2		;track offset
    91                          ;
    92                          ;	end of fixed tables
    93                          ;
    94                          ;	individual subroutines to perform each function
    95                          boot:	;simplest case is to just perform parameter initialization
    96                          
    97                          ;	ld	sp, 80h		;use space below buffer for stack
    98                          
    99                          
   100                          ;	jp	gocpm		;initialize and go to cp/m
   101                          ;
   102                          bwboot:	;simplest case is to read the disk until all sectors loaded
   103   001682 318000          		ld	sp, 80h		;use space below buffer for stack
   104                          
   105                          ;		ld	HL, 0100h
   106                          ;		ld	DE, 0101h
   107                          ;		ld	BC, 0F0FFh
   108                          ;		ld	(HL), 0
   109                          ;		ldir
   110                          
   111   001685 214a19          		ld	HL, copyright
   112   001688 cdb317          		call	printstr
   113                          
   114                          boot2:
   115                          ;		xor	a		;zero in the accum
   116   00168b 320300          		ld	(iobyte), a	;clear the iobyte
   117   00168e 320400          		ld	(cdisk), a	;select disk zero
   118                          
   119                          ;		ld	a, 3
   120                          ;opendisks:
   121                          ;		ld	(diskno), a
   122                          ;		push	AF
   123                          ;		call	cmdOpenDisk
   124                          ;		pop	AF
   125                          ;		dec	a
   126                          ;		jp	P, opendisks
   127                          
   128   001691 0e00            		ld	c, 0		;select disk 0
   129                          
   130   001693 cd2217          		call	bseldsk
   131   001696 cd1c17          		call	bhome		;go to track 00
   132                          ;		jp	gocpm
   133                          ;
   134                          
   135   001699 062c            		ld	b, nsects	;b counts * of sectors to load
   136   00169b 0e00            		ld	c, 0		;c has the current track number
   137   00169d 1600            		ld	d, 0		;d has the next sector to read
   138                          ;		note that we begin by reading track 0, sector 2 since sector 1
   139                          ;		contains the cold start loader, which is skipped in a warm start
   140   00169f 2100e4          		ld	HL, ccp		;base of cp/m (initial load point)
   141                          load1:		;load	one more sector
   142   0016a2 c5              		push	BC		;save sector count, current track
   143   0016a3 d5              		push	DE		;save next sector to read
   144   0016a4 e5              		push	HL		;save dma address
   145   0016a5 4a              		ld	c, d		;get sector address to register C
   146   0016a6 cd3b17          		call	bsetsec		;set sector address from register C
   147   0016a9 c1              		pop	BC		;recall dma address to b, C
   148   0016aa c5              		push	BC		;replace on stack for later recall
   149   0016ab cd4317          		call	bsetdma		;set dma address from b, C
   150                          ;
   151                          ;		drive set to 0, track set, sector set, dma address set
   152   0016ae cd4817          		call	bread
   153                          ;		cp	00h		;any errors?
   154   0016b1 b7              		or	a
   155   0016b2 c28216          		jp	NZ, bwboot	;retry the entire boot if an error occurs
   156                          ;
   157                          ;		no error, lde to next sector
   158   0016b5 e1              		pop	HL		;recall dma address
   159   0016b6 118000          		ld	DE, 128		;dma=dma+128
   160   0016b9 19              		add	HL, DE		;new dma address is in h, l
   161   0016ba d1              		pop	DE		;recall sector address
   162   0016bb c1              		pop	BC		;recall number of sectors remaining, and current trk
   163   0016bc 05              		dec	b		;sectors=sectors-1
   164   0016bd cad416          		jp	Z, gocpm	;transfer to cp/m if all have been loaded
   165                          ;
   166                          ;		more	sectors remain to load, check for track change
   167   0016c0 14              		inc	d
   168   0016c1 7a              		ld	a, d		;sector=26?, if so, change tracks
   169                          
   170   0016c2 e5              		push	HL
   171   0016c3 2a3d16          		ld	HL, (dpbase + $a) ;load Hl with dpblk of drive A:
   172   0016c6 be              		cp	(HL)
   173   0016c7 e1              		pop	HL
   174   0016c8 daa216          		jp	C, load1	;carry generated if sector<26
   175                          ;
   176                          ;		end of	current track,	go to next track
   177   0016cb 1600            		ld	d, 0		;begin with first sector of next track
   178   0016cd 0c              		inc	c		;track=track+1
   179                          ;
   180                          ;		save	register state, and change tracks
   181                          ;		push	BC
   182                          ;		push	DE
   183                          ;		push	HL
   184   0016ce cd3617          		call	bsettrk		;track address set from register c
   185                          ;		pop	HL
   186                          ;		pop	DE
   187                          ;		pop	BC
   188   0016d1 c3a216          		jp	load1		;for another sector
   189                          ;
   190                          ;		end of	load operation, set parameters and go to cp/m
   191                          gocpm:
   192   0016d4 3ec3            		ld	a, 0c3h		;c3 is a jp instruction
   193   0016d6 320000          		ld	(0), a		;for jp to wboot
   194   0016d9 210316          		ld	HL, WBOOT	;wboot entry point
   195   0016dc 220100          		ld	(1), HL		;set address field for jp at 0
   196                          ;
   197   0016df 320500          		ld	(5), a		;for jp to bdos
   198   0016e2 2106ec          		ld	HL, bdos	;bdos entry point
   199   0016e5 220600          		ld	(6), HL		;address field of Jump at 5 to bdos
   200                          ;
   201   0016e8 018000          		ld	BC, 80h		;default dma address is 80h
   202   0016eb cd4317          		call	bsetdma
   203                          ;
   204                          ;		ei			;enable the interrupt system
   205   0016ee 3a0400          		ld	a, (cdisk)	;get current disk number
   206   0016f1 4f              		ld	c, a		;send to the ccp
   207   0016f2 c300e4          		jp	ccp		;go to cp/m for further processing
   208                          ;
   209                          ;
   210                          ;	simple i/o handlers (must be filled in by user)
   211                          ;	in each case, the entry point is provided, with space reserved
   212                          ;	to insert your own code
   213                          ;
   214                          bconst:		;console status, return 0ffh if character ready, 00h if not
   215                          ;		ds     10h		;space for status subroutine
   216                          ;		in     00h
   217                          
   218   0016f5 db01            		in	a, (STATA)
   219   0016f7 e601            		and	a, 1
   220   0016f9 c8              		ret	Z		; zero, not ready
   221   0016fa 3eff            		ld	a, 0ffh		; $ff, ready
   222   0016fc c9              		ret
   223                          ;
   224                          bconin:	;console character into register a
   225                          ;	ds	10h		;space for input routine
   226                          ;--------------------------------------------------------------
   227                          ; get a character in A from rs232 (1)
   228                          ;
   229                          ;--------------------------------------------------------------
   230                          chrin:
   231   0016fd db01            		in	a, (STATA)
   232   0016ff e601            		and	a, 1
   233   001701 28fa            		jr	Z, chrin
   234   001703 db03            		in	a, (RECA)
   235   001705 c9              		ret
   236                          
   237                          ;		in      01h
   238                          ;		and	7fh		;strip parity bit
   239                          ;		ret
   240                          ;
   241                          chrouta:
   242   001706 4f              		ld	c, a
   243                          bconout:	;console character output from register c
   244                          ;--------------------------------------------------------------
   245                          ; output a character in A over rs232 (1)
   246                          ;
   247                          ;--------------------------------------------------------------
   248                          chrout:
   249   001707 db01            		in	a, (STATA)
   250   001709 e604            		and	a, 4
   251   00170b 28fa            		jr	Z, chrout
   252   00170d 79              		ld	a, c
   253   00170e d303            		out	(TRANSA), a
   254   001710 c9              		ret
   255                          
   256                          ;		ld	a, c		;get to accumulator
   257                          ;		ds	10h		;space for output routine
   258                          ;		out     01h
   259                          ;		ret
   260                          ;
   261                          blist:		;list character from register c
   262   001711 79              		ld	a, c	  	;character to register a
   263   001712 c9              		ret		  	;null subroutine
   264                          ;
   265                          blistst:		;return list status (0 if not ready, 1 if ready)
   266   001713 af              		xor	a	 	;0 is always ok to return
   267   001714 c9              		ret
   268                          ;
   269                          bpunch:		;punch	character from	register C
   270   001715 79              		ld	a, c		;character to register a
   271   001716 c9              		ret			;null subroutine
   272                          ;
   273                          ;
   274                          breader:	;reader character into register a from reader device
   275   001717 3e1a            		ld    a, 1ah		;enter end of file for now (replace later)
   276   001719 e67f            		ani    7fh		;remember to strip parity bit
   277   00171b c9              		ret
   278                          ;
   279                          ;
   280                          ;		i/o drivers for the disk follow
   281                          ;		for now, we will simply store the parameters away for use
   282                          ;		in the read and write	subroutines
   283                          ;
   284                          bhome:		;lde to the track 00	position of current drive
   285                          ;		translate this call into a settrk call with Parameter 00
   286   00171c 0e00            		ld    c, 0		;select track 0
   287   00171e cd3617          		call   bsettrk
   288   001721 c9              		ret			;we will lde to 00 on first read/write
   289                          ;
   290                          bseldsk:	;select disk given by register c
   291   001722 210000          		ld	HL, 0000h	;error return code
   292   001725 79              		ld	a, c
   293   001726 320918          		ld	(diskno), a
   294   001729 fe04            		cp	4		;must be between 0 and 3
   295   00172b d0              		ret	NC			;no carry if 4, 5,...
   296                          ;		disk number is in the proper range
   297                          ;		ds	10		;space for disk select
   298                          ;		compute proper disk Parameter header address
   299                          ;		ld	a, (diskno)
   300   00172c 6f              		ld	l, a		;l=disk number 0, 1, 2, 3
   301                          ;		ld	h, 0		;high order zero
   302   00172d 29              		add	HL, HL		;*2
   303   00172e 29              		add	HL, HL		;*4
   304   00172f 29              		add	HL, HL		;*8
   305   001730 29              		add	HL, HL		;*16 (size of each header)
   306   001731 113316          		ld	DE, dpbase
   307   001734 19              		add	HL, DE		;hl=,dpbase (diskno*16)
   308   001735 c9              		ret
   309                          ;
   310                          bsettrk:	;set track given by register c
   311   001736 79              		ld	a, c
   312   001737 320a18          		ld	(track), a
   313                          
   314                          ;		push	BC
   315                          ;		ld	c, 'T'
   316                          ;		call	chrout
   317                          ;		pop	BC
   318                          ;		ld	a, c
   319                          ;		call	printhex
   320                          ;		pop	BC
   321                          ;		push	BC
   322                          ;		ld	a, b
   323                          ;		call	printhex
   324                          ;		ld	a, c
   325                          ;		call	printhex
   326   00173a c9              		ret
   327                          ;
   328                          bsetsec:	;set sector given by register c
   329   00173b 79              		ld	a, c
   330   00173c 320b18          		ld	(sector), a
   331                          
   332                          ;		push	BC
   333                          ;		ld	c, 'S'
   334                          ;		call	chrout
   335                          ;		pop	BC
   336                          ;		ld	a, c
   337                          ;		jp	printhex
   338   00173f c9              		ret
   339                          ;
   340                          ;
   341                          bsectran:
   342                          	;translate the sector given by bc using the
   343                          	;translate table given by de
   344   001740 69              		ld	l, c
   345   001741 60              		ld	h, b
   346   001742 c9              		ret
   347                          
   348                          ;		xchg			;hl=.trans
   349                          ;		dad	b		;hl=.trans (sector)
   350                          ;		ld	l, m		;l=trans (sector)
   351                          ;		ld	h, 0		;hl=trans (sector)
   352                          ;		ret			;with value in hl
   353                          ;
   354                          bsetdma:	;set	dma address given by registers b and c
   355                          ;		ld	l, c		;low order address
   356                          ;		ld	h, b		;high order address
   357   001743 ed430c18        		ld	(dmaad), BC	;save the address
   358   001747 c9              		ret
   359                          
   360                          ;
   361                          bread:
   362                          		;perform read operation (usually this is similar to write
   363                          		;so we will allow space to set up read command, then use
   364                          		;common code in write)
   365                          
   366                          ;		ld	c, 'R'
   367                          ;		call	chrout
   368                          
   369                          ;		call	newline
   370                          ;;		call	cmdGetSector
   371                          ;		call	newline
   372                          
   373                          ;		ld	a, (seclen)
   374                          ;		cp	128
   375                          ;		jp	NZ, error
   376                          ;
   377                          ;		ld	HL, secdata		;copy ROM to RAM from
   378                          ;		ld	DE, (dmaad)		;to
   379                          ;		ld	BC, 128			;length
   380                          ;		ldir
   381                          
   382                          readsec:
   383   001748 3e52            		ld	a, 'R'		;read
   384   00174a cdde17          		call	serout
   385   00174d 3a0918          		ld	a, (diskno)	;disk 0
   386   001750 cdde17          		call	serout
   387   001753 3a0a18          		ld	a, (track)	;track 2
   388   001756 cdde17          		call	serout
   389   001759 3a0b18          		ld	a, (sector)	;sector 0
   390   00175c cdde17          		call	serout
   391                          
   392   00175f cdcb17          		call	serin		;check ack
   393   001762 38e4            		jr	C, readsec	;timeout?, redo
   394                          
   395                          readsec3:
   396   001764 fe41            		cp	'A'
   397   001766 2803            		jr	Z, readsec2	;ack OK
   398   001768 3e01            		ld	a, 1		;else return 1 (= unrecov. error)
   399   00176a c9              		ret
   400                          readsec2:
   401   00176b 2a0c18          		ld	hl, (dmaad)
   402   00176e 1680            		ld	d, 128
   403   001770 cdcb17          readsec1:	call	serin
   404   001773 77              		ld	(hl), a
   405   001774 23              		inc	hl
   406   001775 15              		dec	d
   407   001776 20f8            		jr	NZ, readsec1
   408                          
   409                          ;		call	newline
   410                          ;		ld	hl, (dmaad)
   411                          ;		ld	b, 128
   412                          ;		ld	d, 16
   413                          ;readsec4:	ld	a, (hl)
   414                          ;		inc	hl
   415                          ;		call	printhex
   416                          ;		call	space
   417                          ;		dec	d
   418                          ;		jr	nz, readsec5
   419                          ;		ld	d, 16
   420                          ;		call	newline
   421                          ;readsec5:	djnz	b, readsec4
   422                          
   423                          
   424   001778 af              		xor	a
   425   001779 c9              		ret
   426                          ;		jp	waitio		;to perform the actual i/o
   427                          ;
   428                          bwrite:
   429                          		;perform a write operation
   430                          		;ds	10h		;set up write command
   431                          		;ld	c, 'W'
   432                          		;call	chrout
   433                          		;out	02h
   434                          ;;		call	cmdPutSector
   435                          writesec:
   436   00177a 3e57            		ld	a, 'W'		;write
   437   00177c cdde17          		call	serout
   438   00177f 3a0918          		ld	a, (diskno)	;disk 0
   439   001782 cdde17          		call	serout
   440   001785 3a0a18          		ld	a, (track)	;track 2
   441   001788 cdde17          		call	serout
   442   00178b 3a0b18          		ld	a, (sector)	;sector 0
   443   00178e cdde17          		call	serout
   444                          
   445   001791 0680            		ld	b, 128
   446   001793 2a0c18          		ld	hl, (dmaad)
   447   001796 7e              writesec1:	ld	a, (hl)
   448   001797 23              		inc	hl
   449   001798 cdde17          		call	serout
   450   00179b 10f9            		djnz	b, writesec1
   451                          
   452   00179d cdcb17          		call	serin		;check ack
   453   0017a0 3806            		jr	C, writesec2	;timeout?, error
   454   0017a2 fe41            		cp	a, 'A'		;ack?
   455   0017a4 2002            		jr	NZ, writesec2	;no error
   456                          
   457   0017a6 af              		xor	a
   458   0017a7 c9              		ret
   459                          
   460   0017a8 3e01            writesec2:	ld	a, 1
   461   0017aa c9              		ret
   462                          
   463                          copystr:
   464   0017ab 7e              		ld	a, (HL)
   465   0017ac b7              		or	a
   466   0017ad c8              		ret	Z
   467   0017ae 12              		ld	(DE), a
   468   0017af 23              		inc	HL
   469   0017b0 13              		inc	DE
   470   0017b1 18f8            		jr	copystr
   471                          
   472                          printstr:
   473   0017b3 af              		xor	a
   474   0017b4 86              		add	a, (HL)
   475   0017b5 c8              		ret	Z
   476   0017b6 cd0617          		call	chrouta
   477   0017b9 23              		inc	HL
   478   0017ba 18f7            		jr	printstr
   479                          
   480                          space:
   481   0017bc 0e20            		ld	c, 32
   482   0017be c30717          		jp	chrout
   483                          
   484                          newline:
   485   0017c1 0e0d            		ld	c, 13
   486   0017c3 cd0717          		call	chrout
   487   0017c6 0e0a            		ld	c, 10
   488   0017c8 c30717          		jp	chrout
   489                          
   490                          ;--------------------------------------------------------------
   491                          ; get a character in A from rs232 (2)
   492                          ;
   493                          ;--------------------------------------------------------------
   494   0017cb 010000          serin:		ld	bc, 0
   495   0017ce db09            serin1:		in	a, (STATB)
   496   0017d0 e601            		and	a, 1
   497   0017d2 2007            		jr	NZ, serin2
   498   0017d4 10f8            		djnz	b, serin1
   499   0017d6 0d              		dec	c
   500   0017d7 20f5            		jr	NZ, serin1
   501   0017d9 37              		scf
   502   0017da c9              		ret
   503   0017db db0b            serin2:		in	a, (RECB)
   504   0017dd c9              		ret
   505                          
   506                          ;--------------------------------------------------------------
   507                          ; output a character in A over rs232 (1)
   508                          ;
   509                          ;--------------------------------------------------------------
   510                          serout:
   511   0017de f5              		push	AF
   512   0017df db09            serout1:	in	a, (STATB)
   513   0017e1 e604            		and	a, 4
   514   0017e3 28fa            		jr	Z, serout1
   515   0017e5 f1              		pop	AF
   516   0017e6 d30b            		out	(TRANSB), a
   517   0017e8 c9              		ret
   518                          
   519                          ;--------------------------------------------------------------
   520                          ; prints byte in A in hexadecimal format
   521                          ;--------------------------------------------------------------
   522                          printhex:
   523   0017e9 f5              		push    AF
   524   0017ea f5              		push    AF
   525   0017eb 1f              		rra
   526   0017ec 1f              		rra
   527   0017ed 1f              		rra
   528   0017ee 1f              		rra
   529   0017ef cdf817          		call    printnib
   530   0017f2 f1              		pop     AF
   531   0017f3 cdf817          		call    printnib
   532   0017f6 f1              		pop     AF
   533   0017f7 c9              		ret
   534                          printnib:
   535   0017f8 e60f            		and     0fh
   536   0017fa fe0a            		cp      0ah
   537   0017fc 3802            		jr      C, printnib1
   538   0017fe c607            		add     a, 07h
   539                          printnib1:
   540   001800 c630            		add     a, '0'
   541                          print:
   542   001802 c5              		push    BC
   543   001803 4f              		ld      c, a
   544   001804 cd0717          		call    chrout
   545   001807 c1              		pop     BC
   546   001808 c9              		ret
   547                          
   548                          ;
   549                          ;waitio:	;enter	here from read	and write to perform the actual i/o
   550                          ;		operation. return a 00h in register a if the operation completes
   551                          ;		properly, and 0lh if an error occurs during the read or write
   552                          ;
   553                          ;		in this case, we have saved the disk number in 'diskno' (0, 1)
   554                          ;				the track number in 'track' (0-76)
   555                          ;				the sector number in 'sector' (1-26)
   556                          ;				the dma address in 'dmaad' (0-65535)
   557                          ;		ds	256		;space reserved for i/o drivers
   558                          ;		ld	a, 1		;error condition
   559                          ;		ret			;replaced when filled-in
   560                          ;
   561                          ;		the remainder of the cbios is reserved uninitialized
   562                          ;		data area, and does not need to be a Part of the
   563                          ;		system	memory image (the space must be available,
   564                          ;		however, between"begdat" and"enddat").
   565                          ;
   566   001809 00              diskno:		ds	1		;disk number 0-15
   567   00180a 00              track:		ds	1		;two bytes for expansion
   568   00180b 00              sector:		ds	1		;two bytes for expansion
   569   00180c 0000            dmaad:		ds	2		;direct memory address
   570                          ;
   571                          ;		scratch ram area for bdos use
   572                          begdat		equ	$	 	;beginning of data area
   573   00180e 0000000000000000dirbf:		ds	128	 	;scratch directory area
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
   574   00188e 0000000000000000all00:		ds	31	 	;allocation vector 0
                0000000000000000
                0000000000000000
                00000000000000  
   575   0018ad 0000000000000000all01:		ds	31	 	;allocation vector 1
                0000000000000000
                0000000000000000
                00000000000000  
   576   0018cc 0000000000000000all02:		ds	31	 	;allocation vector 2
                0000000000000000
                0000000000000000
                00000000000000  
   577   0018eb 0000000000000000all03:		ds	31	 	;allocation vector 3
                0000000000000000
                0000000000000000
                00000000000000  
   578   00190a 0000000000000000chk00:		ds	16		;check vector 0
                0000000000000000
   579   00191a 0000000000000000chk01:		ds	16		;check vector 1
                0000000000000000
   580   00192a 0000000000000000chk02:		ds	16	 	;check vector 2
                0000000000000000
   581   00193a 0000000000000000chk03:		ds	16	 	;check vector 3
                0000000000000000
   582                          ;
   583                          enddat		equ	$	 	;end of data area
   584                          datsiz		equ	$-begdat;	;size of data area
   585                          
   586                          
   587                          		IFDEF NOEXCLUDE
   588                          cmdOpenDisk:
   589                          		ld	a, (diskno)
   590                          		call	bin2deca
   591                          		ld	HL, opendiskno
   592                          		call	dec2disp
   593                          		ld	HL, (opendiskno)
   594                          		ld	(opendiskno1), HL
   595                          
   596                          		ld	HL, opendisk
   597                          		jp	sendCommand
   598                          
   599                          
   600                          cmdPutSector:
   601                          		ld	a, (diskno)		; write diskno
   602                          		call	bin2deca		; in paintext
   603                          		ld	HL, putsdisk		; to getsdisk
   604                          		call	dec2disp
   605                          		ld	a, (track)		; write track
   606                          		call	bin2deca
   607                          		ld	HL, putstrack
   608                          		call	dec2disp
   609                          		ld	a, (sector)		; write sector
   610                          		call	bin2deca
   611                          		ld	HL, putssector
   612                          		call	dec2disp
   613                          
   614                          		ld	HL, (dmaad)		;128 from (dmadat)
   615                          		ld	DE, secdata		;to secdata
   616                          		ld	BC, 128			;set length length
   617                          		ld	(seclen), BC
   618                          		ldir
   619                          
   620                          		ld	DE, seclen
   621                          		ld	HL, putsdata-2
   622                          		call	codeBase64
   623                          		ld	HL, 00a0dh
   624                          		ld	(putsdata-2), HL
   625                          
   626                          		ld	HL, putsector
   627                          		jp	sendCommand
   628                          
   629                          
   630                          cmdGetSector:
   631                          		ld	a, (diskno)		; write diskno
   632                          		call	bin2deca		; in paintext
   633                          		ld	HL, getsdisk		; to getsdisk
   634                          		call	dec2disp
   635                          		ld	a, (track)		; write track
   636                          		call	bin2deca
   637                          		ld	HL, getstrack
   638                          		call	dec2disp
   639                          		ld	a, (sector)		; write sector
   640                          		call	bin2deca
   641                          		ld	HL, getssector
   642                          		call	dec2disp
   643                          
   644                          		ld	HL, getsector		; send the sector-command
   645                          		call	sendCommand
   646                          
   647                          ;		ld	a, h
   648                          ;		call	printhex
   649                          ;		ld	a, l
   650                          ;		call	printhex
   651                          ;		ld	a, d
   652                          ;		call	printhex
   653                          ;		ld	a, e
   654                          ;		call	printhex
   655                          ;		ld	c, 32
   656                          ;		call	chrout
   657                          
   658                          		ex	DE, HL			;DE = OK + 5
   659                          		dec	HL			;HL - 4
   660                          		dec	HL
   661                          		dec	HL
   662                          		dec	HL
   663                          		xor	a
   664                          		ld	(HL), a
   665                          		ld	a, 172			;decode from
   666                          		dec	HL
   667                          		ld	(HL), a
   668                          		ld	DE, seclen		;into seclen
   669                          		jp	decodeBase64
   670                          
   671                          
   672                          
   673                          sendCommand:
   674                          		push	HL
   675                          		push	HL
   676                          
   677                          		ld	HL, atstatus		;status of connection
   678                          		call	writeesp
   679                          		ld	a, (line + 21)
   680                          		cp	'3'
   681                          		jp	Z, sendCommand1		;if 3 send command
   682                          
   683                          sendCommand3:
   684                          		ld	HL, connect
   685                          		call	writeesp
   686                          		jr	NC, sendCommand1
   687                          
   688                          enterIP:
   689                          		ld	HL, iptext
   690                          		call	printstr
   691                          		call	getline
   692                          		ld	HL, line
   693                          		ld	DE, connectip
   694                          		call	copystr
   695                          
   696                          		dec	DE
   697                          		ld	HL, porttext
   698                          		call	copystr
   699                          		ld	(DE), a
   700                          ;		jp	error
   701                          		jr	sendCommand3
   702                          
   703                          sendCommand1:
   704                          		pop	HL
   705                          		call	strlen			;length in DE
   706                          ;		ld	a, d
   707                          ;		call	printhex
   708                          ;		ld	a, e
   709                          ;		call	printhex
   710                          		call	bin2dec			;e in hex to a in dec
   711                          		ld	HL, cipsendlenl		;prite dec to display
   712                          		call	dec2disp
   713                          		ld	HL, 03030h		;"00" into
   714                          		ld	(cipsendlenh), HL
   715                          		ld	a, d
   716                          		or	a
   717                          		jr	Z, sendCommand2
   718                          		ld	HL, 03230h		;02
   719                          		ld	(cipsend+11), HL
   720                          		ld	HL, 03638h		;86
   721                          		ld	(cipsend+13), HL
   722                          
   723                          sendCommand2:
   724                          		ld	HL, cipsend
   725                          		call	writeesp
   726                          		jr	NC, sendCommand4
   727                          		pop	HL
   728                          		xor	a
   729                          		call	printhex
   730                          		jr	sendCommand
   731                          
   732                          
   733                          ;		call	prtline
   734                          sendCommand4:
   735                          		call	espin
   736                          		call	espin
   737                          
   738                          
   739                          		pop	HL
   740                          		push	HL
   741                          		call	writeesp
   742                          		pop	HL
   743                          		ret
   744                          
   745                          ;		ret	NC
   746                          ;		ld	a, 1
   747                          ;		call	printhex
   748                          ;		jr	sendCommand
   749                          
   750                          
   751                          error:
   752                          		ld	b, 0
   753                          e1:		djnz	e1
   754                          		ld	a, 080h			;OP7 = HIGH
   755                          		out	(OPRES), a
   756                          		jp	0
   757                          
   758                          connect:	DB	"AT+CIPSTART=\"TCP\",\""
   759                          connectip:	DB	"192.168.178.22"
   760                          		DB	"\","
   761                          connectport:	DB	"4434",13,10,0,0,0
   762                          
   763                          cipsend:	DB	"AT+CIPSEND="
   764                          cipsendlenh:	DB	"00"
   765                          cipsendlenl:	DB	"xx",13,10,0
   766                          
   767                          opendisk:	DB	"GET /disk?func=open&disk="
   768                          opendiskno:	DB	"00"
   769                          		DB	"&filename=disk"
   770                          opendiskno1:	DB	"00.dsk HTTP/1.0",13,10,13,10,0
   771                          
   772                          getsector:	DB	"GET /sectordata?disk="
   773                          getsdisk:	DB	"00"
   774                          		DB	"&track="
   775                          getstrack:	DB	"00"
   776                          		DB	"&sector="
   777                          getssector:	DB	"00"
   778                          		DB	" HTTP/1.1",13,10
   779                          		DB	"Host: roland.z80",13,10,13,10,0
   780                          
   781                          putsector:	DB	"PUT /sectordata?disk="
   782                          putsdisk:	DB	"00"
   783                          		DB	"&track="
   784                          putstrack:	DB	"00"
   785                          		DB	"&sector="
   786                          putssector:	DB	"00"
   787                          		DB	" HTTP/1.0",13,10
   788                          		DB	"Host: roland.z80",13,10
   789                          		DB	"Accept: text/plain",13,10
   790                          		DB	"Content-Length: 172",13,10,13,10
   791                          putsdata:	DS	172
   792                          		DB	0
   793                          atstatus:	DB	"AT+CIPSTATUS",13,10,0
   794                          iptext:		DB	13,10,"IP:",0
   795                          porttext:	DB	"\",4434",13,10,0
   796                          
   797                          
   798                          ;--------------------------------------------------------------
   799                          ; DE: Pointer to input-area
   800                          ; HL: Base64 coded output input
   801                          ;
   802                          ; area: 2-byte          len
   803                          ;       xxx-byte        data
   804                          ;--------------------------------------------------------------
   805                          codeBase64:
   806                          		push    HL              ; IY = ptr to out-length
   807                          		pop     IY
   808                          		inc     HL
   809                          		inc     HL
   810                          		push    HL              ; save ptr to out-data
   811                          
   812                          		ld      a, (DE)
   813                          		neg
   814                          		ld      c, a
   815                          		inc     DE
   816                          		ld      a, (DE)
   817                          		neg
   818                          		ld      b, a
   819                          		inc     DE              ; BC = in-len
   820                          		push    BC
   821                          		pop     IX
   822                          		add     IX, DE
   823                          
   824                          		ld      c, 0
   825                          
   826                          code_loop1:
   827                          		ex      DE, HL          ;switch to input-pointer
   828                          		ld      a, c
   829                          		inc     c
   830                          		and     3
   831                          
   832                          		jr      NZ, code1
   833                          
   834                          		ld      a, (HL)
   835                          		rra
   836                          		rra
   837                          		and     00111111b
   838                          		call    codeB64
   839                          		jr      code_loop
   840                          
   841                          code1:
   842                          		dec     a
   843                          		jr      NZ, code2
   844                          		ld      a, (HL)
   845                          		rla
   846                          		rla
   847                          		rla
   848                          		rla
   849                          		and     00110000b
   850                          		ld      b, a
   851                          		inc     HL
   852                          		ld      a, (HL)
   853                          		rra
   854                          		rra
   855                          		rra
   856                          		rra
   857                          		and     %00001111
   858                          		or      b
   859                          		call    codeB64
   860                          		jr      code_loop
   861                          
   862                          code2:
   863                          		dec     a
   864                          		jr      NZ, code3
   865                          		ld      a, (HL)
   866                          		rla
   867                          		rla
   868                          		and     00111100b
   869                          		ld      b, a
   870                          		inc     HL
   871                          		ld      a, (HL)
   872                          		rlca
   873                          		rlca
   874                          		and     00000011b
   875                          		or      b
   876                          		call    codeB64
   877                          
   878                          code_loop:
   879                          		ex      DE, HL                  ;switch to output-pointer
   880                          		ld      (HL), a                 ;store base64 symbol
   881                          		inc     HL
   882                          		jr      code_loop1
   883                          
   884                          code3:
   885                          		ld      a, (HL)
   886                          		inc     HL
   887                          		and     00111111b
   888                          		call    codeB64
   889                          
   890                          		ex      DE, HL                  ;switch HL to output-pointer
   891                          		ld      (HL), a                 ;store base64 symbol
   892                          		inc     HL
   893                          
   894                          		push    DE
   895                          		push    HL
   896                          		ex      DE, HL
   897                          		push    IX
   898                          		pop     DE
   899                          		sbc     HL, DE
   900                          		ld      b, l
   901                          		pop     HL
   902                          		pop     DE
   903                          
   904                          		jp      M, code_loop1
   905                          		push    HL
   906                          code3a:
   907                          		jr      Z, code3b
   908                          		dec     HL
   909                          		ld      (HL), '='
   910                          		djnz    code3a
   911                          code3b:
   912                          		pop     HL
   913                          		pop     DE
   914                          		sbc     HL, DE
   915                          		ld      (IY), l
   916                          		ld      (IY + 1), h
   917                          		ret
   918                          
   919                          
   920                          
   921                          ;--------------------------------------------------------------
   922                          ; DE: Pointer to output-area
   923                          ; HL: Base64 coded input
   924                          ;
   925                          ; area: 2-byte          len
   926                          ;       xxx-byte        data
   927                          ;--------------------------------------------------------------
   928                          decodeBase64:
   929                          		ld      c, (HL)                 ; load lo, hi length
   930                          		inc     HL
   931                          		ld      b, (HL)
   932                          		inc     HL
   933                          		push    BC
   934                          		exx
   935                          		pop     BC                      ; put length in BC'
   936                          		exx
   937                          
   938                          		ld      c, 0
   939                          
   940                          		push    DE                      ; save out-ptr on stack
   941                          		inc     DE                      ; skip-out-length
   942                          		inc     DE
   943                          		push    DE                      ; save it, too
   944                          
   945                          decode_loop1:
   946                          		call    decodeB64               ; load in-byte in (HL) and decode into a
   947                          		ld      b, a
   948                          		ld      a, c
   949                          		inc     c
   950                          		jr      C, decode_loop2         ; if decodeB64 has set Carry, input was '='
   951                          
   952                          		inc     HL                      ; increment input-pointer
   953                          		ex      DE, HL                  ; switch to output-pointer
   954                          		and     3
   955                          
   956                          		jr      NZ, decode1
   957                          
   958                          		ld      a, b
   959                          		rla
   960                          		rla
   961                          		and     11111100b
   962                          		ld      (HL), a
   963                          		jr      decode_loop
   964                          
   965                          decode1:
   966                          		dec     a
   967                          		jr      NZ, decode2
   968                          		ld      a, b
   969                          		rra
   970                          		rra
   971                          		rra
   972                          		rra
   973                          		and     00000011b
   974                          		or      (HL)
   975                          		ld      (HL), a
   976                          		inc     HL
   977                          		ld      a, b
   978                          		rla
   979                          		rla
   980                          		rla
   981                          		rla
   982                          		and     11110000b
   983                          		ld      (HL), a
   984                          		jr      decode_loop
   985                          
   986                          decode2:
   987                          		dec     a
   988                          		jr      NZ, decode3
   989                          		ld      a, b
   990                          		rra
   991                          		rra
   992                          		and     00001111b
   993                          		or      (HL)
   994                          		ld      (HL), a
   995                          		inc     HL
   996                          		ld      a, b
   997                          		rrca
   998                          		rrca
   999                          		and     11000000b
  1000                          		ld      (HL), a
  1001                          		jr      decode_loop
  1002                          
  1003                          decode3:
  1004                          		ld      a, b
  1005                          		or      (HL)
  1006                          		ld      (HL), a
  1007                          		inc     HL
  1008                          
  1009                          decode_loop:
  1010                          		ex      DE, HL                  ; switch to input-pointer
  1011                          
  1012                          		exx
  1013                          		dec     BC
  1014                          		ld      a, b
  1015                          		or      c
  1016                          		exx
  1017                          		jr      NZ, decode_loop1
  1018                          
  1019                          decode_loop2:
  1020                          		ex      DE, HL                  ; switch to output-pointer
  1021                          		pop     DE                      ; get start of output
  1022                          
  1023                          		or      a                       ; reset carry!
  1024                          		sbc     HL, DE                  ; len = end - start
  1025                          		pop     DE                      ; load address of output-len
  1026                          		ex      DE, HL                  ; switch to output-len
  1027                          		ld      (HL), E                 ; save len
  1028                          		inc     HL
  1029                          		ld      (HL), D
  1030                          		ret
  1031                          
  1032                          
  1033                          
  1034                          decodeB64:
  1035                          		ld      a, (HL)
  1036                          
  1037                          		cp      '='
  1038                          		jr      NZ, decodeB64e
  1039                          		xor     a
  1040                          		scf
  1041                          		ret
  1042                          decodeB64e:
  1043                          		cp      '+'
  1044                          		jr      NZ, decodeB64a
  1045                          		ld      a, 62
  1046                          		ret
  1047                          decodeB64a:
  1048                          		cp      '/'
  1049                          		jr      NZ, decodeB64b
  1050                          		ld      a, 63
  1051                          		ret
  1052                          decodeB64b:
  1053                          		cp      ':'
  1054                          		jr      NC, decodeB64c          ; not 0-9?
  1055                          		add     a, 4                    ; '0' = 48 -> 52
  1056                          		ret
  1057                          decodeB64c:
  1058                          		cp      'Z'+1
  1059                          		jr      NC, decodeB64d          ; not A-Z?
  1060                          		sub     'A'                     ; 'A' = 65 -> 0
  1061                          		ret
  1062                          decodeB64d:                             	; then a-z
  1063                          		sub     71
  1064                          		ret
  1065                          
  1066                          
  1067                          
  1068                          codeB64:
  1069                          		cp      26
  1070                          		jr      NC, codeB64a
  1071                          		add     a, 'A'                     ; < 0-25
  1072                          		ret
  1073                          codeB64a:
  1074                          		cp      52
  1075                          		jr      NC, codeB64b
  1076                          		add     a, 71
  1077                          		ret
  1078                          codeB64b:
  1079                          		cp      62
  1080                          		jr      NC, codeB64c
  1081                          		sub     4
  1082                          		ret
  1083                          codeB64c:
  1084                          		cp      62
  1085                          		jr      NZ, codeB64d
  1086                          		ld      a, '+'
  1087                          		ret
  1088                          codeB64d:
  1089                          		ld      a, '/'
  1090                          		ret
  1091                          ;
  1092                          ;
  1093                          ;
  1094                          dec2disp:	push    af
  1095                          		rrca
  1096                          		rrca
  1097                          		rrca
  1098                          		rrca
  1099                          		call    dec2nibble
  1100                          		inc	HL
  1101                          		pop     af
  1102                          
  1103                          dec2nibble:   	or      0xf0
  1104                          		daa
  1105                          		add     a,0xa0
  1106                          		adc     a,0x40
  1107                          		ld	(HL), a
  1108                          		ret
  1109                          
  1110                          
  1111                          bin2deca:	ld	e, a
  1112                          bin2dec:	ld	b, 8
  1113                          		xor	a
  1114                          bin2dec1:	rlc	e
  1115                          		adc	a, a
  1116                          		daa
  1117                          		djnz	bin2dec1
  1118                          		ret
  1119                          
  1120                          
  1121                          
  1122                          strlen:		ld	DE, 0
  1123                          strlen1:
  1124                          		ld	a, (HL)
  1125                          		or	a
  1126                          		ret	z
  1127                          		inc	DE
  1128                          		inc	HL
  1129                          		jr	strlen1
  1130                          
  1131                          
  1132                          
  1133                          getesp:
  1134                          		ld	HL, line
  1135                          getesp2:
  1136                          		push	HL
  1137                          		pop	DE		; DE = HL
  1138                          getesp1:
  1139                          		call	espin
  1140                          		ld	(HL), a
  1141                          		inc	HL
  1142                          		cp	10
  1143                          		jr	NZ, getesp1	; read until EOL
  1144                          
  1145                          		ex	DE, HL
  1146                          		ld	a, (HL)
  1147                          		inc	HL
  1148                          		ld	b, (HL)
  1149                          		inc	HL
  1150                          		inc	HL
  1151                          		inc	HL
  1152                          		inc	HL
  1153                          		ld	c, (HL)
  1154                          		ex	DE, HL
  1155                          		cp	'O'		; "OK"?
  1156                          		jr	Z, getespK
  1157                          		cp	'E'		; "ERR"?
  1158                          		jr	Z, getespR
  1159                          		ld	a, c
  1160                          		cp	'F'		; "FAIL"?
  1161                          		jr	NZ, getesp2
  1162                          		ex	DE, HL
  1163                          		inc	HL
  1164                          		ld	a, (HL)
  1165                          		ex	DE, HL
  1166                          		cp	'A'
  1167                          		jr	Z, getesperr
  1168                          		jr	getesp2
  1169                          
  1170                          getespK:	ld	a, b
  1171                          		cp	'K'
  1172                          		jr	NZ, getesp2
  1173                          		xor	a
  1174                          		ld	(HL), a
  1175                          		ret
  1176                          
  1177                          getespR:	ld	a, b
  1178                          		cp	'R'
  1179                          		jr	NZ, getesp2
  1180                          getesperr:	xor	a
  1181                          		ld	(HL), a
  1182                          		scf
  1183                          		ret
  1184                          
  1185                          getespE:	ld	a, b
  1186                          		cp	'E'
  1187                          		jr	NZ, getesp2
  1188                          		jr	getesperr
  1189                          writeesp:
  1190                          		ld	a, (HL)
  1191                          		or	a
  1192                          		jr	Z, getesp
  1193                          		call	espout
  1194                          ;		call	chrout
  1195                          		inc	HL
  1196                          		jr	writeesp
  1197                          
  1198                          putesp:
  1199                          		ld	HL, line
  1200                          putesp1:
  1201                          		ld	a, (HL)
  1202                          		cp	10
  1203                          		jr	NZ, putesp2
  1204                          		ld	a, 13
  1205                          		call	espout
  1206                          		ld	a, 10
  1207                          		jp	espout
  1208                          putesp2:	call	espout
  1209                          		inc	HL
  1210                          		jr	putesp1
  1211                          
  1212                          
  1213                          
  1214                          getline:	ld	HL, line-1
  1215                          getline1:
  1216                          		inc	HL
  1217                          		call	chrin
  1218                          		ld	(HL), a
  1219                          		call	chrouta
  1220                          ;		ld	a, c
  1221                          		cp	a, 10
  1222                          		jr	NZ, getline1
  1223                          		xor	a
  1224                          		ld	(HL), a
  1225                          		ret
  1226                          
  1227                          prtline:
  1228                          		ld	HL, line
  1229                          prtline1:
  1230                          		ld	a, (HL)
  1231                          		inc	HL
  1232                          		or	a
  1233                          		ret	Z
  1234                          		call	chrouta
  1235                          		jr	prtline1
  1236                          
  1237                          ;--------------------------------------------------------------
  1238                          ; get a character in A from rs232 (2)
  1239                          ;
  1240                          ;--------------------------------------------------------------
  1241                          espin:
  1242                          		in	a, (STATB)
  1243                          		and	a, 1
  1244                          		jr	Z, espin
  1245                          		in	a, (RECB)
  1246                          		ret
  1247                          
  1248                          espstat:	in	a, (STATB)
  1249                          		and	a, 1
  1250                          		ret
  1251                          
  1252                          ;--------------------------------------------------------------
  1253                          ; output a character in A over rs232 (2)
  1254                          ;
  1255                          ;--------------------------------------------------------------
  1256                          espout:
  1257                          		push	AF
  1258                          espout1:	in	a, (STATB)
  1259                          		and	a, 4
  1260                          		jr	Z, espout1
  1261                          		pop	AF
  1262                          		out	(TRANSB), a
  1263                          		ret
  1264                          
  1265                          line:		DS	300
  1266                          
  1267                          seclen:		DS	2
  1268                          secdata:	DS	128
  1269                          		ENDIF
  1270                          
  1271   00194a 1b5b6d0d        copyright:	DB	27, "[m", 13
  1272   00194e 5a383020        		DB	"Z80 "
  1273   001952 1b5b33356d46611b		DB	27, "[35mFa", 27, "[m"
                5b6d            
  1274   00195c 62756c6f757320  		DB	"bulous "
  1275   001963 1b5b33326d42691b		DB	27, "[32mBi", 27, "[m"
                5b6d            
  1276   00196d 6e61727920      		DB	"nary "
  1277   001972 1b5b33366d416e1b		DB	27, "[36mAn", 27, "[m"
                5b6d            
  1278   00197c 6968696c61746f72		DB	"ihilator",13
                0d              
  1279   001985 43502f4d20322e32		DB	"CP/M 2.2 Copyright 1979 (c) by Digital Research"
                20436f7079726967
                6874203139373920
                2863292062792044
                69676974616c2052
                65736561726368  
  1280   0019b4 00              		DB	0
  1281                          
  1282                          
  1283                          
  1284                          
  1285                          ;	end
  1286                          
cpm22z80.asm:
  3740                          
