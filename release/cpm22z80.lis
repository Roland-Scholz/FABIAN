cpm22z80.asm:
     1                          ;**************************************************************
     2                          ;*
     3                          ;*             C P / M   version   2 . 2
     4                          ;*
     5                          ;*   Reconstructed from memory image on February 27, 1981
     6                          ;*
     7                          ;*                by Clark A. Calkins
     8                          ;*
     9                          ;**************************************************************
    10                          ;
    11                          ; Set memory limit here. This is the amount of contigeous
    12                          ; ram starting from 0000. CP/M will reside at the end of this space.
    13                          ;
    14                          MEM	EQU	62		;for a 62k system (TS802 TEST - WORKS OK).
    15                          BIOS	EQU	(MEM-7)*1024 + $1600
    16                          ;
    17                          IOBYTE	EQU	3		;i/o definition byte.
    18                          TDRIVE	EQU	4		;current drive name and user number.
    19                          ENTRY	EQU	5		;entry point for the cp/m bdos.
    20                          TFCB	EQU	5CH		;default file control block.
    21                          TBUFF	EQU	80H		;i/o buffer and command line storage.
    22                          TBASE	EQU	100H		;transiant program storage area.
    23                          ;
    24                          ;   Set control character equates.
    25                          ;
    26                          CNTRLC	EQU	3		;control-c
    27                          CNTRLE	EQU	05H		;control-e
    28                          BS	EQU	08H		;backspace
    29                          TAB	EQU	09H		;tab
    30                          LF	EQU	0AH		;line feed
    31                          FF	EQU	0CH		;form feed
    32                          CR	EQU	0DH		;carriage return
    33                          CNTRLP	EQU	10H		;control-p
    34                          CNTRLR	EQU	12H		;control-r
    35                          CNTRLS	EQU	13H		;control-s
    36                          CNTRLU	EQU	15H		;control-u
    37                          CNTRLX	EQU	18H		;control-x
    38                          CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
    39                          DEL	EQU	7FH		;rubout
    40                          ;
    41                          ;   Set origin for CP/M
    42                          ;
    43                          	ORG	(MEM-7)*1024
    44                          ;
    45   000000 c35c03          CBASE:	JP	COMMAND		;execute command processor (ccp).
    46   000003 c35803          	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
    47                          
    48                          ;
    49                          ;   Standard cp/m ccp input buffer. Format is (max length),
    50                          ; (actual length), (char #1), (char #2), (char #3), etc.
    51                          ;
    52   000006 7f              INBUFF:	DB	127		;length of input buffer.
    53   000007 00              	DB	0		;current length of contents.
    54   000008 436f707972696768	DB	"Copyright"
                74              
    55   000011 2031393739202863	DB	" 1979 (c) by Digital Research      "
                2920627920446967
                6974616c20526573
                6561726368202020
                202020          
    56   000034 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                00000000000000  
    57   00004b 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                00000000000000  
    58   000062 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                00000000000000  
    59   000079 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                00000000000000  
    60   000088 0800            INPOINT:DW	INBUFF+2	;input line pointer
    61   00008a 0000            NAMEPNT:DW	0		;input line pointer used for error message. Points to
    62                          ;			;start of name in error.
    63                          ;
    64                          ;   Routine to print (A) on the console. All registers used.
    65                          ;
    66   00008c 5f              PRINT:	LD	E,A		;setup bdos call.
    67   00008d 0e02            	LD	C,2
    68   00008f c30500          	JP	ENTRY
    69                          ;
    70                          ;   Routine to print (A) on the console and to save (BC).
    71                          ;
    72   000092 c5              PRINTB:	PUSH	BC
    73   000093 cd8c00          	CALL	PRINT
    74   000096 c1              	POP	BC
    75   000097 c9              	RET
    76                          ;
    77                          ;   Routine to send a carriage return, line feed combination
    78                          ; to the console.
    79                          ;
    80   000098 3e0d            CRLF:	LD	A,CR
    81   00009a cd9200          	CALL	PRINTB
    82   00009d 3e0a            	LD	A,LF
    83   00009f c39200          	JP	PRINTB
    84                          ;
    85                          ;   Routine to send one space to the console and save (BC).
    86                          ;
    87   0000a2 3e20            SPACE:	LD	A,' '
    88   0000a4 c39200          	JP	PRINTB
    89                          ;
    90                          ;   Routine to print character string pointed to be (BC) on the
    91                          ; console. It must terminate with a null byte.
    92                          ;
    93   0000a7 c5              PLINE:	PUSH	BC
    94   0000a8 cd9800          	CALL	CRLF
    95   0000ab e1              	POP	HL
    96   0000ac 7e              PLINE2:	LD	A,(HL)
    97   0000ad b7              	OR	A
    98   0000ae c8              	RET	Z
    99   0000af 23              	INC	HL
   100   0000b0 e5              	PUSH	HL
   101   0000b1 cd8c00          	CALL	PRINT
   102   0000b4 e1              	POP	HL
   103   0000b5 c3ac00          	JP	PLINE2
   104                          ;
   105                          ;   Routine to reset the disk system.
   106                          ;
   107   0000b8 0e0d            RESDSK:	LD	C,13
   108   0000ba c30500          	JP	ENTRY
   109                          ;
   110                          ;   Routine to select disk (A).
   111                          ;
   112   0000bd 5f              DSKSEL:	LD	E,A
   113   0000be 0e0e            	LD	C,14
   114   0000c0 c30500          	JP	ENTRY
   115                          ;
   116                          ;   Routine to call bdos and save the return code. The zero
   117                          ; flag is set on a return of 0ffh.
   118                          ;
   119   0000c3 cd0500          ENTRY1:	CALL	ENTRY
   120   0000c6 32ee07          	LD	(RTNCODE),A	;save return code.
   121   0000c9 3c              	INC	A		;set zero if 0ffh returned.
   122   0000ca c9              	RET
   123                          ;
   124                          ;   Routine to open a file. (DE) must point to the FCB.
   125                          ;
   126   0000cb 0e0f            OPEN:	LD	C,15
   127   0000cd c3c300          	JP	ENTRY1
   128                          ;
   129                          ;   Routine to open file at (FCB).
   130                          ;
   131   0000d0 af              OPENFCB:XOR	A		;clear the record number byte at fcb+32
   132   0000d1 32ed07          	LD	(FCB+32),A
   133   0000d4 11cd07          	LD	DE,FCB
   134   0000d7 c3cb00          	JP	OPEN
   135                          ;
   136                          ;   Routine to close a file. (DE) points to FCB.
   137                          ;
   138   0000da 0e10            CLOSE:	LD	C,16
   139   0000dc c3c300          	JP	ENTRY1
   140                          ;
   141                          ;   Routine to search for the first file with ambigueous name
   142                          ; (DE).
   143                          ;
   144   0000df 0e11            SRCHFST:LD	C,17
   145   0000e1 c3c300          	JP	ENTRY1
   146                          ;
   147                          ;   Search for the next ambigeous file name.
   148                          ;
   149   0000e4 0e12            SRCHNXT:LD	C,18
   150   0000e6 c3c300          	JP	ENTRY1
   151                          ;
   152                          ;   Search for file at (FCB).
   153                          ;
   154   0000e9 11cd07          SRCHFCB:LD	DE,FCB
   155   0000ec c3df00          	JP	SRCHFST
   156                          ;
   157                          ;   Routine to delete a file pointed to by (DE).
   158                          ;
   159   0000ef 0e13            DELETE:	LD	C,19
   160   0000f1 c30500          	JP	ENTRY
   161                          ;
   162                          ;   Routine to call the bdos and set the zero flag if a zero
   163                          ; status is returned.
   164                          ;
   165   0000f4 cd0500          ENTRY2:	CALL	ENTRY
   166   0000f7 b7              	OR	A		;set zero flag if appropriate.
   167   0000f8 c9              	RET
   168                          ;
   169                          ;   Routine to read the next record from a sequential file.
   170                          ; (DE) points to the FCB.
   171                          ;
   172   0000f9 0e14            RDREC:	LD	C,20
   173   0000fb c3f400          	JP	ENTRY2
   174                          ;
   175                          ;   Routine to read file at (FCB).
   176                          ;
   177   0000fe 11cd07          READFCB:LD	DE,FCB
   178   000101 c3f900          	JP	RDREC
   179                          ;
   180                          ;   Routine to write the next record of a sequential file.
   181                          ; (DE) points to the FCB.
   182                          ;
   183   000104 0e15            WRTREC:	LD	C,21
   184   000106 c3f400          	JP	ENTRY2
   185                          ;
   186                          ;   Routine to create the file pointed to by (DE).
   187                          ;
   188   000109 0e16            CREATE:	LD	C,22
   189   00010b c3c300          	JP	ENTRY1
   190                          ;
   191                          ;   Routine to rename the file pointed to by (DE). Note that
   192                          ; the new name starts at (DE+16).
   193                          ;
   194   00010e 0e17            RENAM:	LD	C,23
   195   000110 c30500          	JP	ENTRY
   196                          ;
   197                          ;   Get the current user code.
   198                          ;
   199   000113 1eff            GETUSR:	LD	E,0FFH
   200                          ;
   201                          ;   Routne to get or set the current user code.
   202                          ; If (E) is FF then this is a GET, else it is a SET.
   203                          ;
   204   000115 0e20            GETSETUC: LD	C,32
   205   000117 c30500          	JP	ENTRY
   206                          ;
   207                          ;   Routine to set the current drive byte at (TDRIVE).
   208                          ;
   209   00011a cd1301          SETCDRV:CALL	GETUSR		;get user number
   210   00011d 87              	ADD	A,A		;and shift into the upper 4 bits.
   211   00011e 87              	ADD	A,A
   212   00011f 87              	ADD	A,A
   213   000120 87              	ADD	A,A
   214   000121 21ef07          	LD	HL,CDRIVE	;now add in the current drive number.
   215   000124 b6              	OR	(HL)
   216   000125 320400          	LD	(TDRIVE),A	;and save.
   217   000128 c9              	RET
   218                          ;
   219                          ;   Move currently active drive down to (TDRIVE).
   220                          ;
   221   000129 3aef07          MOVECD:	LD	A,(CDRIVE)
   222   00012c 320400          	LD	(TDRIVE),A
   223   00012f c9              	RET
   224                          ;
   225                          ;   Routine to convert (A) into upper case ascii. Only letters
   226                          ; are affected.
   227                          ;
   228   000130 fe61            UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
   229   000132 d8              	RET	C
   230   000133 fe7b            	CP	'{'
   231   000135 d0              	RET	NC
   232   000136 e65f            	AND	5FH		;convert it if found.
   233   000138 c9              	RET
   234                          ;
   235                          ;   Routine to get a line of input. We must check to see if the
   236                          ; user is in (BATCH) mode. If so, then read the input from file
   237                          ; ($$$.SUB). At the end, reset to console input.
   238                          ;
   239   000139 3aab07          GETINP:	LD	A,(BATCH)	;if =0, then use console input.
   240   00013c b7              	OR	A
   241   00013d ca9601          	JP	Z,GETINP1
   242                          ;
   243                          ;   Use the submit file ($$$.sub) which is prepared by a
   244                          ; SUBMIT run. It must be on drive (A) and it will be deleted
   245                          ; if and error occures (like eof).
   246                          ;
   247   000140 3aef07          	LD	A,(CDRIVE)	;select drive 0 if need be.
   248   000143 b7              	OR	A
   249   000144 3e00            	LD	A,0		;always use drive A for submit.
   250   000146 c4bd00          	CALL	NZ,DSKSEL	;select it if required.
   251   000149 11ac07          	LD	DE,BATCHFCB
   252   00014c cdcb00          	CALL	OPEN		;look for it.
   253   00014f ca9601          	JP	Z,GETINP1	;if not there, use normal input.
   254   000152 3abb07          	LD	A,(BATCHFCB+15)	;get last record number+1.
   255   000155 3d              	DEC	A
   256   000156 32cc07          	LD	(BATCHFCB+32),A
   257   000159 11ac07          	LD	DE,BATCHFCB
   258   00015c cdf900          	CALL	RDREC		;read last record.
   259   00015f c29601          	JP	NZ,GETINP1	;quit on end of file.
   260                          ;
   261                          ;   Move this record into input buffer.
   262                          ;
   263   000162 110700          	LD	DE,INBUFF+1
   264   000165 218000          	LD	HL,TBUFF	;data was read into buffer here.
   265   000168 0680            	LD	B,128		;all 128 characters may be used.
   266   00016a cd4204          	CALL	HL2DE		;(HL) to (DE), (B) bytes.
   267   00016d 21ba07          	LD	HL,BATCHFCB+14
   268   000170 3600            	LD	(HL),0		;zero out the 's2' byte.
   269   000172 23              	INC	HL		;and decrement the record count.
   270   000173 35              	DEC	(HL)
   271   000174 11ac07          	LD	DE,BATCHFCB	;close the batch file now.
   272   000177 cdda00          	CALL	CLOSE
   273   00017a ca9601          	JP	Z,GETINP1	;quit on an error.
   274   00017d 3aef07          	LD	A,(CDRIVE)	;re-select previous drive if need be.
   275   000180 b7              	OR	A
   276   000181 c4bd00          	CALL	NZ,DSKSEL	;don't do needless selects.
   277                          ;
   278                          ;   Print line just read on console.
   279                          ;
   280   000184 210800          	LD	HL,INBUFF+2
   281   000187 cdac00          	CALL	PLINE2
   282   00018a cdc201          	CALL	CHKCON		;check console, quit on a key.
   283   00018d caa701          	JP	Z,GETINP2	;jump if no key is pressed.
   284                          ;
   285                          ;   Terminate the submit job on any keyboard input. Delete this
   286                          ; file such that it is not re-started and jump to normal keyboard
   287                          ; input section.
   288                          ;
   289   000190 cddd01          	CALL	DELBATCH	;delete the batch file.
   290   000193 c38203          	JP	CMMND1		;and restart command input.
   291                          ;
   292                          ;   Get here for normal keyboard input. Delete the submit file
   293                          ; incase there was one.
   294                          ;
   295   000196 cddd01          GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
   296   000199 cd1a01          	CALL	SETCDRV		;reset active disk.
   297   00019c 0e0a            	LD	C,10		;get line from console device.
   298   00019e 110600          	LD	DE,INBUFF
   299   0001a1 cd0500          	CALL	ENTRY
   300   0001a4 cd2901          	CALL	MOVECD		;reset current drive (again).
   301                          ;
   302                          ;   Convert input line to upper case.
   303                          ;
   304   0001a7 210700          GETINP2:LD	HL,INBUFF+1
   305   0001aa 46              	LD	B,(HL)		;(B)=character counter.
   306   0001ab 23              GETINP3:INC	HL
   307   0001ac 78              	LD	A,B		;end of the line?
   308   0001ad b7              	OR	A
   309   0001ae caba01          	JP	Z,GETINP4
   310   0001b1 7e              	LD	A,(HL)		;convert to upper case.
   311   0001b2 cd3001          	CALL	UPPER
   312   0001b5 77              	LD	(HL),A
   313   0001b6 05              	DEC	B		;adjust character count.
   314   0001b7 c3ab01          	JP	GETINP3
   315   0001ba 77              GETINP4:LD	(HL),A		;add trailing null.
   316   0001bb 210800          	LD	HL,INBUFF+2
   317   0001be 228800          	LD	(INPOINT),HL	;reset input line pointer.
   318   0001c1 c9              	RET
   319                          ;
   320                          ;   Routine to check the console for a key pressed. The zero
   321                          ; flag is set is none, else the character is returned in (A).
   322                          ;
   323   0001c2 0e0b            CHKCON:	LD	C,11		;check console.
   324   0001c4 cd0500          	CALL	ENTRY
   325   0001c7 b7              	OR	A
   326   0001c8 c8              	RET	Z		;return if nothing.
   327   0001c9 0e01            	LD	C,1		;else get character.
   328   0001cb cd0500          	CALL	ENTRY
   329   0001ce b7              	OR	A		;clear zero flag and return.
   330   0001cf c9              	RET
   331                          ;
   332                          ;   Routine to get the currently active drive number.
   333                          ;
   334   0001d0 0e19            GETDSK:	LD	C,25
   335   0001d2 c30500          	JP	ENTRY
   336                          ;
   337                          ;   Set the stabdard dma address.
   338                          ;
   339   0001d5 118000          STDDMA:	LD	DE,TBUFF
   340                          ;
   341                          ;   Routine to set the dma address to (DE).
   342                          ;
   343   0001d8 0e1a            DMASET:	LD	C,26
   344   0001da c30500          	JP	ENTRY
   345                          ;
   346                          ;  Delete the batch file created by SUBMIT.
   347                          ;
   348   0001dd 21ab07          DELBATCH: LD	HL,BATCH	;is batch active?
   349   0001e0 7e              	LD	A,(HL)
   350   0001e1 b7              	OR	A
   351   0001e2 c8              	RET	Z
   352   0001e3 3600            	LD	(HL),0		;yes, de-activate it.
   353   0001e5 af              	XOR	A
   354   0001e6 cdbd00          	CALL	DSKSEL		;select drive 0 for sure.
   355   0001e9 11ac07          	LD	DE,BATCHFCB	;and delete this file.
   356   0001ec cdef00          	CALL	DELETE
   357   0001ef 3aef07          	LD	A,(CDRIVE)	;reset current drive.
   358   0001f2 c3bd00          	JP	DSKSEL
   359                          ;
   360                          ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
   361                          ; the same or we halt....
   362                          ;
   363   0001f5 112803          VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
   364   0001f8 210008          	LD	HL,PATTRN2	;ditto, but how could they be different?
   365   0001fb 0606            	LD	B,6		;6 bytes each.
   366   0001fd 1a              VERIFY1:LD	A,(DE)
   367   0001fe be              	CP	(HL)
   368   0001ff c2cf03          	JP	NZ,HALT		;jump to halt routine.
   369   000202 13              	INC	DE
   370   000203 23              	INC	HL
   371   000204 05              	DEC	B
   372   000205 c2fd01          	JP	NZ,VERIFY1
   373   000208 c9              	RET
   374                          ;
   375                          ;   Print back file name with a '?' to indicate a syntax error.
   376                          ;
   377   000209 cd9800          SYNERR:	CALL	CRLF		;end current line.
   378   00020c 2a8a00          	LD	HL,(NAMEPNT)	;this points to name in error.
   379   00020f 7e              SYNERR1:LD	A,(HL)		;print it until a space or null is found.
   380   000210 fe20            	CP	' '
   381   000212 ca2202          	JP	Z,SYNERR2
   382   000215 b7              	OR	A
   383   000216 ca2202          	JP	Z,SYNERR2
   384   000219 e5              	PUSH	HL
   385   00021a cd8c00          	CALL	PRINT
   386   00021d e1              	POP	HL
   387   00021e 23              	INC	HL
   388   00021f c30f02          	JP	SYNERR1
   389   000222 3e3f            SYNERR2:LD	A,'?'		;add trailing '?'.
   390   000224 cd8c00          	CALL	PRINT
   391   000227 cd9800          	CALL	CRLF
   392   00022a cddd01          	CALL	DELBATCH	;delete any batch file.
   393   00022d c38203          	JP	CMMND1		;and restart from console input.
   394                          ;
   395                          ;   Check character at (DE) for legal command input. Note that the
   396                          ; zero flag is set if the character is a delimiter.
   397                          ;
   398   000230 1a              CHECK:	LD	A,(DE)
   399   000231 b7              	OR	A
   400   000232 c8              	RET	Z
   401   000233 fe20            	CP	' '		;control characters are not legal here.
   402   000235 da0902          	JP	C,SYNERR
   403   000238 c8              	RET	Z		;check for valid delimiter.
   404   000239 fe3d            	CP	'='
   405   00023b c8              	RET	Z
   406   00023c fe5f            	CP	'_'
   407   00023e c8              	RET	Z
   408   00023f fe2e            	CP	'.'
   409   000241 c8              	RET	Z
   410   000242 fe3a            	CP	':'
   411   000244 c8              	RET	Z
   412   000245 fe3b            	CP	';'
   413   000247 c8              	RET	Z
   414   000248 fe3c            	CP	'<'
   415   00024a c8              	RET	Z
   416   00024b fe3e            	CP	'>'
   417   00024d c8              	RET	Z
   418   00024e c9              	RET
   419                          ;
   420                          ;   Get the next non-blank character from (DE).
   421                          ;
   422   00024f 1a              NONBLANK: LD	A,(DE)
   423   000250 b7              	OR	A		;string ends with a null.
   424   000251 c8              	RET	Z
   425   000252 fe20            	CP	' '
   426   000254 c0              	RET	NZ
   427   000255 13              	INC	DE
   428   000256 c34f02          	JP	NONBLANK
   429                          ;
   430                          ;   Add (HL)=(HL)+(A)
   431                          ;
   432   000259 85              ADDHL:	ADD	A,L
   433   00025a 6f              	LD	L,A
   434   00025b d0              	RET	NC		;take care of any carry.
   435   00025c 24              	INC	H
   436   00025d c9              	RET
   437                          ;
   438                          ;   Convert the first name in (FCB).
   439                          ;
   440   00025e 3e00            CONVFST:LD	A,0
   441                          ;
   442                          ;   Format a file name (convert * to '?', etc.). On return,
   443                          ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
   444                          ; the position within the fcb for the name (either 0 or 16).
   445                          ;
   446   000260 21cd07          CONVERT:LD	HL,FCB
   447   000263 cd5902          	CALL	ADDHL
   448   000266 e5              	PUSH	HL
   449   000267 e5              	PUSH	HL
   450   000268 af              	XOR	A
   451   000269 32f007          	LD	(CHGDRV),A	;initialize drive change flag.
   452   00026c 2a8800          	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
   453   00026f eb              	EX	DE,HL
   454   000270 cd4f02          	CALL	NONBLANK	;get next non-blank character.
   455   000273 eb              	EX	DE,HL
   456   000274 228a00          	LD	(NAMEPNT),HL	;save pointer here for any error message.
   457   000277 eb              	EX	DE,HL
   458   000278 e1              	POP	HL
   459   000279 1a              	LD	A,(DE)		;get first character.
   460   00027a b7              	OR	A
   461   00027b ca8902          	JP	Z,CONVRT1
   462   00027e de40            	SBC	A,'A'-1		;might be a drive name, convert to binary.
   463   000280 47              	LD	B,A		;and save.
   464   000281 13              	INC	DE		;check next character for a ':'.
   465   000282 1a              	LD	A,(DE)
   466   000283 fe3a            	CP	':'
   467   000285 ca9002          	JP	Z,CONVRT2
   468   000288 1b              	DEC	DE		;nope, move pointer back to the start of the line.
   469   000289 3aef07          CONVRT1:LD	A,(CDRIVE)
   470   00028c 77              	LD	(HL),A
   471   00028d c39602          	JP	CONVRT3
   472   000290 78              CONVRT2:LD	A,B
   473   000291 32f007          	LD	(CHGDRV),A	;set change in drives flag.
   474   000294 70              	LD	(HL),B
   475   000295 13              	INC	DE
   476                          ;
   477                          ;   Convert the basic file name.
   478                          ;
   479   000296 0608            CONVRT3:LD	B,08H
   480   000298 cd3002          CONVRT4:CALL	CHECK
   481   00029b cab902          	JP	Z,CONVRT8
   482   00029e 23              	INC	HL
   483   00029f fe2a            	CP	'*'		;note that an '*' will fill the remaining
   484   0002a1 c2a902          	JP	NZ,CONVRT5	;field with '?'.
   485   0002a4 363f            	LD	(HL),'?'
   486   0002a6 c3ab02          	JP	CONVRT6
   487   0002a9 77              CONVRT5:LD	(HL),A
   488   0002aa 13              	INC	DE
   489   0002ab 05              CONVRT6:DEC	B
   490   0002ac c29802          	JP	NZ,CONVRT4
   491   0002af cd3002          CONVRT7:CALL	CHECK		;get next delimiter.
   492   0002b2 cac002          	JP	Z,GETEXT
   493   0002b5 13              	INC	DE
   494   0002b6 c3af02          	JP	CONVRT7
   495   0002b9 23              CONVRT8:INC	HL		;blank fill the file name.
   496   0002ba 3620            	LD	(HL),' '
   497   0002bc 05              	DEC	B
   498   0002bd c2b902          	JP	NZ,CONVRT8
   499                          ;
   500                          ;   Get the extension and convert it.
   501                          ;
   502   0002c0 0603            GETEXT:	LD	B,03H
   503   0002c2 fe2e            	CP	'.'
   504   0002c4 c2e902          	JP	NZ,GETEXT5
   505   0002c7 13              	INC	DE
   506   0002c8 cd3002          GETEXT1:CALL	CHECK
   507   0002cb cae902          	JP	Z,GETEXT5
   508   0002ce 23              	INC	HL
   509   0002cf fe2a            	CP	'*'
   510   0002d1 c2d902          	JP	NZ,GETEXT2
   511   0002d4 363f            	LD	(HL),'?'
   512   0002d6 c3db02          	JP	GETEXT3
   513   0002d9 77              GETEXT2:LD	(HL),A
   514   0002da 13              	INC	DE
   515   0002db 05              GETEXT3:DEC	B
   516   0002dc c2c802          	JP	NZ,GETEXT1
   517   0002df cd3002          GETEXT4:CALL	CHECK
   518   0002e2 caf002          	JP	Z,GETEXT6
   519   0002e5 13              	INC	DE
   520   0002e6 c3df02          	JP	GETEXT4
   521   0002e9 23              GETEXT5:INC	HL
   522   0002ea 3620            	LD	(HL),' '
   523   0002ec 05              	DEC	B
   524   0002ed c2e902          	JP	NZ,GETEXT5
   525   0002f0 0603            GETEXT6:LD	B,3
   526   0002f2 23              GETEXT7:INC	HL
   527   0002f3 3600            	LD	(HL),0
   528   0002f5 05              	DEC	B
   529   0002f6 c2f202          	JP	NZ,GETEXT7
   530   0002f9 eb              	EX	DE,HL
   531   0002fa 228800          	LD	(INPOINT),HL	;save input line pointer.
   532   0002fd e1              	POP	HL
   533                          ;
   534                          ;   Check to see if this is an ambigeous file name specification.
   535                          ; Set the (A) register to non zero if it is.
   536                          ;
   537   0002fe 010b00          	LD	BC,11		;set name length.
   538   000301 23              GETEXT8:INC	HL
   539   000302 7e              	LD	A,(HL)
   540   000303 fe3f            	CP	'?'		;any question marks?
   541   000305 c20903          	JP	NZ,GETEXT9
   542   000308 04              	INC	B		;count them.
   543   000309 0d              GETEXT9:DEC	C
   544   00030a c20103          	JP	NZ,GETEXT8
   545   00030d 78              	LD	A,B
   546   00030e b7              	OR	A
   547   00030f c9              	RET
   548                          ;
   549                          ;   CP/M command table. Note commands can be either 3 or 4 characters long.
   550                          ;
   551                          NUMCMDS EQU	6		;number of commands
   552   000310 44495220        CMDTBL:	DB	"DIR "
   553   000314 45524120        	DB	"ERA "
   554   000318 54595045        	DB	"TYPE"
   555   00031c 53415645        	DB	"SAVE"
   556   000320 52454e20        	DB	"REN "
   557   000324 55534552        	DB	"USER"
   558                          ;
   559                          ;   The following six bytes must agree with those at (PATTRN2)
   560                          ; or cp/m will HALT. Why?
   561                          ;
   562   000328 001600000000    PATTRN1:DB	0,22,0,0,0,0	;(* serial number bytes *).
   563                          ;
   564                          ;   Search the command table for a match with what has just
   565                          ; been entered. If a match is found, then we jump to the
   566                          ; proper section. Else jump to (UNKNOWN).
   567                          ; On return, the (C) register is set to the command number
   568                          ; that matched (or NUMCMDS+1 if no match).
   569                          ;
   570   00032e 211003          SEARCH:	LD	HL,CMDTBL
   571   000331 0e00            	LD	C,0
   572   000333 79              SEARCH1:LD	A,C
   573   000334 fe06            	CP	NUMCMDS		;this commands exists.
   574   000336 d0              	RET	NC
   575   000337 11ce07          	LD	DE,FCB+1	;check this one.
   576   00033a 0604            	LD	B,4		;max command length.
   577   00033c 1a              SEARCH2:LD	A,(DE)
   578   00033d be              	CP	(HL)
   579   00033e c24f03          	JP	NZ,SEARCH3	;not a match.
   580   000341 13              	INC	DE
   581   000342 23              	INC	HL
   582   000343 05              	DEC	B
   583   000344 c23c03          	JP	NZ,SEARCH2
   584   000347 1a              	LD	A,(DE)		;allow a 3 character command to match.
   585   000348 fe20            	CP	' '
   586   00034a c25403          	JP	NZ,SEARCH4
   587   00034d 79              	LD	A,C		;set return register for this command.
   588   00034e c9              	RET
   589   00034f 23              SEARCH3:INC	HL
   590   000350 05              	DEC	B
   591   000351 c24f03          	JP	NZ,SEARCH3
   592   000354 0c              SEARCH4:INC	C
   593   000355 c33303          	JP	SEARCH1
   594                          ;
   595                          ;   Set the input buffer to empty and then start the command
   596                          ; processor (ccp).
   597                          ;
   598   000358 af              CLEARBUF: XOR	A
   599   000359 320700          	LD	(INBUFF+1),A	;second byte is actual length.
   600                          ;
   601                          ;**************************************************************
   602                          ;*
   603                          ;*
   604                          ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
   605                          ;*
   606                          ;**************************************************************
   607                          ;*
   608                          COMMAND:
   609   00035c 31ab07          	LD	SP,CCPSTACK	;setup stack area.
   610   00035f c5              	PUSH	BC		;note that (C) should be equal to:
   611   000360 79              	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
   612   000361 1f              	RRA			;and 'dddd' is the drive number.
   613   000362 1f              	RRA
   614   000363 1f              	RRA
   615   000364 1f              	RRA
   616   000365 e60f            	AND	0FH		;isolate the user number.
   617   000367 5f              	LD	E,A
   618   000368 cd1501          	CALL	GETSETUC	;and set it.
   619   00036b cdb800          	CALL	RESDSK		;reset the disk system.
   620   00036e 32ab07          	LD	(BATCH),A	;clear batch mode flag.
   621   000371 c1              	POP	BC
   622   000372 79              	LD	A,C
   623   000373 e60f            	AND	0FH		;isolate the drive number.
   624   000375 32ef07          	LD	(CDRIVE),A	;and save.
   625   000378 cdbd00          	CALL	DSKSEL		;...and select.
   626   00037b 3a0700          	LD	A,(INBUFF+1)
   627   00037e b7              	OR	A		;anything in input buffer already?
   628   00037f c29803          	JP	NZ,CMMND2	;yes, we just process it.
   629                          ;
   630                          ;   Entry point to get a command line from the console.
   631                          ;
   632   000382 31ab07          CMMND1:	LD	SP,CCPSTACK	;set stack straight.
   633   000385 cd9800          	CALL	CRLF		;start a new line on the screen.
   634   000388 cdd001          	CALL	GETDSK		;get current drive.
   635   00038b c661            	ADD	A,'a'
   636   00038d cd8c00          	CALL	PRINT		;print current drive.
   637   000390 3e3e            	LD	A,'>'
   638   000392 cd8c00          	CALL	PRINT		;and add prompt.
   639   000395 cd3901          	CALL	GETINP		;get line from user.
   640                          ;
   641                          ;   Process command line here.
   642                          ;
   643   000398 118000          CMMND2:	LD	DE,TBUFF
   644   00039b cdd801          	CALL	DMASET		;set standard dma address.
   645   00039e cdd001          	CALL	GETDSK
   646   0003a1 32ef07          	LD	(CDRIVE),A	;set current drive.
   647   0003a4 cd5e02          	CALL	CONVFST		;convert name typed in.
   648   0003a7 c40902          	CALL	NZ,SYNERR	;wild cards are not allowed.
   649   0003aa 3af007          	LD	A,(CHGDRV)	;if a change in drives was indicated,
   650   0003ad b7              	OR	A		;then treat this as an unknown command
   651   0003ae c2a506          	JP	NZ,UNKNOWN	;which gets executed.
   652   0003b1 cd2e03          	CALL	SEARCH		;else search command table for a match.
   653                          ;
   654                          ;   Note that an unknown command returns
   655                          ; with (A) pointing to the last address
   656                          ; in our table which is (UNKNOWN).
   657                          ;
   658   0003b4 21c103          	LD	HL,CMDADR	;now, look thru our address table for command (A).
   659   0003b7 5f              	LD	E,A		;set (DE) to command number.
   660   0003b8 1600            	LD	D,0
   661   0003ba 19              	ADD	HL,DE
   662   0003bb 19              	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
   663   0003bc 7e              	LD	A,(HL)		;now pick out this address.
   664   0003bd 23              	INC	HL
   665   0003be 66              	LD	H,(HL)
   666   0003bf 6f              	LD	L,A
   667   0003c0 e9              	JP	(HL)		;now execute it.
   668                          ;
   669                          ;   CP/M command address table.
   670                          ;
   671   0003c1 77041f055d05ad05CMDADR:	DW	DIRECT,ERASE,TYPE,SAVE
   672   0003c9 10068e06a506    	DW	RENAME,USER,UNKNOWN
   673                          ;
   674                          ;   Halt the system. Reason for this is unknown at present.
   675                          ;
   676   0003cf 21f376          HALT:	LD	HL,76F3H	;'DI HLT' instructions.
   677   0003d2 220000          	LD	(CBASE),HL
   678   0003d5 210000          	LD	HL,CBASE
   679   0003d8 e9              	JP	(HL)
   680                          ;
   681                          ;   Read error while TYPEing a file.
   682                          ;
   683   0003d9 01df03          RDERROR:LD	BC,RDERR
   684   0003dc c3a700          	JP	PLINE
   685   0003df 5265616420657272RDERR:	DB	"Read error",0
                6f7200          
   686                          ;
   687                          ;   Required file was not located.
   688                          ;
   689   0003ea 01f003          NONE:	LD	BC,NOFILE
   690   0003ed c3a700          	JP	PLINE
   691   0003f0 4e6f2066696c6500NOFILE:	DB	"No file",0
   692                          ;
   693                          ;   Decode a command of the form 'A>filename number{ filename}.
   694                          ; Note that a drive specifier is not allowed on the first file
   695                          ; name. On return, the number is in register (A). Any error
   696                          ; causes 'filename?' to be printed and the command is aborted.
   697                          ;
   698   0003f8 cd5e02          DECODE:	CALL	CONVFST		;convert filename.
   699   0003fb 3af007          	LD	A,(CHGDRV)	;do not allow a drive to be specified.
   700   0003fe b7              	OR	A
   701   0003ff c20902          	JP	NZ,SYNERR
   702   000402 21ce07          	LD	HL,FCB+1	;convert number now.
   703   000405 010b00          	LD	BC,11		;(B)=sum register, (C)=max digit count.
   704   000408 7e              DECODE1:LD	A,(HL)
   705   000409 fe20            	CP	' '		;a space terminates the numeral.
   706   00040b ca3304          	JP	Z,DECODE3
   707   00040e 23              	INC	HL
   708   00040f d630            	SUB	'0'		;make binary from ascii.
   709   000411 fe0a            	CP	10		;legal digit?
   710   000413 d20902          	JP	NC,SYNERR
   711   000416 57              	LD	D,A		;yes, save it in (D).
   712   000417 78              	LD	A,B		;compute (B)=(B)*10 and check for overflow.
   713   000418 e6e0            	AND	0E0H
   714   00041a c20902          	JP	NZ,SYNERR
   715   00041d 78              	LD	A,B
   716   00041e 07              	RLCA
   717   00041f 07              	RLCA
   718   000420 07              	RLCA			;(A)=(B)*8
   719   000421 80              	ADD	A,B		;.......*9
   720   000422 da0902          	JP	C,SYNERR
   721   000425 80              	ADD	A,B		;.......*10
   722   000426 da0902          	JP	C,SYNERR
   723   000429 82              	ADD	A,D		;add in new digit now.
   724   00042a da0902          DECODE2:JP	C,SYNERR
   725   00042d 47              	LD	B,A		;and save result.
   726   00042e 0d              	DEC	C		;only look at 11 digits.
   727   00042f c20804          	JP	NZ,DECODE1
   728   000432 c9              	RET
   729   000433 7e              DECODE3:LD	A,(HL)		;spaces must follow (why?).
   730   000434 fe20            	CP	' '
   731   000436 c20902          	JP	NZ,SYNERR
   732   000439 23              	INC	HL
   733   00043a 0d              DECODE4:DEC	C
   734   00043b c23304          	JP	NZ,DECODE3
   735   00043e 78              	LD	A,B		;set (A)=the numeric value entered.
   736   00043f c9              	RET
   737                          ;
   738                          ;   Move 3 bytes from (HL) to (DE). Note that there is only
   739                          ; one reference to this at (A2D5h).
   740                          ;
   741   000440 0603            MOVE3:	LD	B,3
   742                          ;
   743                          ;   Move (B) bytes from (HL) to (DE).
   744                          ;
   745   000442 7e              HL2DE:	LD	A,(HL)
   746   000443 12              	LD	(DE),A
   747   000444 23              	INC	HL
   748   000445 13              	INC	DE
   749   000446 05              	DEC	B
   750   000447 c24204          	JP	NZ,HL2DE
   751   00044a c9              	RET
   752                          ;
   753                          ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
   754                          ;
   755   00044b 218000          EXTRACT:LD	HL,TBUFF
   756   00044e 81              	ADD	A,C
   757   00044f cd5902          	CALL	ADDHL
   758   000452 7e              	LD	A,(HL)
   759   000453 c9              	RET
   760                          ;
   761                          ;  Check drive specified. If it means a change, then the new
   762                          ; drive will be selected. In any case, the drive byte of the
   763                          ; fcb will be set to null (means use current drive).
   764                          ;
   765   000454 af              DSELECT:XOR	A		;null out first byte of fcb.
   766   000455 32cd07          	LD	(FCB),A
   767   000458 3af007          	LD	A,(CHGDRV)	;a drive change indicated?
   768   00045b b7              	OR	A
   769   00045c c8              	RET	Z
   770   00045d 3d              	DEC	A		;yes, is it the same as the current drive?
   771   00045e 21ef07          	LD	HL,CDRIVE
   772   000461 be              	CP	(HL)
   773   000462 c8              	RET	Z
   774   000463 c3bd00          	JP	DSKSEL		;no. Select it then.
   775                          ;
   776                          ;   Check the drive selection and reset it to the previous
   777                          ; drive if it was changed for the preceeding command.
   778                          ;
   779   000466 3af007          RESETDR:LD	A,(CHGDRV)	;drive change indicated?
   780   000469 b7              	OR	A
   781   00046a c8              	RET	Z
   782   00046b 3d              	DEC	A		;yes, was it a different drive?
   783   00046c 21ef07          	LD	HL,CDRIVE
   784   00046f be              	CP	(HL)
   785   000470 c8              	RET	Z
   786   000471 3aef07          	LD	A,(CDRIVE)	;yes, re-select our old drive.
   787   000474 c3bd00          	JP	DSKSEL
   788                          ;
   789                          ;**************************************************************
   790                          ;*
   791                          ;*           D I R E C T O R Y   C O M M A N D
   792                          ;*
   793                          ;**************************************************************
   794                          ;
   795   000477 cd5e02          DIRECT:	CALL	CONVFST		;convert file name.
   796   00047a cd5404          	CALL	DSELECT		;select indicated drive.
   797   00047d 21ce07          	LD	HL,FCB+1	;was any file indicated?
   798   000480 7e              	LD	A,(HL)
   799   000481 fe20            	CP	' '
   800   000483 c28f04          	JP	NZ,DIRECT2
   801   000486 060b            	LD	B,11		;no. Fill field with '?' - same as *.*.
   802   000488 363f            DIRECT1:LD	(HL),'?'
   803   00048a 23              	INC	HL
   804   00048b 05              	DEC	B
   805   00048c c28804          	JP	NZ,DIRECT1
   806   00048f 1e00            DIRECT2:LD	E,0		;set initial cursor position.
   807   000491 d5              	PUSH	DE
   808   000492 cde900          	CALL	SRCHFCB		;get first file name.
   809   000495 ccea03          	CALL	Z,NONE		;none found at all?
   810   000498 ca1b05          DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
   811   00049b 3aee07          	LD	A,(RTNCODE)	;get file's position in segment (0-3).
   812   00049e 0f              	RRCA
   813   00049f 0f              	RRCA
   814   0004a0 0f              	RRCA
   815   0004a1 e660            	AND	60H		;(A)=position*32
   816   0004a3 4f              	LD	C,A
   817   0004a4 3e0a            	LD	A,10
   818   0004a6 cd4b04          	CALL	EXTRACT		;extract the tenth entry in fcb.
   819   0004a9 17              	RLA			;check system file status bit.
   820   0004aa da0f05          	JP	C,DIRECT8	;we don't list them.
   821   0004ad d1              	POP	DE
   822   0004ae 7b              	LD	A,E		;bump name count.
   823   0004af 1c              	INC	E
   824   0004b0 d5              	PUSH	DE
   825   0004b1 e603            	AND	03H		;at end of line?
   826   0004b3 f5              	PUSH	AF
   827   0004b4 c2cc04          	JP	NZ,DIRECT4
   828   0004b7 cd9800          	CALL	CRLF		;yes, end this line and start another.
   829   0004ba c5              	PUSH	BC
   830   0004bb cdd001          	CALL	GETDSK		;start line with ('A:').
   831   0004be c1              	POP	BC
   832   0004bf c641            	ADD	A,'A'
   833   0004c1 cd9200          	CALL	PRINTB
   834   0004c4 3e3a            	LD	A,':'
   835   0004c6 cd9200          	CALL	PRINTB
   836   0004c9 c3d404          	JP	DIRECT5
   837   0004cc cda200          DIRECT4:CALL	SPACE		;add seperator between file names.
   838   0004cf 3e3a            	LD	A,':'
   839   0004d1 cd9200          	CALL	PRINTB
   840   0004d4 cda200          DIRECT5:CALL	SPACE
   841   0004d7 0601            	LD	B,1		;'extract' each file name character at a time.
   842   0004d9 78              DIRECT6:LD	A,B
   843   0004da cd4b04          	CALL	EXTRACT
   844   0004dd e67f            	AND	7FH		;strip bit 7 (status bit).
   845   0004df fe20            	CP	' '		;are we at the end of the name?
   846   0004e1 c2f904          	JP	NZ,DRECT65
   847   0004e4 f1              	POP	AF		;yes, don't print spaces at the end of a line.
   848   0004e5 f5              	PUSH	AF
   849   0004e6 fe03            	CP	3
   850   0004e8 c2f704          	JP	NZ,DRECT63
   851   0004eb 3e09            	LD	A,9		;first check for no extension.
   852   0004ed cd4b04          	CALL	EXTRACT
   853   0004f0 e67f            	AND	7FH
   854   0004f2 fe20            	CP	' '
   855   0004f4 ca0e05          	JP	Z,DIRECT7	;don't print spaces.
   856   0004f7 3e20            DRECT63:LD	A,' '		;else print them.
   857   0004f9 cd9200          DRECT65:CALL	PRINTB
   858   0004fc 04              	INC	B		;bump to next character psoition.
   859   0004fd 78              	LD	A,B
   860   0004fe fe0c            	CP	12		;end of the name?
   861   000500 d20e05          	JP	NC,DIRECT7
   862   000503 fe09            	CP	9		;nope, starting extension?
   863   000505 c2d904          	JP	NZ,DIRECT6
   864   000508 cda200          	CALL	SPACE		;yes, add seperating space.
   865   00050b c3d904          	JP	DIRECT6
   866   00050e f1              DIRECT7:POP	AF		;get the next file name.
   867   00050f cdc201          DIRECT8:CALL	CHKCON		;first check console, quit on anything.
   868   000512 c21b05          	JP	NZ,DIRECT9
   869   000515 cde400          	CALL	SRCHNXT		;get next name.
   870   000518 c39804          	JP	DIRECT3		;and continue with our list.
   871   00051b d1              DIRECT9:POP	DE		;restore the stack and return to command level.
   872   00051c c38607          	JP	GETBACK
   873                          ;
   874                          ;**************************************************************
   875                          ;*
   876                          ;*                E R A S E   C O M M A N D
   877                          ;*
   878                          ;**************************************************************
   879                          ;
   880   00051f cd5e02          ERASE:	CALL	CONVFST		;convert file name.
   881   000522 fe0b            	CP	11		;was '*.*' entered?
   882   000524 c24205          	JP	NZ,ERASE1
   883   000527 015205          	LD	BC,YESNO	;yes, ask for confirmation.
   884   00052a cda700          	CALL	PLINE
   885   00052d cd3901          	CALL	GETINP
   886   000530 210700          	LD	HL,INBUFF+1
   887   000533 35              	DEC	(HL)		;must be exactly 'y'.
   888   000534 c28203          	JP	NZ,CMMND1
   889   000537 23              	INC	HL
   890   000538 7e              	LD	A,(HL)
   891   000539 fe59            	CP	'Y'
   892   00053b c28203          	JP	NZ,CMMND1
   893   00053e 23              	INC	HL
   894   00053f 228800          	LD	(INPOINT),HL	;save input line pointer.
   895   000542 cd5404          ERASE1:	CALL	DSELECT		;select desired disk.
   896   000545 11cd07          	LD	DE,FCB
   897   000548 cdef00          	CALL	DELETE		;delete the file.
   898   00054b 3c              	INC	A
   899   00054c ccea03          	CALL	Z,NONE		;not there?
   900   00054f c38607          	JP	GETBACK		;return to command level now.
   901   000552 416c6c2028792f6eYESNO:	DB	"All (y/n)?",0
                293f00          
   902                          ;
   903                          ;**************************************************************
   904                          ;*
   905                          ;*            T Y P E   C O M M A N D
   906                          ;*
   907                          ;**************************************************************
   908                          ;
   909   00055d cd5e02          TYPE:	CALL	CONVFST		;convert file name.
   910   000560 c20902          	JP	NZ,SYNERR	;wild cards not allowed.
   911   000563 cd5404          	CALL	DSELECT		;select indicated drive.
   912   000566 cdd000          	CALL	OPENFCB		;open the file.
   913   000569 caa705          	JP	Z,TYPE5		;not there?
   914   00056c cd9800          	CALL	CRLF		;ok, start a new line on the screen.
   915   00056f 21f107          	LD	HL,NBYTES	;initialize byte counter.
   916   000572 36ff            	LD	(HL),0FFH	;set to read first sector.
   917   000574 21f107          TYPE1:	LD	HL,NBYTES
   918   000577 7e              TYPE2:	LD	A,(HL)		;have we written the entire sector?
   919   000578 fe80            	CP	128
   920   00057a da8705          	JP	C,TYPE3
   921   00057d e5              	PUSH	HL		;yes, read in the next one.
   922   00057e cdfe00          	CALL	READFCB
   923   000581 e1              	POP	HL
   924   000582 c2a005          	JP	NZ,TYPE4	;end or error?
   925   000585 af              	XOR	A		;ok, clear byte counter.
   926   000586 77              	LD	(HL),A
   927   000587 34              TYPE3:	INC	(HL)		;count this byte.
   928   000588 218000          	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
   929   00058b cd5902          	CALL	ADDHL
   930   00058e 7e              	LD	A,(HL)
   931   00058f fe1a            	CP	CNTRLZ		;end of file mark?
   932   000591 ca8607          	JP	Z,GETBACK
   933   000594 cd8c00          	CALL	PRINT		;no, print it.
   934   000597 cdc201          	CALL	CHKCON		;check console, quit if anything ready.
   935   00059a c28607          	JP	NZ,GETBACK
   936   00059d c37405          	JP	TYPE1
   937                          ;
   938                          ;   Get here on an end of file or read error.
   939                          ;
   940   0005a0 3d              TYPE4:	DEC	A		;read error?
   941   0005a1 ca8607          	JP	Z,GETBACK
   942   0005a4 cdd903          	CALL	RDERROR		;yes, print message.
   943   0005a7 cd6604          TYPE5:	CALL	RESETDR		;and reset proper drive
   944   0005aa c30902          	JP	SYNERR		;now print file name with problem.
   945                          ;
   946                          ;**************************************************************
   947                          ;*
   948                          ;*            S A V E   C O M M A N D
   949                          ;*
   950                          ;**************************************************************
   951                          ;
   952   0005ad cdf803          SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
   953   0005b0 f5              	PUSH	AF		;save number of pages to write.
   954   0005b1 cd5e02          	CALL	CONVFST		;convert file name.
   955   0005b4 c20902          	JP	NZ,SYNERR	;wild cards not allowed.
   956   0005b7 cd5404          	CALL	DSELECT		;select specified drive.
   957   0005ba 11cd07          	LD	DE,FCB		;now delete this file.
   958   0005bd d5              	PUSH	DE
   959   0005be cdef00          	CALL	DELETE
   960   0005c1 d1              	POP	DE
   961   0005c2 cd0901          	CALL	CREATE		;and create it again.
   962   0005c5 cafb05          	JP	Z,SAVE3		;can't create?
   963   0005c8 af              	XOR	A		;clear record number byte.
   964   0005c9 32ed07          	LD	(FCB+32),A
   965   0005cc f1              	POP	AF		;convert pages to sectors.
   966   0005cd 6f              	LD	L,A
   967   0005ce 2600            	LD	H,0
   968   0005d0 29              	ADD	HL,HL		;(HL)=number of sectors to write.
   969   0005d1 110001          	LD	DE,TBASE	;and we start from here.
   970   0005d4 7c              SAVE1:	LD	A,H		;done yet?
   971   0005d5 b5              	OR	L
   972   0005d6 caf105          	JP	Z,SAVE2
   973   0005d9 2b              	DEC	HL		;nope, count this and compute the start
   974   0005da e5              	PUSH	HL		;of the next 128 byte sector.
   975   0005db 218000          	LD	HL,128
   976   0005de 19              	ADD	HL,DE
   977   0005df e5              	PUSH	HL		;save it and set the transfer address.
   978   0005e0 cdd801          	CALL	DMASET
   979   0005e3 11cd07          	LD	DE,FCB		;write out this sector now.
   980   0005e6 cd0401          	CALL	WRTREC
   981   0005e9 d1              	POP	DE		;reset (DE) to the start of the last sector.
   982   0005ea e1              	POP	HL		;restore sector count.
   983   0005eb c2fb05          	JP	NZ,SAVE3	;write error?
   984   0005ee c3d405          	JP	SAVE1
   985                          ;
   986                          ;   Get here after writing all of the file.
   987                          ;
   988   0005f1 11cd07          SAVE2:	LD	DE,FCB		;now close the file.
   989   0005f4 cdda00          	CALL	CLOSE
   990   0005f7 3c              	INC	A		;did it close ok?
   991   0005f8 c20106          	JP	NZ,SAVE4
   992                          ;
   993                          ;   Print out error message (no space).
   994                          ;
   995   0005fb 010706          SAVE3:	LD	BC,NOSPACE
   996   0005fe cda700          	CALL	PLINE
   997   000601 cdd501          SAVE4:	CALL	STDDMA		;reset the standard dma address.
   998   000604 c38607          	JP	GETBACK
   999   000607 4e6f207370616365NOSPACE:DB	"No space",0
                00              
  1000                          ;
  1001                          ;**************************************************************
  1002                          ;*
  1003                          ;*           R E N A M E   C O M M A N D
  1004                          ;*
  1005                          ;**************************************************************
  1006                          ;
  1007   000610 cd5e02          RENAME:	CALL	CONVFST		;convert first file name.
  1008   000613 c20902          	JP	NZ,SYNERR	;wild cards not allowed.
  1009   000616 3af007          	LD	A,(CHGDRV)	;remember any change in drives specified.
  1010   000619 f5              	PUSH	AF
  1011   00061a cd5404          	CALL	DSELECT		;and select this drive.
  1012   00061d cde900          	CALL	SRCHFCB		;is this file present?
  1013   000620 c27906          	JP	NZ,RENAME6	;yes, print error message.
  1014   000623 21cd07          	LD	HL,FCB		;yes, move this name into second slot.
  1015   000626 11dd07          	LD	DE,FCB+16
  1016   000629 0610            	LD	B,16
  1017   00062b cd4204          	CALL	HL2DE
  1018   00062e 2a8800          	LD	HL,(INPOINT)	;get input pointer.
  1019   000631 eb              	EX	DE,HL
  1020   000632 cd4f02          	CALL	NONBLANK	;get next non blank character.
  1021   000635 fe3d            	CP	'='		;only allow an '=' or '_' seperator.
  1022   000637 ca3f06          	JP	Z,RENAME1
  1023   00063a fe5f            	CP	'_'
  1024   00063c c27306          	JP	NZ,RENAME5
  1025   00063f eb              RENAME1:EX	DE,HL
  1026   000640 23              	INC	HL		;ok, skip seperator.
  1027   000641 228800          	LD	(INPOINT),HL	;save input line pointer.
  1028   000644 cd5e02          	CALL	CONVFST		;convert this second file name now.
  1029   000647 c27306          	JP	NZ,RENAME5	;again, no wild cards.
  1030   00064a f1              	POP	AF		;if a drive was specified, then it
  1031   00064b 47              	LD	B,A		;must be the same as before.
  1032   00064c 21f007          	LD	HL,CHGDRV
  1033   00064f 7e              	LD	A,(HL)
  1034   000650 b7              	OR	A
  1035   000651 ca5906          	JP	Z,RENAME2
  1036   000654 b8              	CP	B
  1037   000655 70              	LD	(HL),B
  1038   000656 c27306          	JP	NZ,RENAME5	;they were different, error.
  1039   000659 70              RENAME2:LD	(HL),B		;	reset as per the first file specification.
  1040   00065a af              	XOR	A
  1041   00065b 32cd07          	LD	(FCB),A		;clear the drive byte of the fcb.
  1042   00065e cde900          RENAME3:CALL	SRCHFCB		;and go look for second file.
  1043   000661 ca6d06          	JP	Z,RENAME4	;doesn't exist?
  1044   000664 11cd07          	LD	DE,FCB
  1045   000667 cd0e01          	CALL	RENAM		;ok, rename the file.
  1046   00066a c38607          	JP	GETBACK
  1047                          ;
  1048                          ;   Process rename errors here.
  1049                          ;
  1050   00066d cdea03          RENAME4:CALL	NONE		;file not there.
  1051   000670 c38607          	JP	GETBACK
  1052   000673 cd6604          RENAME5:CALL	RESETDR		;bad command format.
  1053   000676 c30902          	JP	SYNERR
  1054   000679 018206          RENAME6:LD	BC,EXISTS	;destination file already exists.
  1055   00067c cda700          	CALL	PLINE
  1056   00067f c38607          	JP	GETBACK
  1057   000682 46696c6520657869EXISTS:	DB	"File exists",0
                73747300        
  1058                          ;
  1059                          ;**************************************************************
  1060                          ;*
  1061                          ;*             U S E R   C O M M A N D
  1062                          ;*
  1063                          ;**************************************************************
  1064                          ;
  1065   00068e cdf803          USER:	CALL	DECODE		;get numeric value following command.
  1066   000691 fe10            	CP	16		;legal user number?
  1067   000693 d20902          	JP	NC,SYNERR
  1068   000696 5f              	LD	E,A		;yes but is there anything else?
  1069   000697 3ace07          	LD	A,(FCB+1)
  1070   00069a fe20            	CP	' '
  1071   00069c ca0902          	JP	Z,SYNERR	;yes, that is not allowed.
  1072   00069f cd1501          	CALL	GETSETUC	;ok, set user code.
  1073   0006a2 c38907          	JP	GETBACK1
  1074                          ;
  1075                          ;**************************************************************
  1076                          ;*
  1077                          ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
  1078                          ;*
  1079                          ;**************************************************************
  1080                          ;
  1081   0006a5 cdf501          UNKNOWN:CALL	VERIFY		;check for valid system (why?).
  1082   0006a8 3ace07          	LD	A,(FCB+1)	;anything to execute?
  1083   0006ab fe20            	CP	' '
  1084   0006ad c2c406          	JP	NZ,UNKWN1
  1085   0006b0 3af007          	LD	A,(CHGDRV)	;nope, only a drive change?
  1086   0006b3 b7              	OR	A
  1087   0006b4 ca8907          	JP	Z,GETBACK1	;neither???
  1088   0006b7 3d              	DEC	A
  1089   0006b8 32ef07          	LD	(CDRIVE),A	;ok, store new drive.
  1090   0006bb cd2901          	CALL	MOVECD		;set (TDRIVE) also.
  1091   0006be cdbd00          	CALL	DSKSEL		;and select this drive.
  1092   0006c1 c38907          	JP	GETBACK1	;then return.
  1093                          ;
  1094                          ;   Here a file name was typed. Prepare to execute it.
  1095                          ;
  1096   0006c4 11d607          UNKWN1:	LD	DE,FCB+9	;an extension specified?
  1097   0006c7 1a              	LD	A,(DE)
  1098   0006c8 fe20            	CP	' '
  1099   0006ca c20902          	JP	NZ,SYNERR	;yes, not allowed.
  1100   0006cd d5              UNKWN2:	PUSH	DE
  1101   0006ce cd5404          	CALL	DSELECT		;select specified drive.
  1102   0006d1 d1              	POP	DE
  1103   0006d2 218307          	LD	HL,COMFILE	;set the extension to 'COM'.
  1104   0006d5 cd4004          	CALL	MOVE3
  1105   0006d8 cdd000          	CALL	OPENFCB		;and open this file.
  1106   0006db ca6b07          	JP	Z,UNKWN9	;not present?
  1107                          ;
  1108                          ;   Load in the program.
  1109                          ;
  1110   0006de 210001          	LD	HL,TBASE	;store the program starting here.
  1111   0006e1 e5              UNKWN3:	PUSH	HL
  1112   0006e2 eb              	EX	DE,HL
  1113   0006e3 cdd801          	CALL	DMASET		;set transfer address.
  1114   0006e6 11cd07          	LD	DE,FCB		;and read the next record.
  1115   0006e9 cdf900          	CALL	RDREC
  1116   0006ec c20107          	JP	NZ,UNKWN4	;end of file or read error?
  1117   0006ef e1              	POP	HL		;nope, bump pointer for next sector.
  1118   0006f0 118000          	LD	DE,128
  1119   0006f3 19              	ADD	HL,DE
  1120   0006f4 110000          	LD	DE,CBASE	;enough room for the whole file?
  1121   0006f7 7d              	LD	A,L
  1122   0006f8 93              	SUB	E
  1123   0006f9 7c              	LD	A,H
  1124   0006fa 9a              	SBC	A,D
  1125   0006fb d27107          	JP	NC,UNKWN0	;no, it can't fit.
  1126   0006fe c3e106          	JP	UNKWN3
  1127                          ;
  1128                          ;   Get here after finished reading.
  1129                          ;
  1130   000701 e1              UNKWN4:	POP	HL
  1131   000702 3d              	DEC	A		;normal end of file?
  1132   000703 c27107          	JP	NZ,UNKWN0
  1133   000706 cd6604          	CALL	RESETDR		;yes, reset previous drive.
  1134   000709 cd5e02          	CALL	CONVFST		;convert the first file name that follows
  1135   00070c 21f007          	LD	HL,CHGDRV	;command name.
  1136   00070f e5              	PUSH	HL
  1137   000710 7e              	LD	A,(HL)		;set drive code in default fcb.
  1138   000711 32cd07          	LD	(FCB),A
  1139   000714 3e10            	LD	A,16		;put second name 16 bytes later.
  1140   000716 cd6002          	CALL	CONVERT		;convert second file name.
  1141   000719 e1              	POP	HL
  1142   00071a 7e              	LD	A,(HL)		;and set the drive for this second file.
  1143   00071b 32dd07          	LD	(FCB+16),A
  1144   00071e af              	XOR	A		;clear record byte in fcb.
  1145   00071f 32ed07          	LD	(FCB+32),A
  1146   000722 115c00          	LD	DE,TFCB		;move it into place at(005Ch).
  1147   000725 21cd07          	LD	HL,FCB
  1148   000728 0621            	LD	B,33
  1149   00072a cd4204          	CALL	HL2DE
  1150   00072d 210800          	LD	HL,INBUFF+2	;now move the remainder of the input
  1151   000730 7e              UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
  1152   000731 b7              	OR	A		;or a null.
  1153   000732 ca3e07          	JP	Z,UNKWN6
  1154   000735 fe20            	CP	' '
  1155   000737 ca3e07          	JP	Z,UNKWN6
  1156   00073a 23              	INC	HL
  1157   00073b c33007          	JP	UNKWN5
  1158                          ;
  1159                          ;   Do the line move now. It ends in a null byte.
  1160                          ;
  1161   00073e 0600            UNKWN6:	LD	B,0		;keep a character count.
  1162   000740 118100          	LD	DE,TBUFF+1	;data gets put here.
  1163   000743 7e              UNKWN7:	LD	A,(HL)		;move it now.
  1164   000744 12              	LD	(DE),A
  1165   000745 b7              	OR	A
  1166   000746 ca4f07          	JP	Z,UNKWN8
  1167   000749 04              	INC	B
  1168   00074a 23              	INC	HL
  1169   00074b 13              	INC	DE
  1170   00074c c34307          	JP	UNKWN7
  1171   00074f 78              UNKWN8:	LD	A,B		;now store the character count.
  1172   000750 328000          	LD	(TBUFF),A
  1173   000753 cd9800          	CALL	CRLF		;clean up the screen.
  1174   000756 cdd501          	CALL	STDDMA		;set standard transfer address.
  1175   000759 cd1a01          	CALL	SETCDRV		;reset current drive.
  1176   00075c cd0001          	CALL	TBASE		;and execute the program.
  1177                          ;
  1178                          ;   Transiant programs return here (or reboot).
  1179                          ;
  1180   00075f 31ab07          	LD	SP,BATCH	;set stack first off.
  1181   000762 cd2901          	CALL	MOVECD		;move current drive into place (TDRIVE).
  1182   000765 cdbd00          	CALL	DSKSEL		;and reselect it.
  1183   000768 c38203          	JP	CMMND1		;back to comand mode.
  1184                          ;
  1185                          ;   Get here if some error occured.
  1186                          ;
  1187   00076b cd6604          UNKWN9:	CALL	RESETDR		;inproper format.
  1188   00076e c30902          	JP	SYNERR
  1189   000771 017a07          UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
  1190   000774 cda700          	CALL	PLINE
  1191   000777 c38607          	JP	GETBACK
  1192   00077a 426164206c6f6164BADLOAD:DB	"Bad load",0
                00              
  1193   000783 434f4d          COMFILE:DB	"COM"		;command file extension.
  1194                          ;
  1195                          ;   Get here to return to command level. We will reset the
  1196                          ; previous active drive and then either return to command
  1197                          ; level directly or print error message and then return.
  1198                          ;
  1199   000786 cd6604          GETBACK:CALL	RESETDR		;reset previous drive.
  1200   000789 cd5e02          GETBACK1: CALL	CONVFST		;convert first name in (FCB).
  1201   00078c 3ace07          	LD	A,(FCB+1)	;if this was just a drive change request,
  1202   00078f d620            	SUB	' '		;make sure it was valid.
  1203   000791 21f007          	LD	HL,CHGDRV
  1204   000794 b6              	OR	(HL)
  1205   000795 c20902          	JP	NZ,SYNERR
  1206   000798 c38203          	JP	CMMND1		;ok, return to command level.
  1207                          ;
  1208                          ;   ccp stack area.
  1209                          ;
  1210   00079b 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
  1211                          CCPSTACK EQU	$	;end of ccp stack area.
  1212                          ;
  1213                          ;   Batch (or SUBMIT) processing information storage.
  1214                          ;
  1215   0007ab 00              BATCH:	DB	0		;batch mode flag (0=not active).
  1216   0007ac 0024242420202020BATCHFCB: DB	0,"$$$     SUB",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                2053554200000000
                0000000000000000
                0000000000000000
                00              
  1217                          ;
  1218                          ;   File control block setup by the CCP.
  1219                          ;
  1220   0007cd 0020202020202020FCB:	DB	0,"           ",0,0,0,0,0,"           ",0,0,0,0,0
                2020202000000000
                0020202020202020
                2020202000000000
                00              
  1221   0007ee 00              RTNCODE:DB	0		;status returned from bdos call.
  1222   0007ef 00              CDRIVE:	DB	0		;currently active drive.
  1223   0007f0 00              CHGDRV:	DB	0		;change in drives flag (0=no change).
  1224   0007f1 0000            NBYTES:	DW	0		;byte counter used by TYPE.
  1225                          ;
  1226                          ;   Room for expansion?
  1227                          ;
  1228   0007f3 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000      
  1229                          ;
  1230                          ;   Note that the following six bytes must match those at
  1231                          ; (PATTRN1) or cp/m will HALT. Why?
  1232                          ;
  1233   000800 001600000000    PATTRN2:DB	0,22,0,0,0,0	;(* serial number bytes *).
  1234                          ;
  1235                          ;**************************************************************
  1236                          ;*
  1237                          ;*                    B D O S   E N T R Y
  1238                          ;*
  1239                          ;**************************************************************
  1240                          ;
  1241   000806 c31108          FBASE:	JP	FBASE1
  1242                          ;
  1243                          ;   Bdos error table.
  1244                          ;
  1245   000809 9908            BADSCTR:DW	ERROR1		;bad sector on read or write.
  1246   00080b a508            BADSLCT:DW	ERROR2		;bad disk select.
  1247   00080d ab08            RODISK:	DW	ERROR3		;disk is read only.
  1248   00080f b108            ROFILE:	DW	ERROR4		;file is read only.
  1249                          ;
  1250                          ;   Entry into bdos. (DE) or (E) are the parameters passed. The
  1251                          ; function number desired is in register (C).
  1252                          ;
  1253   000811 eb              FBASE1:	EX	DE,HL		;save the (DE) parameters.
  1254   000812 22430b          	LD	(PARAMS),HL
  1255   000815 eb              	EX	DE,HL
  1256   000816 7b              	LD	A,E		;and save register (E) in particular.
  1257   000817 32d615          	LD	(EPARAM),A
  1258   00081a 210000          	LD	HL,0
  1259   00081d 22450b          	LD	(STATUS),HL	;clear return status.
  1260   000820 39              	ADD	HL,SP
  1261   000821 220f0b          	LD	(USRSTACK),HL	;save users stack pointer.
  1262   000824 31410b          	LD	SP,STKAREA	;and set our own.
  1263   000827 af              	XOR	A		;clear auto select storage space.
  1264   000828 32e015          	LD	(AUTOFLAG),A
  1265   00082b 32de15          	LD	(AUTO),A
  1266   00082e 217415          	LD	HL,GOBACK	;set return address.
  1267   000831 e5              	PUSH	HL
  1268   000832 79              	LD	A,C		;get function number.
  1269   000833 fe29            	CP	NFUNCTS		;valid function number?
  1270   000835 d0              	RET	NC
  1271   000836 4b              	LD	C,E		;keep single register function here.
  1272   000837 214708          	LD	HL,FUNCTNS	;now look thru the function table.
  1273   00083a 5f              	LD	E,A
  1274   00083b 1600            	LD	D,0		;(DE)=function number.
  1275   00083d 19              	ADD	HL,DE
  1276   00083e 19              	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
  1277   00083f 5e              	LD	E,(HL)
  1278   000840 23              	INC	HL
  1279   000841 56              	LD	D,(HL)		;now (DE)=address for this function.
  1280   000842 2a430b          	LD	HL,(PARAMS)	;retrieve parameters.
  1281   000845 eb              	EX	DE,HL		;now (DE) has the original parameters.
  1282   000846 e9              	JP	(HL)		;execute desired function.
  1283                          ;
  1284                          ;   BDOS function jump table.
  1285                          ;
  1286                          NFUNCTS EQU	41		;number of functions in followin table.
  1287                          ;
  1288   000847 03f2c80a9009ce0aFUNCTNS:DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
                12f20ff2d40aed0a
  1289   000857 f30af80ae109fe0a	DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
                7e14831445149c14
  1290   000867 a514ab14c814d714	DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
                e014e614ec14    
  1291   000875 f514fe1404150a15	DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
                11152c0d17151d15
  1292   000885 26152d1541154715	DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
                4d150e145315040b
  1293   000895 040b9b15        	DW	RTN,WTSPECL
  1294                          ;
  1295                          ;   Bdos error message section.
  1296                          ;
  1297   000899 21ca08          ERROR1:	LD	HL,BADSEC	;bad sector message.
  1298   00089c cde508          	CALL	PRTERR		;print it and get a 1 char responce.
  1299   00089f fe03            	CP	CNTRLC		;re-boot request (control-c)?
  1300   0008a1 ca0000          	JP	Z,0		;yes.
  1301   0008a4 c9              	RET			;no, return to retry i/o function.
  1302                          ;
  1303   0008a5 21d508          ERROR2:	LD	HL,BADSEL	;bad drive selected.
  1304   0008a8 c3b408          	JP	ERROR5
  1305                          ;
  1306   0008ab 21e108          ERROR3:	LD	HL,DISKRO	;disk is read only.
  1307   0008ae c3b408          	JP	ERROR5
  1308                          ;
  1309   0008b1 21dc08          ERROR4:	LD	HL,FILERO	;file is read only.
  1310                          ;
  1311   0008b4 cde508          ERROR5:	CALL	PRTERR
  1312   0008b7 c30000          	JP	0		;always reboot on these errors.
  1313                          ;
  1314   0008ba 42646f7320457272BDOSERR:DB	"Bdos Err On "
                204f6e20        
  1315   0008c6 203a2024        BDOSDRV:DB	" : $"
  1316   0008ca 4261642053656374BADSEC:	DB	"Bad Sector$"
                6f7224          
  1317   0008d5 53656c65637424  BADSEL:	DB	"Select$"
  1318   0008dc 46696c6520      FILERO:	DB	"File "
  1319   0008e1 522f4f24        DISKRO:	DB	"R/O$"
  1320                          ;
  1321                          ;   Print bdos error message.
  1322                          ;
  1323   0008e5 e5              PRTERR:	PUSH	HL		;save second message pointer.
  1324   0008e6 cdc909          	CALL	OUTCRLF		;send (cr)(lf).
  1325   0008e9 3a420b          	LD	A,(ACTIVE)	;get active drive.
  1326   0008ec c641            	ADD	A,'A'		;make ascii.
  1327   0008ee 32c608          	LD	(BDOSDRV),A	;and put in message.
  1328   0008f1 01ba08          	LD	BC,BDOSERR	;and print it.
  1329   0008f4 cdd309          	CALL	PRTMESG
  1330   0008f7 c1              	POP	BC		;print second message line now.
  1331   0008f8 cdd309          	CALL	PRTMESG
  1332                          ;
  1333                          ;   Get an input character. We will check our 1 character
  1334                          ; buffer first. This may be set by the console status routine.
  1335                          ;
  1336   0008fb 210e0b          GETCHAR:LD	HL,CHARBUF	;check character buffer.
  1337   0008fe 7e              	LD	A,(HL)		;anything present already?
  1338   0008ff 3600            	LD	(HL),0		;...either case clear it.
  1339   000901 b7              	OR	A
  1340   000902 c0              	RET	NZ		;yes, use it.
  1341   000903 c309f2          	JP	CONIN		;nope, go get a character responce.
  1342                          ;
  1343                          ;   Input and echo a character.
  1344                          ;
  1345   000906 cdfb08          GETECHO:CALL	GETCHAR		;input a character.
  1346   000909 cd1409          	CALL	CHKCHAR		;carriage control?
  1347   00090c d8              	RET	C		;no, a regular control char so don't echo.
  1348   00090d f5              	PUSH	AF		;ok, save character now.
  1349   00090e 4f              	LD	C,A
  1350   00090f cd9009          	CALL	OUTCON		;and echo it.
  1351   000912 f1              	POP	AF		;get character and return.
  1352   000913 c9              	RET
  1353                          ;
  1354                          ;   Check character in (A). Set the zero flag on a carriage
  1355                          ; control character and the carry flag on any other control
  1356                          ; character.
  1357                          ;
  1358   000914 fe0d            CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
  1359   000916 c8              	RET	Z		;or a tab.
  1360   000917 fe0a            	CP	LF
  1361   000919 c8              	RET	Z
  1362   00091a fe09            	CP	TAB
  1363   00091c c8              	RET	Z
  1364   00091d fe08            	CP	BS
  1365   00091f c8              	RET	Z
  1366   000920 fe20            	CP	' '		;other control char? Set carry flag.
  1367   000922 c9              	RET
  1368                          ;
  1369                          ;   Check the console during output. Halt on a control-s, then
  1370                          ; reboot on a control-c. If anything else is ready, clear the
  1371                          ; zero flag and return (the calling routine may want to do
  1372                          ; something).
  1373                          ;
  1374   000923 3a0e0b          CKCONSOL: LD	A,(CHARBUF)	;check buffer.
  1375   000926 b7              	OR	A		;if anything, just return without checking.
  1376   000927 c24509          	JP	NZ,CKCON2
  1377   00092a cd06f2          	CALL	CONST		;nothing in buffer. Check console.
  1378   00092d e601            	AND	01H		;look at bit 0.
  1379   00092f c8              	RET	Z		;return if nothing.
  1380   000930 cd09f2          	CALL	CONIN		;ok, get it.
  1381   000933 fe13            	CP	CNTRLS		;if not control-s, return with zero cleared.
  1382   000935 c24209          	JP	NZ,CKCON1
  1383   000938 cd09f2          	CALL	CONIN		;halt processing until another char
  1384   00093b fe03            	CP	CNTRLC		;is typed. Control-c?
  1385   00093d ca0000          	JP	Z,0		;yes, reboot now.
  1386   000940 af              	XOR	A		;no, just pretend nothing was ever ready.
  1387   000941 c9              	RET
  1388   000942 320e0b          CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
  1389   000945 3e01            CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
  1390   000947 c9              	RET
  1391                          ;
  1392                          ;   Output (C) to the screen. If the printer flip-flop flag
  1393                          ; is set, we will send character to printer also. The console
  1394                          ; will be checked in the process.
  1395                          ;
  1396   000948 3a0a0b          OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
  1397   00094b b7              	OR	A		;anything and we won't generate output.
  1398   00094c c26209          	JP	NZ,OUTCHR1
  1399   00094f c5              	PUSH	BC
  1400   000950 cd2309          	CALL	CKCONSOL	;check console (we don't care whats there).
  1401   000953 c1              	POP	BC
  1402   000954 c5              	PUSH	BC
  1403   000955 cd0cf2          	CALL	CONOUT		;output (C) to the screen.
  1404   000958 c1              	POP	BC
  1405   000959 c5              	PUSH	BC
  1406   00095a 3a0d0b          	LD	A,(PRTFLAG)	;check printer flip-flop flag.
  1407   00095d b7              	OR	A
  1408   00095e c40ff2          	CALL	NZ,LIST		;print it also if non-zero.
  1409   000961 c1              	POP	BC
  1410   000962 79              OUTCHR1:LD	A,C		;update cursors position.
  1411   000963 210c0b          	LD	HL,CURPOS
  1412   000966 fe7f            	CP	DEL		;rubouts don't do anything here.
  1413   000968 c8              	RET	Z
  1414   000969 34              	INC	(HL)		;bump line pointer.
  1415   00096a fe20            	CP	' '		;and return if a normal character.
  1416   00096c d0              	RET	NC
  1417   00096d 35              	DEC	(HL)		;restore and check for the start of the line.
  1418   00096e 7e              	LD	A,(HL)
  1419   00096f b7              	OR	A
  1420   000970 c8              	RET	Z		;ingnore control characters at the start of the line.
  1421   000971 79              	LD	A,C
  1422   000972 fe08            	CP	BS		;is it a backspace?
  1423   000974 c27909          	JP	NZ,OUTCHR2
  1424   000977 35              	DEC	(HL)		;yes, backup pointer.
  1425   000978 c9              	RET
  1426   000979 fe0a            OUTCHR2:CP	LF		;is it a line feed?
  1427   00097b c0              	RET	NZ		;ignore anything else.
  1428   00097c 3600            	LD	(HL),0		;reset pointer to start of line.
  1429   00097e c9              	RET
  1430                          ;
  1431                          ;   Output (A) to the screen. If it is a control character
  1432                          ; (other than carriage control), use ^x format.
  1433                          ;
  1434   00097f 79              SHOWIT:	LD	A,C
  1435   000980 cd1409          	CALL	CHKCHAR		;check character.
  1436   000983 d29009          	JP	NC,OUTCON	;not a control, use normal output.
  1437   000986 f5              	PUSH	AF
  1438   000987 0e5e            	LD	C,'^'		;for a control character, preceed it with '^'.
  1439   000989 cd4809          	CALL	OUTCHAR
  1440   00098c f1              	POP	AF
  1441   00098d f640            	OR	'@'		;and then use the letter equivelant.
  1442   00098f 4f              	LD	C,A
  1443                          ;
  1444                          ;   Function to output (C) to the console device and expand tabs
  1445                          ; if necessary.
  1446                          ;
  1447   000990 79              OUTCON:	LD	A,C
  1448   000991 fe09            	CP	TAB		;is it a tab?
  1449   000993 c24809          	JP	NZ,OUTCHAR	;use regular output.
  1450   000996 0e20            OUTCON1:LD	C,' '		;yes it is, use spaces instead.
  1451   000998 cd4809          	CALL	OUTCHAR
  1452   00099b 3a0c0b          	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
  1453                          
  1454   00099e e607            	AND	07H		;position.
  1455   0009a0 c29609          	JP	NZ,OUTCON1
  1456   0009a3 c9              	RET
  1457                          ;
  1458                          ;   Echo a backspace character. Erase the prevoius character
  1459                          ; on the screen.
  1460                          ;
  1461   0009a4 cdac09          BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
  1462   0009a7 0e20            	LD	C,' '		;then blank that character.
  1463   0009a9 cd0cf2          	CALL	CONOUT
  1464   0009ac 0e08            BACKUP1:LD	C,BS		;then back space once more.
  1465   0009ae c30cf2          	JP	CONOUT
  1466                          ;
  1467                          ;   Signal a deleted line. Print a '#' at the end and start
  1468                          ; over.
  1469                          ;
  1470   0009b1 0e23            NEWLINE:LD	C,'#'
  1471   0009b3 cd4809          	CALL	OUTCHAR		;print this.
  1472   0009b6 cdc909          	CALL	OUTCRLF		;start new line.
  1473   0009b9 3a0c0b          NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
  1474   0009bc 210b0b          	LD	HL,STARTING
  1475   0009bf be              	CP	(HL)
  1476   0009c0 d0              	RET	NC		;there yet?
  1477   0009c1 0e20            	LD	C,' '
  1478   0009c3 cd4809          	CALL	OUTCHAR		;nope, keep going.
  1479   0009c6 c3b909          	JP	NEWLN1
  1480                          ;
  1481                          ;   Output a (cr) (lf) to the console device (screen).
  1482                          ;
  1483   0009c9 0e0d            OUTCRLF:LD	C,CR
  1484   0009cb cd4809          	CALL	OUTCHAR
  1485   0009ce 0e0a            	LD	C,LF
  1486   0009d0 c34809          	JP	OUTCHAR
  1487                          ;
  1488                          ;   Print message pointed to by (BC). It will end with a '$'.
  1489                          ;
  1490   0009d3 0a              PRTMESG:LD	A,(BC)		;check for terminating character.
  1491   0009d4 fe24            	CP	'$'
  1492   0009d6 c8              	RET	Z
  1493   0009d7 03              	INC	BC
  1494   0009d8 c5              	PUSH	BC		;otherwise, bump pointer and print it.
  1495   0009d9 4f              	LD	C,A
  1496   0009da cd9009          	CALL	OUTCON
  1497   0009dd c1              	POP	BC
  1498   0009de c3d309          	JP	PRTMESG
  1499                          ;
  1500                          ;   Function to execute a buffered read.
  1501                          ;
  1502   0009e1 3a0c0b          RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
  1503   0009e4 320b0b          	LD	(STARTING),A
  1504   0009e7 2a430b          	LD	HL,(PARAMS)	;get the maximum buffer space.
  1505   0009ea 4e              	LD	C,(HL)
  1506   0009eb 23              	INC	HL		;point to first available space.
  1507   0009ec e5              	PUSH	HL		;and save.
  1508   0009ed 0600            	LD	B,0		;keep a character count.
  1509   0009ef c5              RDBUF1:	PUSH	BC
  1510   0009f0 e5              	PUSH	HL
  1511   0009f1 cdfb08          RDBUF2:	CALL	GETCHAR		;get the next input character.
  1512   0009f4 e67f            	AND	7FH		;strip bit 7.
  1513   0009f6 e1              	POP	HL		;reset registers.
  1514   0009f7 c1              	POP	BC
  1515   0009f8 fe0d            	CP	CR		;en of the line?
  1516   0009fa cac10a          	JP	Z,RDBUF17
  1517   0009fd fe0a            	CP	LF
  1518   0009ff cac10a          	JP	Z,RDBUF17
  1519   000a02 fe08            	CP	BS		;how about a backspace?
  1520   000a04 c2160a          	JP	NZ,RDBUF3
  1521   000a07 78              	LD	A,B		;yes, but ignore at the beginning of the line.
  1522   000a08 b7              	OR	A
  1523   000a09 caef09          	JP	Z,RDBUF1
  1524   000a0c 05              	DEC	B		;ok, update counter.
  1525   000a0d 3a0c0b          	LD	A,(CURPOS)	;if we backspace to the start of the line,
  1526   000a10 320a0b          	LD	(OUTFLAG),A	;treat as a cancel (control-x).
  1527   000a13 c3700a          	JP	RDBUF10
  1528   000a16 fe7f            RDBUF3:	CP	DEL		;user typed a rubout?
  1529   000a18 c2260a          	JP	NZ,RDBUF4
  1530   000a1b 78              	LD	A,B		;ignore at the start of the line.
  1531   000a1c b7              	OR	A
  1532   000a1d caef09          	JP	Z,RDBUF1
  1533   000a20 7e              	LD	A,(HL)		;ok, echo the prevoius character.
  1534   000a21 05              	DEC	B		;and reset pointers (counters).
  1535   000a22 2b              	DEC	HL
  1536   000a23 c3a90a          	JP	RDBUF15
  1537   000a26 fe05            RDBUF4:	CP	CNTRLE		;physical end of line?
  1538   000a28 c2370a          	JP	NZ,RDBUF5
  1539   000a2b c5              	PUSH	BC		;yes, do it.
  1540   000a2c e5              	PUSH	HL
  1541   000a2d cdc909          	CALL	OUTCRLF
  1542   000a30 af              	XOR	A		;and update starting position.
  1543   000a31 320b0b          	LD	(STARTING),A
  1544   000a34 c3f109          	JP	RDBUF2
  1545   000a37 fe10            RDBUF5:	CP	CNTRLP		;control-p?
  1546   000a39 c2480a          	JP	NZ,RDBUF6
  1547   000a3c e5              	PUSH	HL		;yes, flip the print flag filp-flop byte.
  1548   000a3d 210d0b          	LD	HL,PRTFLAG
  1549   000a40 3e01            	LD	A,1		;PRTFLAG=1-PRTFLAG
  1550   000a42 96              	SUB	(HL)
  1551   000a43 77              	LD	(HL),A
  1552   000a44 e1              	POP	HL
  1553   000a45 c3ef09          	JP	RDBUF1
  1554   000a48 fe18            RDBUF6:	CP	CNTRLX		;control-x (cancel)?
  1555   000a4a c25f0a          	JP	NZ,RDBUF8
  1556   000a4d e1              	POP	HL
  1557   000a4e 3a0b0b          RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
  1558   000a51 210c0b          	LD	HL,CURPOS
  1559   000a54 be              	CP	(HL)
  1560   000a55 d2e109          	JP	NC,RDBUFF	;done yet?
  1561   000a58 35              	DEC	(HL)		;no, decrement pointer and output back up one space.
  1562   000a59 cda409          	CALL	BACKUP
  1563   000a5c c34e0a          	JP	RDBUF7
  1564   000a5f fe15            RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
  1565   000a61 c26b0a          	JP	NZ,RDBUF9
  1566   000a64 cdb109          	CALL	NEWLINE		;start a new line.
  1567   000a67 e1              	POP	HL
  1568   000a68 c3e109          	JP	RDBUFF
  1569   000a6b fe12            RDBUF9:	CP	CNTRLR		;control-r?
  1570   000a6d c2a60a          	JP	NZ,RDBUF14
  1571   000a70 c5              RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
  1572   000a71 cdb109          	CALL	NEWLINE
  1573   000a74 c1              	POP	BC
  1574   000a75 e1              	POP	HL
  1575   000a76 e5              	PUSH	HL
  1576   000a77 c5              	PUSH	BC
  1577   000a78 78              RDBUF11:LD	A,B		;done whole line yet?
  1578   000a79 b7              	OR	A
  1579   000a7a ca8a0a          	JP	Z,RDBUF12
  1580   000a7d 23              	INC	HL		;nope, get next character.
  1581   000a7e 4e              	LD	C,(HL)
  1582   000a7f 05              	DEC	B		;count it.
  1583   000a80 c5              	PUSH	BC
  1584   000a81 e5              	PUSH	HL
  1585   000a82 cd7f09          	CALL	SHOWIT		;and display it.
  1586   000a85 e1              	POP	HL
  1587   000a86 c1              	POP	BC
  1588   000a87 c3780a          	JP	RDBUF11
  1589   000a8a e5              RDBUF12:PUSH	HL		;done with line. If we were displaying
  1590   000a8b 3a0a0b          	LD	A,(OUTFLAG)	;then update cursor position.
  1591   000a8e b7              	OR	A
  1592   000a8f caf109          	JP	Z,RDBUF2
  1593   000a92 210c0b          	LD	HL,CURPOS	;because this line is shorter, we must
  1594   000a95 96              	SUB	(HL)		;back up the cursor (not the screen however)
  1595   000a96 320a0b          	LD	(OUTFLAG),A	;some number of positions.
  1596   000a99 cda409          RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
  1597   000a9c 210a0b          	LD	HL,OUTFLAG	;zero, the screen will not be changed.
  1598   000a9f 35              	DEC	(HL)
  1599   000aa0 c2990a          	JP	NZ,RDBUF13
  1600   000aa3 c3f109          	JP	RDBUF2		;now just get the next character.
  1601                          ;
  1602                          ;   Just a normal character, put this in our buffer and echo.
  1603                          ;
  1604   000aa6 23              RDBUF14:INC	HL
  1605   000aa7 77              	LD	(HL),A		;store character.
  1606   000aa8 04              	INC	B		;and count it.
  1607   000aa9 c5              RDBUF15:PUSH	BC
  1608   000aaa e5              	PUSH	HL
  1609   000aab 4f              	LD	C,A		;echo it now.
  1610   000aac cd7f09          	CALL	SHOWIT
  1611   000aaf e1              	POP	HL
  1612   000ab0 c1              	POP	BC
  1613   000ab1 7e              	LD	A,(HL)		;was it an abort request?
  1614   000ab2 fe03            	CP	CNTRLC		;control-c abort?
  1615   000ab4 78              	LD	A,B
  1616   000ab5 c2bd0a          	JP	NZ,RDBUF16
  1617   000ab8 fe01            	CP	1		;only if at start of line.
  1618   000aba ca0000          	JP	Z,0
  1619   000abd b9              RDBUF16:CP	C		;nope, have we filled the buffer?
  1620   000abe daef09          	JP	C,RDBUF1
  1621   000ac1 e1              RDBUF17:POP	HL		;yes end the line and return.
  1622   000ac2 70              	LD	(HL),B
  1623   000ac3 0e0d            	LD	C,CR
  1624   000ac5 c34809          	JP	OUTCHAR		;output (cr) and return.
  1625                          ;
  1626                          ;   Function to get a character from the console device.
  1627                          ;
  1628   000ac8 cd0609          GETCON:	CALL	GETECHO		;get and echo.
  1629   000acb c3010b          	JP	SETSTAT		;save status and return.
  1630                          ;
  1631                          ;   Function to get a character from the tape reader device.
  1632                          ;
  1633   000ace cd15f2          GETRDR:	CALL	READER		;get a character from reader, set status and return.
  1634   000ad1 c3010b          	JP	SETSTAT
  1635                          ;
  1636                          ;  Function to perform direct console i/o. If (C) contains (FF)
  1637                          ; then this is an input request. If (C) contains (FE) then
  1638                          ; this is a status request. Otherwise we are to output (C).
  1639                          ;
  1640   000ad4 79              DIRCIO:	LD	A,C		;test for (FF).
  1641   000ad5 3c              	INC	A
  1642   000ad6 cae00a          	JP	Z,DIRC1
  1643   000ad9 3c              	INC	A		;test for (FE).
  1644   000ada ca06f2          	JP	Z,CONST
  1645   000add c30cf2          	JP	CONOUT		;just output (C).
  1646   000ae0 cd06f2          DIRC1:	CALL	CONST		;this is an input request.
  1647   000ae3 b7              	OR	A
  1648   000ae4 ca9115          	JP	Z,GOBACK1	;not ready? Just return (directly).
  1649   000ae7 cd09f2          	CALL	CONIN		;yes, get character.
  1650   000aea c3010b          	JP	SETSTAT		;set status and return.
  1651                          ;
  1652                          ;   Function to return the i/o byte.
  1653                          ;
  1654   000aed 3a0300          GETIOB:	LD	A,(IOBYTE)
  1655   000af0 c3010b          	JP	SETSTAT
  1656                          ;
  1657                          ;   Function to set the i/o byte.
  1658                          ;
  1659   000af3 210300          SETIOB:	LD	HL,IOBYTE
  1660   000af6 71              	LD	(HL),C
  1661   000af7 c9              	RET
  1662                          ;
  1663                          ;   Function to print the character string pointed to by (DE)
  1664                          ; on the console device. The string ends with a '$'.
  1665                          ;
  1666   000af8 eb              PRTSTR:	EX	DE,HL
  1667   000af9 4d              	LD	C,L
  1668   000afa 44              	LD	B,H		;now (BC) points to it.
  1669   000afb c3d309          	JP	PRTMESG
  1670                          ;
  1671                          ;   Function to interigate the console device.
  1672                          ;
  1673   000afe cd2309          GETCSTS:CALL	CKCONSOL
  1674                          ;
  1675                          ;   Get here to set the status and return to the cleanup
  1676                          ; section. Then back to the user.
  1677                          ;
  1678   000b01 32450b          SETSTAT:LD	(STATUS),A
  1679   000b04 c9              RTN:	RET
  1680                          ;
  1681                          ;   Set the status to 1 (read or write error code).
  1682                          ;
  1683   000b05 3e01            IOERR1:	LD	A,1
  1684   000b07 c3010b          	JP	SETSTAT
  1685                          ;
  1686   000b0a 00              OUTFLAG:DB	0		;output flag (non zero means no output).
  1687   000b0b 02              STARTING: DB	2		;starting position for cursor.
  1688   000b0c 00              CURPOS:	DB	0		;cursor position (0=start of line).
  1689   000b0d 00              PRTFLAG:DB	0		;printer flag (control-p toggle). List if non zero.
  1690   000b0e 00              CHARBUF:DB	0		;single input character buffer.
  1691                          ;
  1692                          ;   Stack area for BDOS calls.
  1693                          ;
  1694   000b0f 0000            USRSTACK: DW	0		;save users stack pointer here.
  1695                          ;
  1696   000b11 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                0000000000000000
  1697   000b29 0000000000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
                0000000000000000
  1698                          STKAREA EQU	$		;end of stack area.
  1699                          ;
  1700   000b41 00              USERNO:	DB	0		;current user number.
  1701   000b42 00              ACTIVE:	DB	0		;currently active drive.
  1702   000b43 0000            PARAMS:	DW	0		;save (DE) parameters here on entry.
  1703   000b45 0000            STATUS:	DW	0		;status returned from bdos function.
  1704                          ;
  1705                          ;   Select error occured, jump to error routine.
  1706                          ;
  1707   000b47 210b08          SLCTERR:LD	HL,BADSLCT
  1708                          ;
  1709                          ;   Jump to (HL) indirectly.
  1710                          ;
  1711   000b4a 5e              JUMPHL:	LD	E,(HL)
  1712   000b4b 23              	INC	HL
  1713   000b4c 56              	LD	D,(HL)		;now (DE) contain the desired address.
  1714   000b4d eb              	EX	DE,HL
  1715   000b4e e9              	JP	(HL)
  1716                          ;
  1717                          ;   Block move. (DE) to (HL), (C) bytes total.
  1718                          ;
  1719   000b4f 0c              DE2HL:	INC	C		;is count down to zero?
  1720   000b50 0d              DE2HL1:	DEC	C
  1721   000b51 c8              	RET	Z		;yes, we are done.
  1722   000b52 1a              	LD	A,(DE)		;no, move one more byte.
  1723   000b53 77              	LD	(HL),A
  1724   000b54 13              	INC	DE
  1725   000b55 23              	INC	HL
  1726   000b56 c3500b          	JP	DE2HL1		;and repeat.
  1727                          ;
  1728                          ;   Select the desired drive.
  1729                          ;
  1730   000b59 3a420b          SELECT:	LD	A,(ACTIVE)	;get active disk.
  1731   000b5c 4f              	LD	C,A
  1732   000b5d cd1bf2          	CALL	SELDSK		;select it.
  1733   000b60 7c              	LD	A,H		;valid drive?
  1734   000b61 b5              	OR	L		;valid drive?
  1735   000b62 c8              	RET	Z		;return if not.
  1736                          ;
  1737                          ;   Here, the BIOS returned the address of the parameter block
  1738                          ; in (HL). We will extract the necessary pointers and save them.
  1739                          ;
  1740   000b63 5e              	LD	E,(HL)		;yes, get address of translation table into (DE).
  1741   000b64 23              	INC	HL
  1742   000b65 56              	LD	D,(HL)
  1743   000b66 23              	INC	HL
  1744   000b67 22b315          	LD	(SCRATCH1),HL	;save pointers to scratch areas.
  1745   000b6a 23              	INC	HL
  1746   000b6b 23              	INC	HL
  1747   000b6c 22b515          	LD	(SCRATCH2),HL	;ditto.
  1748   000b6f 23              	INC	HL
  1749   000b70 23              	INC	HL
  1750   000b71 22b715          	LD	(SCRATCH3),HL	;ditto.
  1751   000b74 23              	INC	HL
  1752   000b75 23              	INC	HL
  1753   000b76 eb              	EX	DE,HL		;now save the translation table address.
  1754   000b77 22d015          	LD	(XLATE),HL
  1755   000b7a 21b915          	LD	HL,DIRBUF	;put the next 8 bytes here.
  1756   000b7d 0e08            	LD	C,8		;they consist of the directory buffer
  1757   000b7f cd4f0b          	CALL	DE2HL		;pointer, parameter block pointer,
  1758   000b82 2abb15          	LD	HL,(DISKPB)	;check and allocation vectors.
  1759   000b85 eb              	EX	DE,HL
  1760   000b86 21c115          	LD	HL,SECTORS	;move parameter block into our ram.
  1761   000b89 0e0f            	LD	C,15		;it is 15 bytes long.
  1762   000b8b cd4f0b          	CALL	DE2HL
  1763   000b8e 2ac615          	LD	HL,(DSKSIZE)	;check disk size.
  1764   000b91 7c              	LD	A,H		;more than 256 blocks on this?
  1765   000b92 21dd15          	LD	HL,BIGDISK
  1766   000b95 36ff            	LD	(HL),0FFH	;set to samll.
  1767   000b97 b7              	OR	A
  1768   000b98 ca9d0b          	JP	Z,SELECT1
  1769   000b9b 3600            	LD	(HL),0		;wrong, set to large.
  1770   000b9d 3eff            SELECT1:LD	A,0FFH		;clear the zero flag.
  1771   000b9f b7              	OR	A
  1772   000ba0 c9              	RET
  1773                          ;
  1774                          ;   Routine to home the disk track head and clear pointers.
  1775                          ;
  1776   000ba1 cd18f2          HOMEDRV:CALL	HOME		;home the head.
  1777   000ba4 af              	XOR	A
  1778   000ba5 2ab515          	LD	HL,(SCRATCH2)	;set our track pointer also.
  1779   000ba8 77              	LD	(HL),A
  1780   000ba9 23              	INC	HL
  1781   000baa 77              	LD	(HL),A
  1782   000bab 2ab715          	LD	HL,(SCRATCH3)	;and our sector pointer.
  1783   000bae 77              	LD	(HL),A
  1784   000baf 23              	INC	HL
  1785   000bb0 77              	LD	(HL),A
  1786   000bb1 c9              	RET
  1787                          ;
  1788                          ;   Do the actual disk read and check the error return status.
  1789                          ;
  1790   000bb2 cd27f2          DOREAD:	CALL	READ
  1791   000bb5 c3bb0b          	JP	IORET
  1792                          ;
  1793                          ;   Do the actual disk write and handle any bios error.
  1794                          ;
  1795   000bb8 cd2af2          DOWRITE:CALL	WRITE
  1796   000bbb b7              IORET:	OR	A
  1797   000bbc c8              	RET	Z		;return unless an error occured.
  1798   000bbd 210908          	LD	HL,BADSCTR	;bad read/write on this sector.
  1799   000bc0 c34a0b          	JP	JUMPHL
  1800                          ;
  1801                          ;   Routine to select the track and sector that the desired
  1802                          ; block number falls in.
  1803                          ;
  1804   000bc3 2aea15          TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
  1805   000bc6 0e02            	LD	C,2		;in directory and compute sector #.
  1806   000bc8 cdea0c          	CALL	SHIFTR		;sector #=file-position/4.
  1807   000bcb 22e515          	LD	(BLKNMBR),HL	;save this as the block number of interest.
  1808   000bce 22ec15          	LD	(CKSUMTBL),HL	;what's it doing here too?
  1809                          ;
  1810                          ;   if the sector number has already been set (BLKNMBR), enter
  1811                          ; at this point.
  1812                          ;
  1813   000bd1 21e515          TRKSEC1:LD	HL,BLKNMBR
  1814   000bd4 4e              	LD	C,(HL)		;move sector number into (BC).
  1815   000bd5 23              	INC	HL
  1816   000bd6 46              	LD	B,(HL)
  1817   000bd7 2ab715          	LD	HL,(SCRATCH3)	;get current sector number and
  1818   000bda 5e              	LD	E,(HL)		;move this into (DE).
  1819   000bdb 23              	INC	HL
  1820   000bdc 56              	LD	D,(HL)
  1821   000bdd 2ab515          	LD	HL,(SCRATCH2)	;get current track number.
  1822   000be0 7e              	LD	A,(HL)		;and this into (HL).
  1823   000be1 23              	INC	HL
  1824   000be2 66              	LD	H,(HL)
  1825   000be3 6f              	LD	L,A
  1826   000be4 79              TRKSEC2:LD	A,C		;is desired sector before current one?
  1827   000be5 93              	SUB	E
  1828   000be6 78              	LD	A,B
  1829   000be7 9a              	SBC	A,D
  1830   000be8 d2fa0b          	JP	NC,TRKSEC3
  1831   000beb e5              	PUSH	HL		;yes, decrement sectors by one track.
  1832   000bec 2ac115          	LD	HL,(SECTORS)	;get sectors per track.
  1833   000bef 7b              	LD	A,E
  1834   000bf0 95              	SUB	L
  1835   000bf1 5f              	LD	E,A
  1836   000bf2 7a              	LD	A,D
  1837   000bf3 9c              	SBC	A,H
  1838   000bf4 57              	LD	D,A		;now we have backed up one full track.
  1839   000bf5 e1              	POP	HL
  1840   000bf6 2b              	DEC	HL		;adjust track counter.
  1841   000bf7 c3e40b          	JP	TRKSEC2
  1842   000bfa e5              TRKSEC3:PUSH	HL		;desired sector is after current one.
  1843   000bfb 2ac115          	LD	HL,(SECTORS)	;get sectors per track.
  1844   000bfe 19              	ADD	HL,DE		;bump sector pointer to next track.
  1845   000bff da0f0c          	JP	C,TRKSEC4
  1846   000c02 79              	LD	A,C		;is desired sector now before current one?
  1847   000c03 95              	SUB	L
  1848   000c04 78              	LD	A,B
  1849   000c05 9c              	SBC	A,H
  1850   000c06 da0f0c          	JP	C,TRKSEC4
  1851   000c09 eb              	EX	DE,HL		;not yes, increment track counter
  1852   000c0a e1              	POP	HL		;and continue until it is.
  1853   000c0b 23              	INC	HL
  1854   000c0c c3fa0b          	JP	TRKSEC3
  1855                          ;
  1856                          ;   here we have determined the track number that contains the
  1857                          ; desired sector.
  1858                          ;
  1859   000c0f e1              TRKSEC4:POP	HL		;get track number (HL).
  1860   000c10 c5              	PUSH	BC
  1861   000c11 d5              	PUSH	DE
  1862   000c12 e5              	PUSH	HL
  1863   000c13 eb              	EX	DE,HL
  1864   000c14 2ace15          	LD	HL,(OFFSET)	;adjust for first track offset.
  1865   000c17 19              	ADD	HL,DE
  1866   000c18 44              	LD	B,H
  1867   000c19 4d              	LD	C,L
  1868   000c1a cd1ef2          	CALL	SETTRK		;select this track.
  1869   000c1d d1              	POP	DE		;reset current track pointer.
  1870   000c1e 2ab515          	LD	HL,(SCRATCH2)
  1871   000c21 73              	LD	(HL),E
  1872   000c22 23              	INC	HL
  1873   000c23 72              	LD	(HL),D
  1874   000c24 d1              	POP	DE
  1875   000c25 2ab715          	LD	HL,(SCRATCH3)	;reset the first sector on this track.
  1876   000c28 73              	LD	(HL),E
  1877   000c29 23              	INC	HL
  1878   000c2a 72              	LD	(HL),D
  1879   000c2b c1              	POP	BC
  1880   000c2c 79              	LD	A,C		;now subtract the desired one.
  1881   000c2d 93              	SUB	E		;to make it relative (1-# sectors/track).
  1882   000c2e 4f              	LD	C,A
  1883   000c2f 78              	LD	A,B
  1884   000c30 9a              	SBC	A,D
  1885   000c31 47              	LD	B,A
  1886   000c32 2ad015          	LD	HL,(XLATE)	;translate this sector according to this table.
  1887   000c35 eb              	EX	DE,HL
  1888   000c36 cd30f2          	CALL	SECTRN		;let the bios translate it.
  1889   000c39 4d              	LD	C,L
  1890   000c3a 44              	LD	B,H
  1891   000c3b c321f2          	JP	SETSEC		;and select it.
  1892                          ;
  1893                          ;   Compute block number from record number (SAVNREC) and
  1894                          ; extent number (SAVEXT).
  1895                          ;
  1896   000c3e 21c315          GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
  1897   000c41 4e              	LD	C,(HL)		;note that this is base 2 log of ratio.
  1898   000c42 3ae315          	LD	A,(SAVNREC)	;get record number.
  1899   000c45 b7              GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
  1900   000c46 1f              	RRA
  1901   000c47 0d              	DEC	C
  1902   000c48 c2450c          	JP	NZ,GETBLK1
  1903   000c4b 47              	LD	B,A		;save result in (B).
  1904   000c4c 3e08            	LD	A,8
  1905   000c4e 96              	SUB	(HL)
  1906   000c4f 4f              	LD	C,A		;compute (C)=8-BLKSHFT.
  1907   000c50 3ae215          	LD	A,(SAVEXT)
  1908   000c53 0d              GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
  1909   000c54 ca5c0c          	JP	Z,GETBLK3
  1910   000c57 b7              	OR	A
  1911   000c58 17              	RLA
  1912   000c59 c3530c          	JP	GETBLK2
  1913   000c5c 80              GETBLK3:ADD	A,B
  1914   000c5d c9              	RET
  1915                          ;
  1916                          ;   Routine to extract the (BC) block byte from the fcb pointed
  1917                          ; to by (PARAMS). If this is a big-disk, then these are 16 bit
  1918                          ; block numbers, else they are 8 bit numbers.
  1919                          ; Number is returned in (HL).
  1920                          ;
  1921   000c5e 2a430b          EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
  1922   000c61 111000          	LD	DE,16		;block numbers start 16 bytes into fcb.
  1923   000c64 19              	ADD	HL,DE
  1924   000c65 09              	ADD	HL,BC
  1925   000c66 3add15          	LD	A,(BIGDISK)	;are we using a big-disk?
  1926   000c69 b7              	OR	A
  1927   000c6a ca710c          	JP	Z,EXTBLK1
  1928   000c6d 6e              	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
  1929   000c6e 2600            	LD	H,0
  1930   000c70 c9              	RET
  1931   000c71 09              EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
  1932   000c72 5e              	LD	E,(HL)
  1933   000c73 23              	INC	HL
  1934   000c74 56              	LD	D,(HL)
  1935   000c75 eb              	EX	DE,HL		;return in (HL).
  1936   000c76 c9              	RET
  1937                          ;
  1938                          ;   Compute block number.
  1939                          ;
  1940   000c77 cd3e0c          COMBLK:	CALL	GETBLOCK
  1941   000c7a 4f              	LD	C,A
  1942   000c7b 0600            	LD	B,0
  1943   000c7d cd5e0c          	CALL	EXTBLK
  1944   000c80 22e515          	LD	(BLKNMBR),HL
  1945   000c83 c9              	RET
  1946                          ;
  1947                          ;   Check for a zero block number (unused).
  1948                          ;
  1949   000c84 2ae515          CHKBLK:	LD	HL,(BLKNMBR)
  1950   000c87 7d              	LD	A,L		;is it zero?
  1951   000c88 b4              	OR	H
  1952   000c89 c9              	RET
  1953                          ;
  1954                          ;   Adjust physical block (BLKNMBR) and convert to logical
  1955                          ; sector (LOGSECT). This is the starting sector of this block.
  1956                          ; The actual sector of interest is then added to this and the
  1957                          ; resulting sector number is stored back in (BLKNMBR). This
  1958                          ; will still have to be adjusted for the track number.
  1959                          ;
  1960   000c8a 3ac315          LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
  1961   000c8d 2ae515          	LD	HL,(BLKNMBR)	;get physical sector desired.
  1962   000c90 29              LOGICL1:ADD	HL,HL		;compute logical sector number.
  1963   000c91 3d              	DEC	A		;note logical sectors are 128 bytes long.
  1964   000c92 c2900c          	JP	NZ,LOGICL1
  1965   000c95 22e715          	LD	(LOGSECT),HL	;save logical sector.
  1966   000c98 3ac415          	LD	A,(BLKMASK)	;get block mask.
  1967   000c9b 4f              	LD	C,A
  1968   000c9c 3ae315          	LD	A,(SAVNREC)	;get next sector to access.
  1969   000c9f a1              	AND	C		;extract the relative position within physical block.
  1970   000ca0 b5              	OR	L		;and add it too logical sector.
  1971   000ca1 6f              	LD	L,A
  1972   000ca2 22e515          	LD	(BLKNMBR),HL	;and store.
  1973   000ca5 c9              	RET
  1974                          ;
  1975                          ;   Set (HL) to point to extent byte in fcb.
  1976                          ;
  1977   000ca6 2a430b          SETEXT:	LD	HL,(PARAMS)
  1978   000ca9 110c00          	LD	DE,12		;it is the twelth byte.
  1979   000cac 19              	ADD	HL,DE
  1980   000cad c9              	RET
  1981                          ;
  1982                          ;   Set (HL) to point to record count byte in fcb and (DE) to
  1983                          ; next record number byte.
  1984                          ;
  1985   000cae 2a430b          SETHLDE:LD	HL,(PARAMS)
  1986   000cb1 110f00          	LD	DE,15		;record count byte (#15).
  1987   000cb4 19              	ADD	HL,DE
  1988   000cb5 eb              	EX	DE,HL
  1989   000cb6 211100          	LD	HL,17		;next record number (#32).
  1990   000cb9 19              	ADD	HL,DE
  1991   000cba c9              	RET
  1992                          ;
  1993                          ;   Save current file data from fcb.
  1994                          ;
  1995   000cbb cdae0c          STRDATA:CALL	SETHLDE
  1996   000cbe 7e              	LD	A,(HL)		;get and store record count byte.
  1997   000cbf 32e315          	LD	(SAVNREC),A
  1998   000cc2 eb              	EX	DE,HL
  1999   000cc3 7e              	LD	A,(HL)		;get and store next record number byte.
  2000   000cc4 32e115          	LD	(SAVNXT),A
  2001   000cc7 cda60c          	CALL	SETEXT		;point to extent byte.
  2002   000cca 3ac515          	LD	A,(EXTMASK)	;get extent mask.
  2003   000ccd a6              	AND	(HL)
  2004   000cce 32e215          	LD	(SAVEXT),A	;and save extent here.
  2005   000cd1 c9              	RET
  2006                          ;
  2007                          ;   Set the next record to access. If (MODE) is set to 2, then
  2008                          ; the last record byte (SAVNREC) has the correct number to access.
  2009                          ; For sequential access, (MODE) will be equal to 1.
  2010                          ;
  2011   000cd2 cdae0c          SETNREC:CALL	SETHLDE
  2012   000cd5 3ad515          	LD	A,(MODE)	;get sequential flag (=1).
  2013   000cd8 fe02            	CP	2		;a 2 indicates that no adder is needed.
  2014   000cda c2de0c          	JP	NZ,STNREC1
  2015   000cdd af              	XOR	A		;clear adder (random access?).
  2016   000cde 4f              STNREC1:LD	C,A
  2017   000cdf 3ae315          	LD	A,(SAVNREC)	;get last record number.
  2018   000ce2 81              	ADD	A,C		;increment record count.
  2019   000ce3 77              	LD	(HL),A		;and set fcb's next record byte.
  2020   000ce4 eb              	EX	DE,HL
  2021   000ce5 3ae115          	LD	A,(SAVNXT)	;get next record byte from storage.
  2022   000ce8 77              	LD	(HL),A		;and put this into fcb as number of records used.
  2023   000ce9 c9              	RET
  2024                          ;
  2025                          ;   Shift (HL) right (C) bits.
  2026                          ;
  2027   000cea 0c              SHIFTR:	INC	C
  2028   000ceb 0d              SHIFTR1:DEC	C
  2029   000cec c8              	RET	Z
  2030   000ced 7c              	LD	A,H
  2031   000cee b7              	OR	A
  2032   000cef 1f              	RRA
  2033   000cf0 67              	LD	H,A
  2034   000cf1 7d              	LD	A,L
  2035   000cf2 1f              	RRA
  2036   000cf3 6f              	LD	L,A
  2037   000cf4 c3eb0c          	JP	SHIFTR1
  2038                          ;
  2039                          ;   Compute the check-sum for the directory buffer. Return
  2040                          ; integer sum in (A).
  2041                          ;
  2042   000cf7 0e80            CHECKSUM:	LD	C,128		;length of buffer.
  2043   000cf9 2ab915          		LD	HL,(DIRBUF)	;get its location.
  2044   000cfc af              		XOR	A		;clear summation byte.
  2045   000cfd 86              CHKSUM1:	ADD	A, (HL)		;and compute sum ignoring carries.
  2046   000cfe 23              		INC	HL
  2047   000cff 0d              		DEC	C
  2048   000d00 c2fd0c          		JP	NZ,CHKSUM1
  2049   000d03 c9              		RET
  2050                          ;
  2051                          ;   Shift (HL) left (C) bits.
  2052                          ;
  2053   000d04 0c              SHIFTL:		INC	C
  2054   000d05 0d              SHIFTL1:	DEC	C
  2055   000d06 c8              		RET	Z
  2056   000d07 29              		ADD	HL,HL		;shift left 1 bit.
  2057   000d08 c3050d          		JP	SHIFTL1
  2058                          ;
  2059                          ;   Routine to set a bit in a 16 bit value contained in (BC).
  2060                          ; The bit set depends on the current drive selection.
  2061                          ;
  2062   000d0b c5              SETBIT:	PUSH	BC		;save 16 bit word.
  2063   000d0c 3a420b          	LD	A,(ACTIVE)	;get active drive.
  2064   000d0f 4f              	LD	C,A
  2065   000d10 210100          	LD	HL,1
  2066   000d13 cd040d          	CALL	SHIFTL		;shift bit 0 into place.
  2067   000d16 c1              	POP	BC		;now 'or' this with the original word.
  2068   000d17 79              	LD	A,C
  2069   000d18 b5              	OR	L
  2070   000d19 6f              	LD	L,A		;low byte done, do high byte.
  2071   000d1a 78              	LD	A,B
  2072   000d1b b4              	OR	H
  2073   000d1c 67              	LD	H,A
  2074   000d1d c9              	RET
  2075                          ;
  2076                          ;   Extract the write protect status bit for the current drive.
  2077                          ; The result is returned in (A), bit 0.
  2078                          ;
  2079   000d1e 2aad15          GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
  2080   000d21 3a420b          	LD	A,(ACTIVE)	;which drive is current?
  2081   000d24 4f              	LD	C,A
  2082   000d25 cdea0c          	CALL	SHIFTR		;shift status such that bit 0 is the
  2083   000d28 7d              	LD	A,L		;one of interest for this drive.
  2084   000d29 e601            	AND	01H		;and isolate it.
  2085   000d2b c9              	RET
  2086                          ;
  2087                          ;   Function to write protect the current disk.
  2088                          ;
  2089   000d2c 21ad15          WRTPRTD:LD	HL,WRTPRT	;point to status word.
  2090   000d2f 4e              	LD	C,(HL)		;set (BC) equal to the status.
  2091   000d30 23              	INC	HL
  2092   000d31 46              	LD	B,(HL)
  2093   000d32 cd0b0d          	CALL	SETBIT		;and set this bit according to current drive.
  2094   000d35 22ad15          	LD	(WRTPRT),HL	;then save.
  2095   000d38 2ac815          	LD	HL,(DIRSIZE)	;now save directory size limit.
  2096   000d3b 23              	INC	HL		;remember the last one.
  2097   000d3c eb              	EX	DE,HL
  2098   000d3d 2ab315          	LD	HL,(SCRATCH1)	;and store it here.
  2099   000d40 73              	LD	(HL),E		;put low byte.
  2100   000d41 23              	INC	HL
  2101   000d42 72              	LD	(HL),D		;then high byte.
  2102   000d43 c9              	RET
  2103                          ;
  2104                          ;   Check for a read only file.
  2105                          ;
  2106   000d44 cd5e0d          CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
  2107   000d47 110900          CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
  2108   000d4a 19              	ADD	HL,DE
  2109   000d4b 7e              	LD	A,(HL)
  2110   000d4c 17              	RLA
  2111   000d4d d0              	RET	NC		;return if ok.
  2112   000d4e 210f08          	LD	HL,ROFILE	;else, print error message and terminate.
  2113   000d51 c34a0b          	JP	JUMPHL
  2114                          ;
  2115                          ;   Check the write protect status of the active disk.
  2116                          ;
  2117   000d54 cd1e0d          CHKWPRT:CALL	GETWPRT
  2118   000d57 c8              	RET	Z		;return if ok.
  2119   000d58 210d08          	LD	HL,RODISK	;else print message and terminate.
  2120   000d5b c34a0b          	JP	JUMPHL
  2121                          ;
  2122                          ;   Routine to set (HL) pointing to the proper entry in the
  2123                          ; directory buffer.
  2124                          ;
  2125   000d5e 2ab915          FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
  2126   000d61 3ae915          	LD	A,(FCBPOS)	;relative position of file.
  2127                          ;
  2128                          ;   Routine to add (A) to (HL).
  2129                          ;
  2130   000d64 85              ADDA2HL:ADD	A,L
  2131   000d65 6f              	LD	L,A
  2132   000d66 d0              	RET	NC
  2133   000d67 24              	INC	H		;take care of any carry.
  2134   000d68 c9              	RET
  2135                          ;
  2136                          ;   Routine to get the 's2' byte from the fcb supplied in
  2137                          ; the initial parameter specification.
  2138                          ;
  2139   000d69 2a430b          GETS2:	LD	HL,(PARAMS)	;get address of fcb.
  2140   000d6c 110e00          	LD	DE,14		;relative position of 's2'.
  2141   000d6f 19              	ADD	HL,DE
  2142   000d70 7e              	LD	A,(HL)		;extract this byte.
  2143   000d71 c9              	RET
  2144                          ;
  2145                          ;   Clear the 's2' byte in the fcb.
  2146                          ;
  2147   000d72 cd690d          CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
  2148   000d75 3600            	LD	(HL),0		;now clear it.
  2149   000d77 c9              	RET
  2150                          ;
  2151                          ;   Set bit 7 in the 's2' byte of the fcb.
  2152                          ;
  2153   000d78 cd690d          SETS2B7:CALL	GETS2		;get the byte.
  2154   000d7b f680            	OR	80H		;and set bit 7.
  2155   000d7d 77              	LD	(HL),A		;then store.
  2156   000d7e c9              	RET
  2157                          ;
  2158                          ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
  2159                          ; the difference. This checks to see if there are more file
  2160                          ; names in the directory. We are at (FILEPOS) and there are
  2161                          ; (SCRATCH1) of them to check.
  2162                          ;
  2163   000d7f 2aea15          MOREFLS:LD	HL,(FILEPOS)	;we are here.
  2164   000d82 eb              	EX	DE,HL
  2165   000d83 2ab315          	LD	HL,(SCRATCH1)	;and don't go past here.
  2166   000d86 7b              	LD	A,E		;compute difference but don't keep.
  2167   000d87 96              	SUB	(HL)
  2168   000d88 23              	INC	HL
  2169   000d89 7a              	LD	A,D
  2170   000d8a 9e              	SBC	A,(HL)		;set carry if no more names.
  2171   000d8b c9              	RET
  2172                          ;
  2173                          ;   Call this routine to prevent (SCRATCH1) from being greater
  2174                          ; than (FILEPOS).
  2175                          ;
  2176   000d8c cd7f0d          CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
  2177   000d8f d8              	RET	C
  2178   000d90 13              	INC	DE		;yes, reset it to (FILEPOS).
  2179   000d91 72              	LD	(HL),D
  2180   000d92 2b              	DEC	HL
  2181   000d93 73              	LD	(HL),E
  2182   000d94 c9              	RET
  2183                          ;
  2184                          ;   Compute (HL)=(DE)-(HL)
  2185                          ;
  2186   000d95 7b              SUBHL:	LD	A,E		;compute difference.
  2187   000d96 95              	SUB	L
  2188   000d97 6f              	LD	L,A		;store low byte.
  2189   000d98 7a              	LD	A,D
  2190   000d99 9c              	SBC	A,H
  2191   000d9a 67              	LD	H,A		;and then high byte.
  2192   000d9b c9              	RET
  2193                          ;
  2194                          ;   Set the directory checksum byte.
  2195                          ;
  2196   000d9c 0eff            SETDIR:	LD	C,0FFH
  2197                          ;
  2198                          ;   Routine to set or compare the directory checksum byte. If
  2199                          ; (C)=0ffh, then this will set the checksum byte. Else the byte
  2200                          ; will be checked. If the check fails (the disk has been changed),
  2201                          ; then this disk will be write protected.
  2202                          ;
  2203   000d9e 2aec15          CHECKDIR: LD	HL,(CKSUMTBL)
  2204   000da1 eb              	EX	DE,HL
  2205   000da2 2acc15          	LD	HL,(ALLOC1)
  2206   000da5 cd950d          	CALL	SUBHL
  2207   000da8 d0              	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
  2208   000da9 c5              	PUSH	BC
  2209   000daa cdf70c          	CALL	CHECKSUM	;else compute checksum.
  2210   000dad 2abd15          	LD	HL,(CHKVECT)	;get address of checksum table.
  2211   000db0 eb              	EX	DE,HL
  2212   000db1 2aec15          	LD	HL,(CKSUMTBL)
  2213   000db4 19              	ADD	HL,DE		;set (HL) to point to byte for this drive.
  2214   000db5 c1              	POP	BC
  2215   000db6 0c              	INC	C		;set or check ?
  2216   000db7 cac40d          	JP	Z,CHKDIR1
  2217   000dba be              	CP	(HL)		;check them.
  2218   000dbb c8              	RET	Z		;return if they are the same.
  2219   000dbc cd7f0d          	CALL	MOREFLS		;not the same, do we care?
  2220   000dbf d0              	RET	NC
  2221   000dc0 cd2c0d          	CALL	WRTPRTD		;yes, mark this as write protected.
  2222   000dc3 c9              	RET
  2223   000dc4 77              CHKDIR1:LD	(HL),A		;just set the byte.
  2224   000dc5 c9              	RET
  2225                          ;
  2226                          ;   Do a write to the directory of the current disk.
  2227                          ;
  2228   000dc6 cd9c0d          DIRWRITE: CALL	SETDIR		;set checksum byte.
  2229   000dc9 cde00d          	CALL	DIRDMA		;set directory dma address.
  2230   000dcc 0e01            	LD	C,1		;tell the bios to actually write.
  2231   000dce cdb80b          	CALL	DOWRITE		;then do the write.
  2232   000dd1 c3da0d          	JP	DEFDMA
  2233                          ;
  2234                          ;   Read from the directory.
  2235                          ;
  2236   000dd4 cde00d          DIRREAD:CALL	DIRDMA		;set the directory dma address.
  2237   000dd7 cdb20b          	CALL	DOREAD		;and read it.
  2238                          ;
  2239                          ;   Routine to set the dma address to the users choice.
  2240                          ;
  2241   000dda 21b115          DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
  2242   000ddd c3e30d          	JP	DIRDMA1
  2243                          ;
  2244                          ;   Routine to set the dma address for directory work.
  2245                          ;
  2246   000de0 21b915          DIRDMA:	LD	HL,DIRBUF
  2247                          ;
  2248                          ;   Set the dma address. On entry, (HL) points to
  2249                          ; word containing the desired dma address.
  2250                          ;
  2251   000de3 4e              DIRDMA1:LD	C,(HL)
  2252   000de4 23              	INC	HL
  2253   000de5 46              	LD	B,(HL)		;setup (BC) and go to the bios to set it.
  2254   000de6 c324f2          	JP	SETDMA
  2255                          ;
  2256                          ;   Move the directory buffer into user's dma space.
  2257                          ;
  2258   000de9 2ab915          MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
  2259   000dec eb              	EX	DE,HL
  2260   000ded 2ab115          	LD	HL,(USERDMA)	; put it here.
  2261   000df0 0e80            	LD	C,128		;this is its length.
  2262   000df2 c34f0b          	JP	DE2HL		;move it now and return.
  2263                          ;
  2264                          ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
  2265                          ;
  2266   000df5 21ea15          CKFILPOS: LD	HL,FILEPOS
  2267   000df8 7e              	LD	A,(HL)
  2268   000df9 23              	INC	HL
  2269   000dfa be              	CP	(HL)		;are both bytes the same?
  2270   000dfb c0              	RET	NZ
  2271   000dfc 3c              	INC	A		;yes, but are they each 0ffh?
  2272   000dfd c9              	RET
  2273                          ;
  2274                          ;   Set location (FILEPOS) to 0ffffh.
  2275                          ;
  2276   000dfe 21ffff          STFILPOS: LD	HL,0FFFFH
  2277   000e01 22ea15          	LD	(FILEPOS),HL
  2278   000e04 c9              	RET
  2279                          ;
  2280                          ;   Move on to the next file position within the current
  2281                          ; directory buffer. If no more exist, set pointer to 0ffffh
  2282                          ; and the calling routine will check for this. Enter with (C)
  2283                          ; equal to 0ffh to cause the checksum byte to be set, else we
  2284                          ; will check this disk and set write protect if checksums are
  2285                          ; not the same (applies only if another directory sector must
  2286                          ; be read).
  2287                          ;
  2288   000e05 2ac815          NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
  2289   000e08 eb              	EX	DE,HL
  2290   000e09 2aea15          	LD	HL,(FILEPOS)	;get current count.
  2291   000e0c 23              	INC	HL		;go on to the next one.
  2292   000e0d 22ea15          	LD	(FILEPOS),HL
  2293   000e10 cd950d          	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
  2294   000e13 d2190e          	JP	NC,NXENT1	;is there more room left?
  2295   000e16 c3fe0d          	JP	STFILPOS	;no. Set this flag and return.
  2296   000e19 3aea15          NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
  2297   000e1c e603            	AND	03H		;only look within this sector (only 4 entries fit).
  2298   000e1e 0605            	LD	B,5		;convert to relative position (32 bytes each).
  2299   000e20 87              NXENT2:	ADD	A,A		;note that this is not efficient code.
  2300   000e21 05              	DEC	B		;5 'ADD A's would be better.
  2301   000e22 c2200e          	JP	NZ,NXENT2
  2302   000e25 32e915          	LD	(FCBPOS),A	;save it as position of fcb.
  2303   000e28 b7              	OR	A
  2304   000e29 c0              	RET	NZ		;return if we are within buffer.
  2305   000e2a c5              	PUSH	BC
  2306   000e2b cdc30b          	CALL	TRKSEC		;we need the next directory sector.
  2307   000e2e cdd40d          	CALL	DIRREAD
  2308   000e31 c1              	POP	BC
  2309   000e32 c39e0d          	JP	CHECKDIR
  2310                          ;
  2311                          ;   Routine to to get a bit from the disk space allocation
  2312                          ; map. It is returned in (A), bit position 0. On entry to here,
  2313                          ; set (BC) to the block number on the disk to check.
  2314                          ; On return, (D) will contain the original bit position for
  2315                          ; this block number and (HL) will point to the address for it.
  2316                          ;
  2317   000e35 79              CKBITMAP: LD	A,C		;determine bit number of interest.
  2318   000e36 e607            	AND	07H		;compute (D)=(E)=(C and 7)+1.
  2319   000e38 3c              	INC	A
  2320   000e39 5f              	LD	E,A		;save particular bit number.
  2321   000e3a 57              	LD	D,A
  2322                          ;
  2323                          ;   compute (BC)=(BC)/8.
  2324                          ;
  2325   000e3b 79              	LD	A,C
  2326   000e3c 0f              	RRCA			;now shift right 3 bits.
  2327   000e3d 0f              	RRCA
  2328   000e3e 0f              	RRCA
  2329   000e3f e61f            	AND	1FH		;and clear bits 7,6,5.
  2330   000e41 4f              	LD	C,A
  2331   000e42 78              	LD	A,B
  2332   000e43 87              	ADD	A,A		;now shift (B) into bits 7,6,5.
  2333   000e44 87              	ADD	A,A
  2334   000e45 87              	ADD	A,A
  2335   000e46 87              	ADD	A,A
  2336   000e47 87              	ADD	A,A
  2337   000e48 b1              	OR	C		;and add in (C).
  2338   000e49 4f              	LD	C,A		;ok, (C) ha been completed.
  2339   000e4a 78              	LD	A,B		;is there a better way of doing this?
  2340   000e4b 0f              	RRCA
  2341   000e4c 0f              	RRCA
  2342   000e4d 0f              	RRCA
  2343   000e4e e61f            	AND	1FH
  2344   000e50 47              	LD	B,A		;and now (B) is completed.
  2345                          ;
  2346                          ;   use this as an offset into the disk space allocation
  2347                          ; table.
  2348                          ;
  2349   000e51 2abf15          	LD	HL,(ALOCVECT)
  2350   000e54 09              	ADD	HL,BC
  2351   000e55 7e              	LD	A,(HL)		;now get correct byte.
  2352   000e56 07              CKBMAP1:RLCA			;get correct bit into position 0.
  2353   000e57 1d              	DEC	E
  2354   000e58 c2560e          	JP	NZ,CKBMAP1
  2355   000e5b c9              	RET
  2356                          ;
  2357                          ;   Set or clear the bit map such that block number (BC) will be marked
  2358                          ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
  2359                          ; 1 then it will be set (don't use anyother values).
  2360                          ;
  2361   000e5c d5              STBITMAP: PUSH	DE
  2362   000e5d cd350e          	CALL	CKBITMAP	;get the byte of interest.
  2363   000e60 e6fe            	AND	0FEH		;clear the affected bit.
  2364   000e62 c1              	POP	BC
  2365   000e63 b1              	OR	C		;and now set it acording to (C).
  2366                          ;
  2367                          ;  entry to restore the original bit position and then store
  2368                          ; in table. (A) contains the value, (D) contains the bit
  2369                          ; position (1-8), and (HL) points to the address within the
  2370                          ; space allocation table for this byte.
  2371                          ;
  2372   000e64 0f              STBMAP1:RRCA			;restore original bit position.
  2373   000e65 15              	DEC	D
  2374   000e66 c2640e          	JP	NZ,STBMAP1
  2375   000e69 77              	LD	(HL),A		;and stor byte in table.
  2376   000e6a c9              	RET
  2377                          ;
  2378                          ;   Set/clear space used bits in allocation map for this file.
  2379                          ; On entry, (C)=1 to set the map and (C)=0 to clear it.
  2380                          ;
  2381   000e6b cd5e0d          SETFILE:CALL	FCB2HL		;get address of fcb
  2382   000e6e 111000          	LD	DE,16
  2383   000e71 19              	ADD	HL,DE		;get to block number bytes.
  2384   000e72 c5              	PUSH	BC
  2385   000e73 0e11            	LD	C,17		;check all 17 bytes (max) of table.
  2386   000e75 d1              SETFL1:	POP	DE
  2387   000e76 0d              	DEC	C		;done all bytes yet?
  2388   000e77 c8              	RET	Z
  2389   000e78 d5              	PUSH	DE
  2390   000e79 3add15          	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
  2391   000e7c b7              	OR	A
  2392   000e7d ca880e          	JP	Z,SETFL2
  2393   000e80 c5              	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
  2394   000e81 e5              	PUSH	HL
  2395   000e82 4e              	LD	C,(HL)		;get low byte from table, always
  2396   000e83 0600            	LD	B,0		;set high byte to zero.
  2397   000e85 c38e0e          	JP	SETFL3
  2398   000e88 0d              SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
  2399   000e89 c5              	PUSH	BC
  2400   000e8a 4e              	LD	C,(HL)		;now get both the low and high bytes.
  2401   000e8b 23              	INC	HL
  2402   000e8c 46              	LD	B,(HL)
  2403   000e8d e5              	PUSH	HL
  2404   000e8e 79              SETFL3:	LD	A,C		;block used?
  2405   000e8f b0              	OR	B
  2406   000e90 ca9d0e          	JP	Z,SETFL4
  2407   000e93 2ac615          	LD	HL,(DSKSIZE)	;is this block number within the
  2408   000e96 7d              	LD	A,L		;space on the disk?
  2409   000e97 91              	SUB	C
  2410   000e98 7c              	LD	A,H
  2411   000e99 98              	SBC	A,B
  2412   000e9a d45c0e          	CALL	NC,STBITMAP	;yes, set the proper bit.
  2413   000e9d e1              SETFL4:	POP	HL		;point to next block number in fcb.
  2414   000e9e 23              	INC	HL
  2415   000e9f c1              	POP	BC
  2416   000ea0 c3750e          	JP	SETFL1
  2417                          ;
  2418                          ;   Construct the space used allocation bit map for the active
  2419                          ; drive. If a file name starts with '$' and it is under the
  2420                          ; current user number, then (STATUS) is set to minus 1. Otherwise
  2421                          ; it is not set at all.
  2422                          ;
  2423   000ea3 2ac615          BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
  2424   000ea6 0e03            	LD	C,3
  2425   000ea8 cdea0c          	CALL	SHIFTR		;(HL)=(HL)/8.
  2426   000eab 23              	INC	HL		;at lease 1 byte.
  2427   000eac 44              	LD	B,H
  2428   000ead 4d              	LD	C,L		;set (BC) to the allocation table length.
  2429                          ;
  2430                          ;   Initialize the bitmap for this drive. Right now, the first
  2431                          ; two bytes are specified by the disk parameter block. However
  2432                          ; a patch could be entered here if it were necessary to setup
  2433                          ; this table in a special mannor. For example, the bios could
  2434                          ; determine locations of 'bad blocks' and set them as already
  2435                          ; 'used' in the map.
  2436                          ;
  2437   000eae 2abf15          	LD	HL,(ALOCVECT)	;now zero out the table now.
  2438   000eb1 3600            BITMAP1:LD	(HL),0
  2439   000eb3 23              	INC	HL
  2440   000eb4 0b              	DEC	BC
  2441   000eb5 78              	LD	A,B
  2442   000eb6 b1              	OR	C
  2443   000eb7 c2b10e          	JP	NZ,BITMAP1
  2444   000eba 2aca15          	LD	HL,(ALLOC0)	;get initial space used by directory.
  2445   000ebd eb              	EX	DE,HL
  2446   000ebe 2abf15          	LD	HL,(ALOCVECT)	;and put this into map.
  2447   000ec1 73              	LD	(HL),E
  2448   000ec2 23              	INC	HL
  2449   000ec3 72              	LD	(HL),D
  2450                          ;
  2451                          ;   End of initialization portion.
  2452                          ;
  2453   000ec4 cda10b          	CALL	HOMEDRV		;now home the drive.
  2454   000ec7 2ab315          	LD	HL,(SCRATCH1)
  2455   000eca 3603            	LD	(HL),3		;force next directory request to read
  2456   000ecc 23              	INC	HL		;in a sector.
  2457   000ecd 3600            	LD	(HL),0
  2458   000ecf cdfe0d          	CALL	STFILPOS	;clear initial file position also.
  2459   000ed2 0eff            BITMAP2:LD	C,0FFH		;read next file name in directory
  2460   000ed4 cd050e          	CALL	NXENTRY		;and set checksum byte.
  2461   000ed7 cdf50d          	CALL	CKFILPOS	;is there another file?
  2462   000eda c8              	RET	Z
  2463   000edb cd5e0d          	CALL	FCB2HL		;yes, get its address.
  2464   000ede 3ee5            	LD	A,0E5H
  2465   000ee0 be              	CP	(HL)		;empty file entry?
  2466   000ee1 cad20e          	JP	Z,BITMAP2
  2467   000ee4 3a410b          	LD	A,(USERNO)	;no, correct user number?
  2468   000ee7 be              	CP	(HL)
  2469   000ee8 c2f60e          	JP	NZ,BITMAP3
  2470   000eeb 23              	INC	HL
  2471   000eec 7e              	LD	A,(HL)		;yes, does name start with a '$'?
  2472   000eed d624            	SUB	'$'
  2473   000eef c2f60e          	JP	NZ,BITMAP3
  2474   000ef2 3d              	DEC	A		;yes, set atatus to minus one.
  2475   000ef3 32450b          	LD	(STATUS),A
  2476   000ef6 0e01            BITMAP3:LD	C,1		;now set this file's space as used in bit map.
  2477   000ef8 cd6b0e          	CALL	SETFILE
  2478   000efb cd8c0d          	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
  2479   000efe c3d20e          	JP	BITMAP2
  2480                          ;
  2481                          ;   Set the status (STATUS) and return.
  2482                          ;
  2483   000f01 3ad415          STSTATUS: LD	A,(FNDSTAT)
  2484   000f04 c3010b          	JP	SETSTAT
  2485                          ;
  2486                          ;   Check extents in (A) and (C). Set the zero flag if they
  2487                          ; are the same. The number of 16k chunks of disk space that
  2488                          ; the directory extent covers is expressad is (EXTMASK+1).
  2489                          ; No registers are modified.
  2490                          ;
  2491   000f07 c5              SAMEXT:	PUSH	BC
  2492   000f08 f5              	PUSH	AF
  2493   000f09 3ac515          	LD	A,(EXTMASK)	;get extent mask and use it to
  2494   000f0c 2f              	CPL			;to compare both extent numbers.
  2495   000f0d 47              	LD	B,A		;save resulting mask here.
  2496   000f0e 79              	LD	A,C		;mask first extent and save in (C).
  2497   000f0f a0              	AND	B
  2498   000f10 4f              	LD	C,A
  2499   000f11 f1              	POP	AF		;now mask second extent and compare
  2500   000f12 a0              	AND	B		;with the first one.
  2501   000f13 91              	SUB	C
  2502   000f14 e61f            	AND	1FH		;(* only check buts 0-4 *)
  2503   000f16 c1              	POP	BC		;the zero flag is set if they are the same.
  2504   000f17 c9              	RET			;restore (BC) and return.
  2505                          ;
  2506                          ;   Search for the first occurence of a file name. On entry,
  2507                          ; register (C) should contain the number of bytes of the fcb
  2508                          ; that must match.
  2509                          ;
  2510   000f18 3eff            FINDFST:LD	A,0FFH
  2511   000f1a 32d415          	LD	(FNDSTAT),A
  2512   000f1d 21d815          	LD	HL,COUNTER	;save character count.
  2513   000f20 71              	LD	(HL),C
  2514   000f21 2a430b          	LD	HL,(PARAMS)	;get filename to match.
  2515   000f24 22d915          	LD	(SAVEFCB),HL	;and save.
  2516   000f27 cdfe0d          	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
  2517   000f2a cda10b          	CALL	HOMEDRV		;home the drive.
  2518                          ;
  2519                          ;   Entry to locate the next occurence of a filename within the
  2520                          ; directory. The disk is not expected to have been changed. If
  2521                          ; it was, then it will be write protected.
  2522                          ;
  2523   000f2d 0e00            FINDNXT:LD	C,0		;write protect the disk if changed.
  2524   000f2f cd050e          	CALL	NXENTRY		;get next filename entry in directory.
  2525   000f32 cdf50d          	CALL	CKFILPOS	;is file position = 0ffffh?
  2526   000f35 ca940f          	JP	Z,FNDNXT6	;yes, exit now then.
  2527   000f38 2ad915          	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
  2528   000f3b eb              	EX	DE,HL
  2529   000f3c 1a              	LD	A,(DE)
  2530   000f3d fee5            	CP	0E5H		;empty directory entry?
  2531   000f3f ca4a0f          	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
  2532   000f42 d5              	PUSH	DE
  2533   000f43 cd7f0d          	CALL	MOREFLS		;more files in directory?
  2534   000f46 d1              	POP	DE
  2535   000f47 d2940f          	JP	NC,FNDNXT6	;no more. Exit now.
  2536   000f4a cd5e0d          FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
  2537   000f4d 3ad815          	LD	A,(COUNTER)	;get number of bytes (characters) to check.
  2538   000f50 4f              	LD	C,A
  2539   000f51 0600            	LD	B,0		;initialize byte position counter.
  2540   000f53 79              FNDNXT2:LD	A,C		;are we done with the compare?
  2541   000f54 b7              	OR	A
  2542   000f55 ca830f          	JP	Z,FNDNXT5
  2543   000f58 1a              	LD	A,(DE)		;no, check next byte.
  2544   000f59 fe3f            	CP	'?'		;don't care about this character?
  2545   000f5b ca7c0f          	JP	Z,FNDNXT4
  2546   000f5e 78              	LD	A,B		;get bytes position in fcb.
  2547   000f5f fe0d            	CP	13		;don't care about the thirteenth byte either.
  2548   000f61 ca7c0f          	JP	Z,FNDNXT4
  2549   000f64 fe0c            	CP	12		;extent byte?
  2550   000f66 1a              	LD	A,(DE)
  2551   000f67 ca730f          	JP	Z,FNDNXT3
  2552   000f6a 96              	SUB	(HL)		;otherwise compare characters.
  2553   000f6b e67f            	AND	7FH
  2554   000f6d c22d0f          	JP	NZ,FINDNXT	;not the same, check next entry.
  2555   000f70 c37c0f          	JP	FNDNXT4		;so far so good, keep checking.
  2556   000f73 c5              FNDNXT3:PUSH	BC		;check the extent byte here.
  2557   000f74 4e              	LD	C,(HL)
  2558   000f75 cd070f          	CALL	SAMEXT
  2559   000f78 c1              	POP	BC
  2560   000f79 c22d0f          	JP	NZ,FINDNXT	;not the same, look some more.
  2561                          ;
  2562                          ;   So far the names compare. Bump pointers to the next byte
  2563                          ; and continue until all (C) characters have been checked.
  2564                          ;
  2565   000f7c 13              FNDNXT4:INC	DE		;bump pointers.
  2566   000f7d 23              	INC	HL
  2567   000f7e 04              	INC	B
  2568   000f7f 0d              	DEC	C		;adjust character counter.
  2569   000f80 c3530f          	JP	FNDNXT2
  2570   000f83 3aea15          FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
  2571   000f86 e603            	AND	03H
  2572   000f88 32450b          	LD	(STATUS),A
  2573   000f8b 21d415          	LD	HL,FNDSTAT
  2574   000f8e 7e              	LD	A,(HL)
  2575   000f8f 17              	RLA
  2576   000f90 d0              	RET	NC
  2577   000f91 af              	XOR	A
  2578   000f92 77              	LD	(HL),A
  2579   000f93 c9              	RET
  2580                          ;
  2581                          ;   Filename was not found. Set appropriate status.
  2582                          ;
  2583   000f94 cdfe0d          FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
  2584   000f97 3eff            	LD	A,0FFH		;say not located.
  2585   000f99 c3010b          	JP	SETSTAT
  2586                          ;
  2587                          ;   Erase files from the directory. Only the first byte of the
  2588                          ; fcb will be affected. It is set to (E5).
  2589                          ;
  2590   000f9c cd540d          ERAFILE:CALL	CHKWPRT		;is disk write protected?
  2591   000f9f 0e0c            	LD	C,12		;only compare file names.
  2592   000fa1 cd180f          	CALL	FINDFST		;get first file name.
  2593   000fa4 cdf50d          ERAFIL1:CALL	CKFILPOS	;any found?
  2594   000fa7 c8              	RET	Z		;nope, we must be done.
  2595   000fa8 cd440d          	CALL	CHKROFL		;is file read only?
  2596   000fab cd5e0d          	CALL	FCB2HL		;nope, get address of fcb and
  2597   000fae 36e5            	LD	(HL),0E5H	;set first byte to 'empty'.
  2598   000fb0 0e00            	LD	C,0		;clear the space from the bit map.
  2599   000fb2 cd6b0e          	CALL	SETFILE
  2600   000fb5 cdc60d          	CALL	DIRWRITE	;now write the directory sector back out.
  2601   000fb8 cd2d0f          	CALL	FINDNXT		;find the next file name.
  2602   000fbb c3a40f          	JP	ERAFIL1		;and repeat process.
  2603                          ;
  2604                          ;   Look through the space allocation map (bit map) for the
  2605                          ; next available block. Start searching at block number (BC-1).
  2606                          ; The search procedure is to look for an empty block that is
  2607                          ; before the starting block. If not empty, look at a later
  2608                          ; block number. In this way, we return the closest empty block
  2609                          ; on either side of the 'target' block number. This will speed
  2610                          ; access on random devices. For serial devices, this should be
  2611                          ; changed to look in the forward direction first and then start
  2612                          ; at the front and search some more.
  2613                          ;
  2614                          ;   On return, (DE)= block number that is empty and (HL) =0
  2615                          ; if no empry block was found.
  2616                          ;
  2617   000fbe 50              FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
  2618   000fbf 59              	LD	E,C
  2619                          ;
  2620                          ;   Look before target block. Registers (BC) are used as the lower
  2621                          ; pointer and (DE) as the upper pointer.
  2622                          ;
  2623   000fc0 79              FNDSPA1:LD	A,C		;is block 0 specified?
  2624   000fc1 b0              	OR	B
  2625   000fc2 cad10f          	JP	Z,FNDSPA2
  2626   000fc5 0b              	DEC	BC		;nope, check previous block.
  2627   000fc6 d5              	PUSH	DE
  2628   000fc7 c5              	PUSH	BC
  2629   000fc8 cd350e          	CALL	CKBITMAP
  2630   000fcb 1f              	RRA			;is this block empty?
  2631   000fcc d2ec0f          	JP	NC,FNDSPA3	;yes. use this.
  2632                          ;
  2633                          ;   Note that the above logic gets the first block that it finds
  2634                          ; that is empty. Thus a file could be written 'backward' making
  2635                          ; it very slow to access. This could be changed to look for the
  2636                          ; first empty block and then continue until the start of this
  2637                          ; empty space is located and then used that starting block.
  2638                          ; This should help speed up access to some files especially on
  2639                          ; a well used disk with lots of fairly small 'holes'.
  2640                          ;
  2641   000fcf c1              	POP	BC		;nope, check some more.
  2642   000fd0 d1              	POP	DE
  2643                          ;
  2644                          ;   Now look after target block.
  2645                          ;
  2646   000fd1 2ac615          FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
  2647   000fd4 7b              	LD	A,E
  2648   000fd5 95              	SUB	L
  2649   000fd6 7a              	LD	A,D
  2650   000fd7 9c              	SBC	A,H
  2651   000fd8 d2f40f          	JP	NC,FNDSPA4
  2652   000fdb 13              	INC	DE		;yes, move on to next one.
  2653   000fdc c5              	PUSH	BC
  2654   000fdd d5              	PUSH	DE
  2655   000fde 42              	LD	B,D
  2656   000fdf 4b              	LD	C,E
  2657   000fe0 cd350e          	CALL	CKBITMAP	;check it.
  2658   000fe3 1f              	RRA			;empty?
  2659   000fe4 d2ec0f          	JP	NC,FNDSPA3
  2660   000fe7 d1              	POP	DE		;nope, continue searching.
  2661   000fe8 c1              	POP	BC
  2662   000fe9 c3c00f          	JP	FNDSPA1
  2663                          ;
  2664                          ;   Empty block found. Set it as used and return with (HL)
  2665                          ; pointing to it (true?).
  2666                          ;
  2667   000fec 17              FNDSPA3:RLA			;reset byte.
  2668   000fed 3c              	INC	A		;and set bit 0.
  2669   000fee cd640e          	CALL	STBMAP1		;update bit map.
  2670   000ff1 e1              	POP	HL		;set return registers.
  2671   000ff2 d1              	POP	DE
  2672   000ff3 c9              	RET
  2673                          ;
  2674                          ;   Free block was not found. If (BC) is not zero, then we have
  2675                          ; not checked all of the disk space.
  2676                          ;
  2677   000ff4 79              FNDSPA4:LD	A,C
  2678   000ff5 b0              	OR	B
  2679   000ff6 c2c00f          	JP	NZ,FNDSPA1
  2680   000ff9 210000          	LD	HL,0		;set 'not found' status.
  2681   000ffc c9              	RET
  2682                          ;
  2683                          ;   Move a complete fcb entry into the directory and write it.
  2684                          ;
  2685   000ffd 0e00            FCBSET:	LD	C,0
  2686   000fff 1e20            	LD	E,32		;length of each entry.
  2687                          ;
  2688                          ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
  2689                          ; fcb in directory starting at relative byte (C). This updated
  2690                          ; directory buffer is then written to the disk.
  2691                          ;
  2692   001001 d5              UPDATE:	PUSH	DE
  2693   001002 0600            	LD	B,0		;set (BC) to relative byte position.
  2694   001004 2a430b          	LD	HL,(PARAMS)	;get address of fcb.
  2695   001007 09              	ADD	HL,BC		;compute starting byte.
  2696   001008 eb              	EX	DE,HL
  2697   001009 cd5e0d          	CALL	FCB2HL		;get address of fcb to update in directory.
  2698   00100c c1              	POP	BC		;set (C) to number of bytes to change.
  2699   00100d cd4f0b          	CALL	DE2HL
  2700   001010 cdc30b          UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
  2701   001013 c3c60d          	JP	DIRWRITE	;then write this sector out.
  2702                          ;
  2703                          ;   Routine to change the name of all files on the disk with a
  2704                          ; specified name. The fcb contains the current name as the
  2705                          ; first 12 characters and the new name 16 bytes into the fcb.
  2706                          ;
  2707   001016 cd540d          CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
  2708   001019 0e0c            	LD	C,12		;match first 12 bytes of fcb only.
  2709   00101b cd180f          	CALL	FINDFST		;get first name.
  2710   00101e 2a430b          	LD	HL,(PARAMS)	;get address of fcb.
  2711   001021 7e              	LD	A,(HL)		;get user number.
  2712   001022 111000          	LD	DE,16		;move over to desired name.
  2713   001025 19              	ADD	HL,DE
  2714   001026 77              	LD	(HL),A		;keep same user number.
  2715   001027 cdf50d          CHGNAM1:CALL	CKFILPOS	;any matching file found?
  2716   00102a c8              	RET	Z		;no, we must be done.
  2717   00102b cd440d          	CALL	CHKROFL		;check for read only file.
  2718   00102e 0e10            	LD	C,16		;start 16 bytes into fcb.
  2719   001030 1e0c            	LD	E,12		;and update the first 12 bytes of directory.
  2720   001032 cd0110          	CALL	UPDATE
  2721   001035 cd2d0f          	CALL	FINDNXT		;get te next file name.
  2722   001038 c32710          	JP	CHGNAM1		;and continue.
  2723                          ;
  2724                          ;   Update a files attributes. The procedure is to search for
  2725                          ; every file with the same name as shown in fcb (ignoring bit 7)
  2726                          ; and then to update it (which includes bit 7). No other changes
  2727                          ; are made.
  2728                          ;
  2729   00103b 0e0c            SAVEATTR: LD	C,12		;match first 12 bytes.
  2730   00103d cd180f          	CALL	FINDFST		;look for first filename.
  2731   001040 cdf50d          SAVATR1:CALL	CKFILPOS	;was one found?
  2732   001043 c8              	RET	Z		;nope, we must be done.
  2733   001044 0e00            	LD	C,0		;yes, update the first 12 bytes now.
  2734   001046 1e0c            	LD	E,12
  2735   001048 cd0110          	CALL	UPDATE		;update filename and write directory.
  2736   00104b cd2d0f          	CALL	FINDNXT		;and get the next file.
  2737   00104e c34010          	JP	SAVATR1		;then continue until done.
  2738                          ;
  2739                          ;  Open a file (name specified in fcb).
  2740                          ;
  2741   001051 0e0f            OPENIT:	LD	C,15		;compare the first 15 bytes.
  2742   001053 cd180f          	CALL	FINDFST		;get the first one in directory.
  2743   001056 cdf50d          	CALL	CKFILPOS	;any at all?
  2744   001059 c8              	RET	Z
  2745   00105a cda60c          OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
  2746   00105d 7e              	LD	A,(HL)		;and get it.
  2747   00105e f5              	PUSH	AF		;save it and address.
  2748   00105f e5              	PUSH	HL
  2749   001060 cd5e0d          	CALL	FCB2HL		;point to fcb in directory.
  2750   001063 eb              	EX	DE,HL
  2751   001064 2a430b          	LD	HL,(PARAMS)	;this is the users copy.
  2752   001067 0e20            	LD	C,32		;move it into users space.
  2753   001069 d5              	PUSH	DE
  2754   00106a cd4f0b          	CALL	DE2HL
  2755   00106d cd780d          	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
  2756   001070 d1              	POP	DE		;now get the extent byte from this fcb.
  2757   001071 210c00          	LD	HL,12
  2758   001074 19              	ADD	HL,DE
  2759   001075 4e              	LD	C,(HL)		;into (C).
  2760   001076 210f00          	LD	HL,15		;now get the record count byte into (B).
  2761   001079 19              	ADD	HL,DE
  2762   00107a 46              	LD	B,(HL)
  2763   00107b e1              	POP	HL		;keep the same extent as the user had originally.
  2764   00107c f1              	POP	AF
  2765   00107d 77              	LD	(HL),A
  2766   00107e 79              	LD	A,C		;is it the same as in the directory fcb?
  2767   00107f be              	CP	(HL)
  2768   001080 78              	LD	A,B		;if yes, then use the same record count.
  2769   001081 ca8b10          	JP	Z,OPENIT2
  2770   001084 3e00            	LD	A,0		;if the user specified an extent greater than
  2771   001086 da8b10          	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
  2772   001089 3e80            	LD	A,128		;otherwise set to maximum.
  2773   00108b 2a430b          OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
  2774   00108e 110f00          	LD	DE,15
  2775   001091 19              	ADD	HL,DE		;compute relative position.
  2776   001092 77              	LD	(HL),A		;and set the record count.
  2777   001093 c9              	RET
  2778                          ;
  2779                          ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
  2780                          ; point to a zero value (16 bit).
  2781                          ;   Return with zero flag set it (DE) was moved. Registers (DE)
  2782                          ; and (HL) are not changed. However (A) is.
  2783                          ;
  2784   001094 7e              MOVEWORD: LD	A,(HL)		;check for a zero word.
  2785   001095 23              	INC	HL
  2786   001096 b6              	OR	(HL)		;both bytes zero?
  2787   001097 2b              	DEC	HL
  2788   001098 c0              	RET	NZ		;nope, just return.
  2789   001099 1a              	LD	A,(DE)		;yes, move two bytes from (DE) into
  2790   00109a 77              	LD	(HL),A		;this zero space.
  2791   00109b 13              	INC	DE
  2792   00109c 23              	INC	HL
  2793   00109d 1a              	LD	A,(DE)
  2794   00109e 77              	LD	(HL),A
  2795   00109f 1b              	DEC	DE		;don't disturb these registers.
  2796   0010a0 2b              	DEC	HL
  2797   0010a1 c9              	RET
  2798                          ;
  2799                          ;   Get here to close a file specified by (fcb).
  2800                          ;
  2801   0010a2 af              CLOSEIT:XOR	A		;clear status and file position bytes.
  2802   0010a3 32450b          	LD	(STATUS),A
  2803   0010a6 32ea15          	LD	(FILEPOS),A
  2804   0010a9 32eb15          	LD	(FILEPOS+1),A
  2805   0010ac cd1e0d          	CALL	GETWPRT		;get write protect bit for this drive.
  2806   0010af c0              	RET	NZ		;just return if it is set.
  2807   0010b0 cd690d          	CALL	GETS2		;else get the 's2' byte.
  2808   0010b3 e680            	AND	80H		;and look at bit 7 (file unmodified?).
  2809   0010b5 c0              	RET	NZ		;just return if set.
  2810   0010b6 0e0f            	LD	C,15		;else look up this file in directory.
  2811   0010b8 cd180f          	CALL	FINDFST
  2812   0010bb cdf50d          	CALL	CKFILPOS	;was it found?
  2813   0010be c8              	RET	Z		;just return if not.
  2814   0010bf 011000          	LD	BC,16		;set (HL) pointing to records used section.
  2815   0010c2 cd5e0d          	CALL	FCB2HL
  2816   0010c5 09              	ADD	HL,BC
  2817   0010c6 eb              	EX	DE,HL
  2818   0010c7 2a430b          	LD	HL,(PARAMS)	;do the same for users specified fcb.
  2819   0010ca 09              	ADD	HL,BC
  2820   0010cb 0e10            	LD	C,16		;this many bytes are present in this extent.
  2821   0010cd 3add15          CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
  2822   0010d0 b7              	OR	A
  2823   0010d1 cae810          	JP	Z,CLOSEIT4
  2824   0010d4 7e              	LD	A,(HL)		;just 8 bit. Get one from users fcb.
  2825   0010d5 b7              	OR	A
  2826   0010d6 1a              	LD	A,(DE)		;now get one from directory fcb.
  2827   0010d7 c2db10          	JP	NZ,CLOSEIT2
  2828   0010da 77              	LD	(HL),A		;users byte was zero. Update from directory.
  2829   0010db b7              CLOSEIT2: OR	A
  2830   0010dc c2e110          	JP	NZ,CLOSEIT3
  2831   0010df 7e              	LD	A,(HL)		;directories byte was zero, update from users fcb.
  2832   0010e0 12              	LD	(DE),A
  2833   0010e1 be              CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
  2834   0010e2 c21f11          	JP	NZ,CLOSEIT7	;then close error if they are not the same.
  2835   0010e5 c3fd10          	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
  2836   0010e8 cd9410          CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
  2837   0010eb eb              	EX	DE,HL
  2838   0010ec cd9410          	CALL	MOVEWORD	;update directories fcb if it is zero.
  2839   0010ef eb              	EX	DE,HL
  2840   0010f0 1a              	LD	A,(DE)		;if these two values are no different,
  2841   0010f1 be              	CP	(HL)		;then a close error occured.
  2842   0010f2 c21f11          	JP	NZ,CLOSEIT7
  2843   0010f5 13              	INC	DE		;check second byte.
  2844   0010f6 23              	INC	HL
  2845   0010f7 1a              	LD	A,(DE)
  2846   0010f8 be              	CP	(HL)
  2847   0010f9 c21f11          	JP	NZ,CLOSEIT7
  2848   0010fc 0d              	DEC	C		;remember 16 bit values.
  2849   0010fd 13              CLOSEIT5: INC	DE		;bump to next item in table.
  2850   0010fe 23              	INC	HL
  2851   0010ff 0d              	DEC	C		;there are 16 entries only.
  2852   001100 c2cd10          	JP	NZ,CLOSEIT1	;continue if more to do.
  2853   001103 01ecff          	LD	BC,0FFECH	;backup 20 places (extent byte).
  2854   001106 09              	ADD	HL,BC
  2855   001107 eb              	EX	DE,HL
  2856   001108 09              	ADD	HL,BC
  2857   001109 1a              	LD	A,(DE)
  2858   00110a be              	CP	(HL)		;directory's extent already greater than the
  2859   00110b da1711          	JP	C,CLOSEIT6	;users extent?
  2860   00110e 77              	LD	(HL),A		;no, update directory extent.
  2861   00110f 010300          	LD	BC,3		;and update the record count byte in
  2862   001112 09              	ADD	HL,BC		;directories fcb.
  2863   001113 eb              	EX	DE,HL
  2864   001114 09              	ADD	HL,BC
  2865   001115 7e              	LD	A,(HL)		;get from user.
  2866   001116 12              	LD	(DE),A		;and put in directory.
  2867   001117 3eff            CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
  2868   001119 32d215          	LD	(CLOSEFLG),A
  2869   00111c c31010          	JP	UPDATE1		;update the directory now.
  2870   00111f 21450b          CLOSEIT7: LD	HL,STATUS	;set return status and then return.
  2871   001122 35              	DEC	(HL)
  2872   001123 c9              	RET
  2873                          ;
  2874                          ;   Routine to get the next empty space in the directory. It
  2875                          ; will then be cleared for use.
  2876                          ;
  2877   001124 cd540d          GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
  2878   001127 2a430b          	LD	HL,(PARAMS)	;save current parameters (fcb).
  2879   00112a e5              	PUSH	HL
  2880   00112b 21ac15          	LD	HL,EMPTYFCB	;use special one for empty space.
  2881   00112e 22430b          	LD	(PARAMS),HL
  2882   001131 0e01            	LD	C,1		;search for first empty spot in directory.
  2883   001133 cd180f          	CALL	FINDFST		;(* only check first byte *)
  2884   001136 cdf50d          	CALL	CKFILPOS	;none?
  2885   001139 e1              	POP	HL
  2886   00113a 22430b          	LD	(PARAMS),HL	;restore original fcb address.
  2887   00113d c8              	RET	Z		;return if no more space.
  2888   00113e eb              	EX	DE,HL
  2889   00113f 210f00          	LD	HL,15		;point to number of records for this file.
  2890   001142 19              	ADD	HL,DE
  2891   001143 0e11            	LD	C,17		;and clear all of this space.
  2892   001145 af              	XOR	A
  2893   001146 77              GETMT1:	LD	(HL),A
  2894   001147 23              	INC	HL
  2895   001148 0d              	DEC	C
  2896   001149 c24611          	JP	NZ,GETMT1
  2897   00114c 210d00          	LD	HL,13		;clear the 's1' byte also.
  2898   00114f 19              	ADD	HL,DE
  2899   001150 77              	LD	(HL),A
  2900   001151 cd8c0d          	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
  2901   001154 cdfd0f          	CALL	FCBSET		;write out this fcb entry to directory.
  2902   001157 c3780d          	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
  2903                          ;
  2904                          ;   Routine to close the current extent and open the next one
  2905                          ; for reading.
  2906                          ;
  2907   00115a af              GETNEXT:XOR	A
  2908   00115b 32d215          	LD	(CLOSEFLG),A	;clear close flag.
  2909   00115e cda210          	CALL	CLOSEIT		;close this extent.
  2910   001161 cdf50d          	CALL	CKFILPOS
  2911   001164 c8              	RET	Z		;not there???
  2912   001165 2a430b          	LD	HL,(PARAMS)	;get extent byte.
  2913   001168 010c00          	LD	BC,12
  2914   00116b 09              	ADD	HL,BC
  2915   00116c 7e              	LD	A,(HL)		;and increment it.
  2916   00116d 3c              	INC	A
  2917   00116e e61f            	AND	1FH		;keep within range 0-31.
  2918   001170 77              	LD	(HL),A
  2919   001171 ca8311          	JP	Z,GTNEXT1	;overflow?
  2920   001174 47              	LD	B,A		;mask extent byte.
  2921   001175 3ac515          	LD	A,(EXTMASK)
  2922   001178 a0              	AND	B
  2923   001179 21d215          	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
  2924   00117c a6              	AND	(HL)
  2925   00117d ca8e11          	JP	Z,GTNEXT2	;if zero, we must read in next extent.
  2926   001180 c3ac11          	JP	GTNEXT3		;else, it is already in memory.
  2927   001183 010200          GTNEXT1:LD	BC,2		;Point to the 's2' byte.
  2928   001186 09              	ADD	HL,BC
  2929   001187 34              	INC	(HL)		;and bump it.
  2930   001188 7e              	LD	A,(HL)		;too many extents?
  2931   001189 e60f            	AND	0FH
  2932   00118b cab611          	JP	Z,GTNEXT5	;yes, set error code.
  2933                          ;
  2934                          ;   Get here to open the next extent.
  2935                          ;
  2936   00118e 0e0f            GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
  2937   001190 cd180f          	CALL	FINDFST		;find the first one.
  2938   001193 cdf50d          	CALL	CKFILPOS	;none available?
  2939   001196 c2ac11          	JP	NZ,GTNEXT3
  2940   001199 3ad315          	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
  2941   00119c 3c              	INC	A		;0ffh means reading (so not possible).
  2942   00119d cab611          	JP	Z,GTNEXT5	;or an error.
  2943   0011a0 cd2411          	CALL	GETEMPTY	;we are writing, get an empty entry.
  2944   0011a3 cdf50d          	CALL	CKFILPOS	;none?
  2945   0011a6 cab611          	JP	Z,GTNEXT5	;error if true.
  2946   0011a9 c3af11          	JP	GTNEXT4		;else we are almost done.
  2947   0011ac cd5a10          GTNEXT3:CALL	OPENIT1		;open this extent.
  2948   0011af cdbb0c          GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
  2949   0011b2 af              	XOR	A		;clear status and return.
  2950   0011b3 c3010b          	JP	SETSTAT
  2951                          ;
  2952                          ;   Error in extending the file. Too many extents were needed
  2953                          ; or not enough space on the disk.
  2954                          ;
  2955   0011b6 cd050b          GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
  2956   0011b9 c3780d          	JP	SETS2B7		;so this is not written on a close.
  2957                          ;
  2958                          ;   Read a sequential file.
  2959                          ;
  2960   0011bc 3e01            RDSEQ:	LD	A,1		;set sequential access mode.
  2961   0011be 32d515          	LD	(MODE),A
  2962   0011c1 3eff            RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
  2963   0011c3 32d315          	LD	(RDWRTFLG),A
  2964   0011c6 cdbb0c          	CALL	STRDATA		;put rec# and ext# into fcb.
  2965   0011c9 3ae315          	LD	A,(SAVNREC)	;get next record to read.
  2966   0011cc 21e115          	LD	HL,SAVNXT	;get number of records in extent.
  2967   0011cf be              	CP	(HL)		;within this extent?
  2968   0011d0 dae611          	JP	C,RDSEQ2
  2969   0011d3 fe80            	CP	128		;no. Is this extent fully used?
  2970   0011d5 c2fb11          	JP	NZ,RDSEQ3	;no. End-of-file.
  2971   0011d8 cd5a11          	CALL	GETNEXT		;yes, open the next one.
  2972   0011db af              	XOR	A		;reset next record to read.
  2973   0011dc 32e315          	LD	(SAVNREC),A
  2974   0011df 3a450b          	LD	A,(STATUS)	;check on open, successful?
  2975   0011e2 b7              	OR	A
  2976   0011e3 c2fb11          	JP	NZ,RDSEQ3	;no, error.
  2977   0011e6 cd770c          RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
  2978   0011e9 cd840c          	CALL	CHKBLK		;check it. Within bounds?
  2979   0011ec cafb11          	JP	Z,RDSEQ3	;no, error.
  2980   0011ef cd8a0c          	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
  2981   0011f2 cdd10b          	CALL	TRKSEC1		;set the track and sector for this block #.
  2982   0011f5 cdb20b          	CALL	DOREAD		;and read it.
  2983   0011f8 c3d20c          	JP	SETNREC		;and set the next record to be accessed.
  2984                          ;
  2985                          ;   Read error occured. Set status and return.
  2986                          ;
  2987   0011fb c3050b          RDSEQ3:	JP	IOERR1
  2988                          ;
  2989                          ;   Write the next sequential record.
  2990                          ;
  2991   0011fe 3e01            WTSEQ:	LD	A,1		;set sequential access mode.
  2992   001200 32d515          	LD	(MODE),A
  2993   001203 3e00            WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
  2994   001205 32d315          	LD	(RDWRTFLG),A
  2995   001208 cd540d          	CALL	CHKWPRT		;check write protect status.
  2996   00120b 2a430b          	LD	HL,(PARAMS)
  2997   00120e cd470d          	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
  2998   001211 cdbb0c          	CALL	STRDATA		;put updated data into fcb.
  2999   001214 3ae315          	LD	A,(SAVNREC)	;get record number to write.
  3000   001217 fe80            	CP	128		;within range?
  3001   001219 d2050b          	JP	NC,IOERR1	;no, error(?).
  3002   00121c cd770c          	CALL	COMBLK		;compute block number.
  3003   00121f cd840c          	CALL	CHKBLK		;check number.
  3004   001222 0e00            	LD	C,0		;is there one to write to?
  3005   001224 c26e12          	JP	NZ,WTSEQ6	;yes, go do it.
  3006   001227 cd3e0c          	CALL	GETBLOCK	;get next block number within fcb to use.
  3007   00122a 32d715          	LD	(RELBLOCK),A	;and save.
  3008   00122d 010000          	LD	BC,0		;start looking for space from the start
  3009   001230 b7              	OR	A		;if none allocated as yet.
  3010   001231 ca3b12          	JP	Z,WTSEQ2
  3011   001234 4f              	LD	C,A		;extract previous block number from fcb
  3012   001235 0b              	DEC	BC		;so we can be closest to it.
  3013   001236 cd5e0c          	CALL	EXTBLK
  3014   001239 44              	LD	B,H
  3015   00123a 4d              	LD	C,L
  3016   00123b cdbe0f          WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
  3017   00123e 7d              	LD	A,L		;check for a zero number.
  3018   00123f b4              	OR	H
  3019   001240 c24812          	JP	NZ,WTSEQ3
  3020   001243 3e02            	LD	A,2		;no more space?
  3021   001245 c3010b          	JP	SETSTAT
  3022   001248 22e515          WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
  3023   00124b eb              	EX	DE,HL		;put block number into (DE).
  3024   00124c 2a430b          	LD	HL,(PARAMS)	;now we must update the fcb for this
  3025   00124f 011000          	LD	BC,16		;newly allocated block.
  3026   001252 09              	ADD	HL,BC
  3027   001253 3add15          	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
  3028   001256 b7              	OR	A
  3029   001257 3ad715          	LD	A,(RELBLOCK)	;(* update this entry *)
  3030   00125a ca6412          	JP	Z,WTSEQ4	;zero means 16 bit ones.
  3031   00125d cd640d          	CALL	ADDA2HL		;(HL)=(HL)+(A)
  3032   001260 73              	LD	(HL),E		;store new block number.
  3033   001261 c36c12          	JP	WTSEQ5
  3034   001264 4f              WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
  3035   001265 0600            	LD	B,0
  3036   001267 09              	ADD	HL,BC
  3037   001268 09              	ADD	HL,BC
  3038   001269 73              	LD	(HL),E		;stuff block number (DE) there.
  3039   00126a 23              	INC	HL
  3040   00126b 72              	LD	(HL),D
  3041   00126c 0e02            WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
  3042   00126e 3a450b          WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
  3043   001271 b7              	OR	A
  3044   001272 c0              	RET	NZ
  3045   001273 c5              	PUSH	BC		;yes, save write flag for bios (register C).
  3046   001274 cd8a0c          	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
  3047   001277 3ad515          	LD	A,(MODE)	;get access mode flag (1=sequential,
  3048   00127a 3d              	DEC	A		;0=random, 2=special?).
  3049   00127b 3d              	DEC	A
  3050   00127c c2bb12          	JP	NZ,WTSEQ9
  3051                          ;
  3052                          ;   Special random i/o from function #40. Maybe for M/PM, but the
  3053                          ; current block, if it has not been written to, will be zeroed
  3054                          ; out and then written (reason?).
  3055                          ;
  3056   00127f c1              	POP	BC
  3057   001280 c5              	PUSH	BC
  3058   001281 79              	LD	A,C		;get write status flag (2=writing unused space).
  3059   001282 3d              	DEC	A
  3060   001283 3d              	DEC	A
  3061   001284 c2bb12          	JP	NZ,WTSEQ9
  3062   001287 e5              	PUSH	HL
  3063   001288 2ab915          	LD	HL,(DIRBUF)	;zero out the directory buffer.
  3064   00128b 57              	LD	D,A		;note that (A) is zero here.
  3065   00128c 77              WTSEQ7:	LD	(HL),A
  3066   00128d 23              	INC	HL
  3067   00128e 14              	INC	D		;do 128 bytes.
  3068   00128f f28c12          	JP	P,WTSEQ7
  3069   001292 cde00d          	CALL	DIRDMA		;tell the bios the dma address for directory access.
  3070   001295 2ae715          	LD	HL,(LOGSECT)	;get sector that starts current block.
  3071   001298 0e02            	LD	C,2		;set 'writing to unused space' flag.
  3072   00129a 22e515          WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
  3073   00129d c5              	PUSH	BC
  3074   00129e cdd10b          	CALL	TRKSEC1		;determine its track and sector numbers.
  3075   0012a1 c1              	POP	BC
  3076   0012a2 cdb80b          	CALL	DOWRITE		;now write out 128 bytes of zeros.
  3077   0012a5 2ae515          	LD	HL,(BLKNMBR)	;get sector number.
  3078   0012a8 0e00            	LD	C,0		;set normal write flag.
  3079   0012aa 3ac415          	LD	A,(BLKMASK)	;determine if we have written the entire
  3080   0012ad 47              	LD	B,A		;physical block.
  3081   0012ae a5              	AND	L
  3082   0012af b8              	CP	B
  3083   0012b0 23              	INC	HL		;prepare for the next one.
  3084   0012b1 c29a12          	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
  3085   0012b4 e1              	POP	HL		;reset next sector number.
  3086   0012b5 22e515          	LD	(BLKNMBR),HL
  3087   0012b8 cdda0d          	CALL	DEFDMA		;and reset dma address.
  3088                          ;
  3089                          ;   Normal disk write. Set the desired track and sector then
  3090                          ; do the actual write.
  3091                          ;
  3092   0012bb cdd10b          WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
  3093   0012be c1              	POP	BC		;get write status flag.
  3094   0012bf c5              	PUSH	BC
  3095   0012c0 cdb80b          	CALL	DOWRITE		;and write this out.
  3096   0012c3 c1              	POP	BC
  3097   0012c4 3ae315          	LD	A,(SAVNREC)	;get number of records in file.
  3098   0012c7 21e115          	LD	HL,SAVNXT	;get last record written.
  3099   0012ca be              	CP	(HL)
  3100   0012cb dad212          	JP	C,WTSEQ10
  3101   0012ce 77              	LD	(HL),A		;we have to update record count.
  3102   0012cf 34              	INC	(HL)
  3103   0012d0 0e02            	LD	C,2
  3104                          ;
  3105                          ;*   This area has been patched to correct disk update problem
  3106                          ;* when using blocking and de-blocking in the BIOS.
  3107                          ;
  3108   0012d2 00              WTSEQ10:NOP			;was 'dcr c'
  3109   0012d3 00              	NOP			;was 'dcr c'
  3110   0012d4 210000          	LD	HL,0		;was 'jnz wtseq99'
  3111                          ;
  3112                          ; *   End of patch.
  3113                          ;
  3114   0012d7 f5              	PUSH	AF
  3115   0012d8 cd690d          	CALL	GETS2		;set 'extent written to' flag.
  3116   0012db e67f            	AND	7FH		;(* clear bit 7 *)
  3117   0012dd 77              	LD	(HL),A
  3118   0012de f1              	POP	AF		;get record count for this extent.
  3119   0012df fe7f            WTSEQ99:CP	127		;is it full?
  3120   0012e1 c20013          	JP	NZ,WTSEQ12
  3121   0012e4 3ad515          	LD	A,(MODE)	;yes, are we in sequential mode?
  3122   0012e7 fe01            	CP	1
  3123   0012e9 c20013          	JP	NZ,WTSEQ12
  3124   0012ec cdd20c          	CALL	SETNREC		;yes, set next record number.
  3125   0012ef cd5a11          	CALL	GETNEXT		;and get next empty space in directory.
  3126   0012f2 21450b          	LD	HL,STATUS	;ok?
  3127   0012f5 7e              	LD	A,(HL)
  3128   0012f6 b7              	OR	A
  3129   0012f7 c2fe12          	JP	NZ,WTSEQ11
  3130   0012fa 3d              	DEC	A		;yes, set record count to -1.
  3131   0012fb 32e315          	LD	(SAVNREC),A
  3132   0012fe 3600            WTSEQ11:LD	(HL),0		;clear status.
  3133   001300 c3d20c          WTSEQ12:JP	SETNREC		;set next record to access.
  3134                          ;
  3135                          ;   For random i/o, set the fcb for the desired record number
  3136                          ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
  3137                          ; used as follows:
  3138                          ;
  3139                          ;       fcb+35            fcb+34            fcb+33
  3140                          ;  |     'r-2'      |      'r-1'      |      'r-0'     |
  3141                          ;  |7             0 | 7             0 | 7             0|
  3142                          ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
  3143                          ;  |    overflow   | | extra |  extent   |   record #  |
  3144                          ;  | ______________| |_extent|__number___|_____________|
  3145                          ;                     also 's2'
  3146                          ;
  3147                          ;   On entry, register (C) contains 0ffh if this is a read
  3148                          ; and thus we can not access unwritten disk space. Otherwise,
  3149                          ; another extent will be opened (for writing) if required.
  3150                          ;
  3151   001303 af              POSITION: XOR	A		;set random i/o flag.
  3152   001304 32d515          	LD	(MODE),A
  3153                          ;
  3154                          ;   Special entry (function #40). M/PM ?
  3155                          ;
  3156   001307 c5              POSITN1:PUSH	BC		;save read/write flag.
  3157   001308 2a430b          	LD	HL,(PARAMS)	;get address of fcb.
  3158   00130b eb              	EX	DE,HL
  3159   00130c 212100          	LD	HL,33		;now get byte 'r0'.
  3160   00130f 19              	ADD	HL,DE
  3161   001310 7e              	LD	A,(HL)
  3162   001311 e67f            	AND	7FH		;keep bits 0-6 for the record number to access.
  3163   001313 f5              	PUSH	AF
  3164   001314 7e              	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
  3165   001315 17              	RLA
  3166   001316 23              	INC	HL
  3167   001317 7e              	LD	A,(HL)
  3168   001318 17              	RLA
  3169   001319 e61f            	AND	1FH		;and save this in bits 0-4 of (C).
  3170   00131b 4f              	LD	C,A		;this is the extent byte.
  3171   00131c 7e              	LD	A,(HL)		;now get the extra extent byte.
  3172   00131d 1f              	RRA
  3173   00131e 1f              	RRA
  3174   00131f 1f              	RRA
  3175   001320 1f              	RRA
  3176   001321 e60f            	AND	0FH
  3177   001323 47              	LD	B,A		;and save it in (B).
  3178   001324 f1              	POP	AF		;get record number back to (A).
  3179   001325 23              	INC	HL		;check overflow byte 'r2'.
  3180   001326 6e              	LD	L,(HL)
  3181   001327 2c              	INC	L
  3182   001328 2d              	DEC	L
  3183   001329 2e06            	LD	L,6		;prepare for error.
  3184   00132b c28b13          	JP	NZ,POSITN5	;out of disk space error.
  3185   00132e 212000          	LD	HL,32		;store record number into fcb.
  3186   001331 19              	ADD	HL,DE
  3187   001332 77              	LD	(HL),A
  3188   001333 210c00          	LD	HL,12		;and now check the extent byte.
  3189   001336 19              	ADD	HL,DE
  3190   001337 79              	LD	A,C
  3191   001338 96              	SUB	(HL)		;same extent as before?
  3192   001339 c24713          	JP	NZ,POSITN2
  3193   00133c 210e00          	LD	HL,14		;yes, check extra extent byte 's2' also.
  3194   00133f 19              	ADD	HL,DE
  3195   001340 78              	LD	A,B
  3196   001341 96              	SUB	(HL)
  3197   001342 e67f            	AND	7FH
  3198   001344 ca7f13          	JP	Z,POSITN3	;same, we are almost done then.
  3199                          ;
  3200                          ;  Get here when another extent is required.
  3201                          ;
  3202   001347 c5              POSITN2:PUSH	BC
  3203   001348 d5              	PUSH	DE
  3204   001349 cda210          	CALL	CLOSEIT		;close current extent.
  3205   00134c d1              	POP	DE
  3206   00134d c1              	POP	BC
  3207   00134e 2e03            	LD	L,3		;prepare for error.
  3208   001350 3a450b          	LD	A,(STATUS)
  3209   001353 3c              	INC	A
  3210   001354 ca8413          	JP	Z,POSITN4	;close error.
  3211   001357 210c00          	LD	HL,12		;put desired extent into fcb now.
  3212   00135a 19              	ADD	HL,DE
  3213   00135b 71              	LD	(HL),C
  3214   00135c 210e00          	LD	HL,14		;and store extra extent byte 's2'.
  3215   00135f 19              	ADD	HL,DE
  3216   001360 70              	LD	(HL),B
  3217   001361 cd5110          	CALL	OPENIT		;try and get this extent.
  3218   001364 3a450b          	LD	A,(STATUS)	;was it there?
  3219   001367 3c              	INC	A
  3220   001368 c27f13          	JP	NZ,POSITN3
  3221   00136b c1              	POP	BC		;no. can we create a new one (writing?).
  3222   00136c c5              	PUSH	BC
  3223   00136d 2e04            	LD	L,4		;prepare for error.
  3224   00136f 0c              	INC	C
  3225   001370 ca8413          	JP	Z,POSITN4	;nope, reading unwritten space error.
  3226   001373 cd2411          	CALL	GETEMPTY	;yes we can, try to find space.
  3227   001376 2e05            	LD	L,5		;prepare for error.
  3228   001378 3a450b          	LD	A,(STATUS)
  3229   00137b 3c              	INC	A
  3230   00137c ca8413          	JP	Z,POSITN4	;out of space?
  3231                          ;
  3232                          ;   Normal return location. Clear error code and return.
  3233                          ;
  3234   00137f c1              POSITN3:POP	BC		;restore stack.
  3235   001380 af              	XOR	A		;and clear error code byte.
  3236   001381 c3010b          	JP	SETSTAT
  3237                          ;
  3238                          ;   Error. Set the 's2' byte to indicate this (why?).
  3239                          ;
  3240   001384 e5              POSITN4:PUSH	HL
  3241   001385 cd690d          	CALL	GETS2
  3242   001388 36c0            	LD	(HL),0C0H
  3243   00138a e1              	POP	HL
  3244                          ;
  3245                          ;   Return with error code (presently in L).
  3246                          ;
  3247   00138b c1              POSITN5:POP	BC
  3248   00138c 7d              	LD	A,L		;get error code.
  3249   00138d 32450b          	LD	(STATUS),A
  3250   001390 c3780d          	JP	SETS2B7
  3251                          ;
  3252                          ;   Read a random record.
  3253                          ;
  3254   001393 0eff            READRAN:LD	C,0FFH		;set 'read' status.
  3255   001395 cd0313          	CALL	POSITION	;position the file to proper record.
  3256   001398 ccc111          	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
  3257   00139b c9              	RET
  3258                          ;
  3259                          ;   Write to a random record.
  3260                          ;
  3261   00139c 0e00            WRITERAN: LD	C,0		;set 'writing' flag.
  3262   00139e cd0313          	CALL	POSITION	;position the file to proper record.
  3263   0013a1 cc0312          	CALL	Z,WTSEQ1	;and write as usual (if no errors).
  3264   0013a4 c9              	RET
  3265                          ;
  3266                          ;   Compute the random record number. Enter with (HL) pointing
  3267                          ; to a fcb an (DE) contains a relative location of a record
  3268                          ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
  3269                          ; byte, and (A) the 'r2' byte.
  3270                          ;
  3271                          ;   On return, the zero flag is set if the record is within
  3272                          ; bounds. Otherwise, an overflow occured.
  3273                          ;
  3274   0013a5 eb              COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
  3275   0013a6 19              	ADD	HL,DE		;compute relative position of record #.
  3276   0013a7 4e              	LD	C,(HL)		;get record number into (BC).
  3277   0013a8 0600            	LD	B,0
  3278   0013aa 210c00          	LD	HL,12		;now get extent.
  3279   0013ad 19              	ADD	HL,DE
  3280   0013ae 7e              	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
  3281   0013af 0f              	RRCA			;move lower bit into bit 7.
  3282   0013b0 e680            	AND	80H		;and ignore all other bits.
  3283   0013b2 81              	ADD	A,C		;add to our record number.
  3284   0013b3 4f              	LD	C,A
  3285   0013b4 3e00            	LD	A,0		;take care of any carry.
  3286   0013b6 88              	ADC	A,B
  3287   0013b7 47              	LD	B,A
  3288   0013b8 7e              	LD	A,(HL)		;now get the upper bits of extent into
  3289   0013b9 0f              	RRCA			;bit positions 0-3.
  3290   0013ba e60f            	AND	0FH		;and ignore all others.
  3291   0013bc 80              	ADD	A,B		;add this in to 'r1' byte.
  3292   0013bd 47              	LD	B,A
  3293   0013be 210e00          	LD	HL,14		;get the 's2' byte (extra extent).
  3294   0013c1 19              	ADD	HL,DE
  3295   0013c2 7e              	LD	A,(HL)
  3296   0013c3 87              	ADD	A,A		;and shift it left 4 bits (bits 4-7).
  3297   0013c4 87              	ADD	A,A
  3298   0013c5 87              	ADD	A,A
  3299   0013c6 87              	ADD	A,A
  3300   0013c7 f5              	PUSH	AF		;save carry flag (bit 0 of flag byte).
  3301   0013c8 80              	ADD	A,B		;now add extra extent into 'r1'.
  3302   0013c9 47              	LD	B,A
  3303   0013ca f5              	PUSH	AF		;and save carry (overflow byte 'r2').
  3304   0013cb e1              	POP	HL		;bit 0 of (L) is the overflow indicator.
  3305   0013cc 7d              	LD	A,L
  3306   0013cd e1              	POP	HL		;and same for first carry flag.
  3307   0013ce b5              	OR	L		;either one of these set?
  3308   0013cf e601            	AND	01H		;only check the carry flags.
  3309   0013d1 c9              	RET
  3310                          ;
  3311                          ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
  3312                          ; reflect the last record used for a random (or other) file.
  3313                          ; This reads the directory and looks at all extents computing
  3314                          ; the largerst record number for each and keeping the maximum
  3315                          ; value only. Then 'r0', 'r1', and 'r2' will reflect this
  3316                          ; maximum record number. This is used to compute the space used
  3317                          ; by a random file.
  3318                          ;
  3319   0013d2 0e0c            RANSIZE:LD	C,12		;look thru directory for first entry with
  3320   0013d4 cd180f          	CALL	FINDFST		;this name.
  3321   0013d7 2a430b          	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
  3322   0013da 112100          	LD	DE,33
  3323   0013dd 19              	ADD	HL,DE
  3324   0013de e5              	PUSH	HL
  3325   0013df 72              	LD	(HL),D		;note that (D)=0.
  3326   0013e0 23              	INC	HL
  3327   0013e1 72              	LD	(HL),D
  3328   0013e2 23              	INC	HL
  3329   0013e3 72              	LD	(HL),D
  3330   0013e4 cdf50d          RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
  3331   0013e7 ca0c14          	JP	Z,RANSIZ3	;no, we are done.
  3332   0013ea cd5e0d          	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
  3333   0013ed 110f00          	LD	DE,15		;point to last record in extent.
  3334   0013f0 cda513          	CALL	COMPRAND	;and compute random parameters.
  3335   0013f3 e1              	POP	HL
  3336   0013f4 e5              	PUSH	HL		;now check these values against those
  3337   0013f5 5f              	LD	E,A		;already in fcb.
  3338   0013f6 79              	LD	A,C		;the carry flag will be set if those
  3339   0013f7 96              	SUB	(HL)		;in the fcb represent a larger size than
  3340   0013f8 23              	INC	HL		;this extent does.
  3341   0013f9 78              	LD	A,B
  3342   0013fa 9e              	SBC	A,(HL)
  3343   0013fb 23              	INC	HL
  3344   0013fc 7b              	LD	A,E
  3345   0013fd 9e              	SBC	A,(HL)
  3346   0013fe da0614          	JP	C,RANSIZ2
  3347   001401 73              	LD	(HL),E		;we found a larger (in size) extent.
  3348   001402 2b              	DEC	HL		;stuff these values into fcb.
  3349   001403 70              	LD	(HL),B
  3350   001404 2b              	DEC	HL
  3351   001405 71              	LD	(HL),C
  3352   001406 cd2d0f          RANSIZ2:CALL	FINDNXT		;now get the next extent.
  3353   001409 c3e413          	JP	RANSIZ1		;continue til all done.
  3354   00140c e1              RANSIZ3:POP	HL		;we are done, restore the stack and
  3355   00140d c9              	RET			;return.
  3356                          ;
  3357                          ;   Function to return the random record position of a given
  3358                          ; file which has been read in sequential mode up to now.
  3359                          ;
  3360   00140e 2a430b          SETRAN:	LD	HL,(PARAMS)	;point to fcb.
  3361   001411 112000          	LD	DE,32		;and to last used record.
  3362   001414 cda513          	CALL	COMPRAND	;compute random position.
  3363   001417 212100          	LD	HL,33		;now stuff these values into fcb.
  3364   00141a 19              	ADD	HL,DE
  3365   00141b 71              	LD	(HL),C		;move 'r0'.
  3366   00141c 23              	INC	HL
  3367   00141d 70              	LD	(HL),B		;and 'r1'.
  3368   00141e 23              	INC	HL
  3369   00141f 77              	LD	(HL),A		;and lastly 'r2'.
  3370   001420 c9              	RET
  3371                          ;
  3372                          ;   This routine select the drive specified in (ACTIVE) and
  3373                          ; update the login vector and bitmap table if this drive was
  3374                          ; not already active.
  3375                          ;
  3376   001421 2aaf15          LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
  3377   001424 3a420b          	LD	A,(ACTIVE)	;get the default drive.
  3378   001427 4f              	LD	C,A
  3379   001428 cdea0c          	CALL	SHIFTR		;position active bit for this drive
  3380   00142b e5              	PUSH	HL		;into bit 0.
  3381   00142c eb              	EX	DE,HL
  3382   00142d cd590b          	CALL	SELECT		;select this drive.
  3383   001430 e1              	POP	HL
  3384   001431 cc470b          	CALL	Z,SLCTERR	;valid drive?
  3385   001434 7d              	LD	A,L		;is this a newly activated drive?
  3386   001435 1f              	RRA
  3387   001436 d8              	RET	C
  3388   001437 2aaf15          	LD	HL,(LOGIN)	;yes, update the login vector.
  3389   00143a 4d              	LD	C,L
  3390   00143b 44              	LD	B,H
  3391   00143c cd0b0d          	CALL	SETBIT
  3392   00143f 22af15          	LD	(LOGIN),HL	;and save.
  3393   001442 c3a30e          	JP	BITMAP		;now update the bitmap.
  3394                          ;
  3395                          ;   Function to set the active disk number.
  3396                          ;
  3397   001445 3ad615          SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
  3398   001448 21420b          	LD	HL,ACTIVE	;represents a change in drives.
  3399   00144b be              	CP	(HL)
  3400   00144c c8              	RET	Z
  3401   00144d 77              	LD	(HL),A		;yes it does, log it in.
  3402   00144e c32114          	JP	LOGINDRV
  3403                          ;
  3404                          ;   This is the 'auto disk select' routine. The firsst byte
  3405                          ; of the fcb is examined for a drive specification. If non
  3406                          ; zero then the drive will be selected and loged in.
  3407                          ;
  3408   001451 3eff            AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
  3409   001453 32de15          	LD	(AUTO),A
  3410   001456 2a430b          	LD	HL,(PARAMS)	;get drive specified.
  3411   001459 7e              	LD	A,(HL)
  3412   00145a e61f            	AND	1FH		;look at lower 5 bits.
  3413   00145c 3d              	DEC	A		;adjust for (1=A, 2=B) etc.
  3414   00145d 32d615          	LD	(EPARAM),A	;and save for the select routine.
  3415   001460 fe1e            	CP	1EH		;check for 'no change' condition.
  3416   001462 d27514          	JP	NC,AUTOSL1	;yes, don't change.
  3417   001465 3a420b          	LD	A,(ACTIVE)	;we must change, save currently active
  3418   001468 32df15          	LD	(OLDDRV),A	;drive.
  3419   00146b 7e              	LD	A,(HL)		;and save first byte of fcb also.
  3420   00146c 32e015          	LD	(AUTOFLAG),A	;this must be non-zero.
  3421   00146f e6e0            	AND	0E0H		;whats this for (bits 6,7 are used for
  3422   001471 77              	LD	(HL),A		;something)?
  3423   001472 cd4514          	CALL	SETDSK		;select and log in this drive.
  3424   001475 3a410b          AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
  3425   001478 2a430b          	LD	HL,(PARAMS)	;(* upper half of first byte *)
  3426   00147b b6              	OR	(HL)
  3427   00147c 77              	LD	(HL),A
  3428   00147d c9              	RET			;and return (all done).
  3429                          ;
  3430                          ;   Function to return the current cp/m version number.
  3431                          ;
  3432   00147e 3e22            GETVER:	LD	A,022H		;version 2.2
  3433   001480 c3010b          	JP	SETSTAT
  3434                          ;
  3435                          ;   Function to reset the disk system.
  3436                          ;
  3437   001483 210000          RSTDSK:	LD	HL,0		;clear write protect status and log
  3438   001486 22ad15          	LD	(WRTPRT),HL	;in vector.
  3439   001489 22af15          	LD	(LOGIN),HL
  3440   00148c af              	XOR	A		;select drive 'A'.
  3441   00148d 32420b          	LD	(ACTIVE),A
  3442   001490 218000          	LD	HL,TBUFF	;setup default dma address.
  3443   001493 22b115          	LD	(USERDMA),HL
  3444   001496 cdda0d          	CALL	DEFDMA
  3445   001499 c32114          	JP	LOGINDRV	;now log in drive 'A'.
  3446                          ;
  3447                          ;   Function to open a specified file.
  3448                          ;
  3449   00149c cd720d          OPENFIL:CALL	CLEARS2		;clear 's2' byte.
  3450   00149f cd5114          	CALL	AUTOSEL		;select proper disk.
  3451   0014a2 c35110          	JP	OPENIT		;and open the file.
  3452                          ;
  3453                          ;   Function to close a specified file.
  3454                          ;
  3455   0014a5 cd5114          CLOSEFIL: CALL	AUTOSEL		;select proper disk.
  3456   0014a8 c3a210          	JP	CLOSEIT		;and close the file.
  3457                          ;
  3458                          ;   Function to return the first occurence of a specified file
  3459                          ; name. If the first byte of the fcb is '?' then the name will
  3460                          ; not be checked (get the first entry no matter what).
  3461                          ;
  3462   0014ab 0e00            GETFST:	LD	C,0		;prepare for special search.
  3463   0014ad eb              	EX	DE,HL
  3464   0014ae 7e              	LD	A,(HL)		;is first byte a '?'?
  3465   0014af fe3f            	CP	'?'
  3466   0014b1 cac214          	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
  3467   0014b4 cda60c          	CALL	SETEXT		;get the extension byte from fcb.
  3468   0014b7 7e              	LD	A,(HL)		;is it '?'? if yes, then we want
  3469   0014b8 fe3f            	CP	'?'		;an entry with a specific 's2' byte.
  3470   0014ba c4720d          	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
  3471   0014bd cd5114          	CALL	AUTOSEL		;select proper drive.
  3472   0014c0 0e0f            	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
  3473   0014c2 cd180f          GETFST1:CALL	FINDFST		;find an entry and then move it into
  3474   0014c5 c3e90d          	JP	MOVEDIR		;the users dma space.
  3475                          ;
  3476                          ;   Function to return the next occurence of a file name.
  3477                          ;
  3478   0014c8 2ad915          GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
  3479   0014cb 22430b          	LD	(PARAMS),HL	;other dbos calls are allowed.
  3480   0014ce cd5114          	CALL	AUTOSEL		;no error will be returned, but the
  3481   0014d1 cd2d0f          	CALL	FINDNXT		;results will be wrong.
  3482   0014d4 c3e90d          	JP	MOVEDIR
  3483                          ;
  3484                          ;   Function to delete a file by name.
  3485                          ;
  3486   0014d7 cd5114          DELFILE:CALL	AUTOSEL		;select proper drive.
  3487   0014da cd9c0f          	CALL	ERAFILE		;erase the file.
  3488   0014dd c3010f          	JP	STSTATUS	;set status and return.
  3489                          ;
  3490                          ;   Function to execute a sequential read of the specified
  3491                          ; record number.
  3492                          ;
  3493   0014e0 cd5114          READSEQ:CALL	AUTOSEL		;select proper drive then read.
  3494   0014e3 c3bc11          	JP	RDSEQ
  3495                          ;
  3496                          ;   Function to write the net sequential record.
  3497                          ;
  3498   0014e6 cd5114          WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
  3499   0014e9 c3fe11          	JP	WTSEQ
  3500                          ;
  3501                          ;   Create a file function.
  3502                          ;
  3503   0014ec cd720d          FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
  3504   0014ef cd5114          	CALL	AUTOSEL		;select proper drive and get the next
  3505   0014f2 c32411          	JP	GETEMPTY	;empty directory space.
  3506                          ;
  3507                          ;   Function to rename a file.
  3508                          ;
  3509   0014f5 cd5114          RENFILE:CALL	AUTOSEL		;select proper drive and then switch
  3510   0014f8 cd1610          	CALL	CHGNAMES	;file names.
  3511   0014fb c3010f          	JP	STSTATUS
  3512                          ;
  3513                          ;   Function to return the login vector.
  3514                          ;
  3515   0014fe 2aaf15          GETLOG:	LD	HL,(LOGIN)
  3516   001501 c32915          	JP	GETPRM1
  3517                          ;
  3518                          ;   Function to return the current disk assignment.
  3519                          ;
  3520   001504 3a420b          GETCRNT:LD	A,(ACTIVE)
  3521   001507 c3010b          	JP	SETSTAT
  3522                          ;
  3523                          ;   Function to set the dma address.
  3524                          ;
  3525   00150a eb              PUTDMA:	EX	DE,HL
  3526   00150b 22b115          	LD	(USERDMA),HL	;save in our space and then get to
  3527   00150e c3da0d          	JP	DEFDMA		;the bios with this also.
  3528                          ;
  3529                          ;   Function to return the allocation vector.
  3530                          ;
  3531   001511 2abf15          GETALOC:LD	HL,(ALOCVECT)
  3532   001514 c32915          	JP	GETPRM1
  3533                          ;
  3534                          ;   Function to return the read-only status vector.
  3535                          ;
  3536   001517 2aad15          GETROV:	LD	HL,(WRTPRT)
  3537   00151a c32915          	JP	GETPRM1
  3538                          ;
  3539                          ;   Function to set the file attributes (read-only, system).
  3540                          ;
  3541   00151d cd5114          SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
  3542   001520 cd3b10          	CALL	SAVEATTR
  3543   001523 c3010f          	JP	STSTATUS
  3544                          ;
  3545                          ;   Function to return the address of the disk parameter block
  3546                          ; for the current drive.
  3547                          ;
  3548   001526 2abb15          GETPARM:LD	HL,(DISKPB)
  3549   001529 22450b          GETPRM1:LD	(STATUS),HL
  3550   00152c c9              	RET
  3551                          ;
  3552                          ;   Function to get or set the user number. If (E) was (FF)
  3553                          ; then this is a request to return the current user number.
  3554                          ; Else set the user number from (E).
  3555                          ;
  3556   00152d 3ad615          GETUSER:LD	A,(EPARAM)	;get parameter.
  3557   001530 feff            	CP	0FFH		;get user number?
  3558   001532 c23b15          	JP	NZ,SETUSER
  3559   001535 3a410b          	LD	A,(USERNO)	;yes, just do it.
  3560   001538 c3010b          	JP	SETSTAT
  3561   00153b e61f            SETUSER:AND	1FH		;no, we should set it instead. keep low
  3562   00153d 32410b          	LD	(USERNO),A	;bits (0-4) only.
  3563   001540 c9              	RET
  3564                          ;
  3565                          ;   Function to read a random record from a file.
  3566                          ;
  3567   001541 cd5114          RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
  3568   001544 c39313          	JP	READRAN
  3569                          ;
  3570                          ;   Function to compute the file size for random files.
  3571                          ;
  3572   001547 cd5114          WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
  3573   00154a c39c13          	JP	WRITERAN
  3574                          ;
  3575                          ;   Function to compute the size of a random file.
  3576                          ;
  3577   00154d cd5114          FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
  3578   001550 c3d213          	JP	RANSIZE
  3579                          ;
  3580                          ;   Function #37. This allows a program to log off any drives.
  3581                          ; On entry, set (DE) to contain a word with bits set for those
  3582                          ; drives that are to be logged off. The log-in vector and the
  3583                          ; write protect vector will be updated. This must be a M/PM
  3584                          ; special function.
  3585                          ;
  3586   001553 2a430b          LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
  3587   001556 7d              	LD	A,L		;for each bit that is set, we want
  3588   001557 2f              	CPL			;to clear that bit in (LOGIN)
  3589   001558 5f              	LD	E,A		;and (WRTPRT).
  3590   001559 7c              	LD	A,H
  3591   00155a 2f              	CPL
  3592   00155b 2aaf15          	LD	HL,(LOGIN)	;reset the login vector.
  3593   00155e a4              	AND	H
  3594   00155f 57              	LD	D,A
  3595   001560 7d              	LD	A,L
  3596   001561 a3              	AND	E
  3597   001562 5f              	LD	E,A
  3598   001563 2aad15          	LD	HL,(WRTPRT)
  3599   001566 eb              	EX	DE,HL
  3600   001567 22af15          	LD	(LOGIN),HL	;and save.
  3601   00156a 7d              	LD	A,L		;now do the write protect vector.
  3602   00156b a3              	AND	E
  3603   00156c 6f              	LD	L,A
  3604   00156d 7c              	LD	A,H
  3605   00156e a2              	AND	D
  3606   00156f 67              	LD	H,A
  3607   001570 22ad15          	LD	(WRTPRT),HL	;and save. all done.
  3608   001573 c9              	RET
  3609                          ;
  3610                          ;   Get here to return to the user.
  3611                          ;
  3612   001574 3ade15          GOBACK:	LD	A,(AUTO)	;was auto select activated?
  3613   001577 b7              	OR	A
  3614   001578 ca9115          	JP	Z,GOBACK1
  3615   00157b 2a430b          	LD	HL,(PARAMS)	;yes, but was a change made?
  3616   00157e 3600            	LD	(HL),0		;(* reset first byte of fcb *)
  3617   001580 3ae015          	LD	A,(AUTOFLAG)
  3618   001583 b7              	OR	A
  3619   001584 ca9115          	JP	Z,GOBACK1
  3620   001587 77              	LD	(HL),A		;yes, reset first byte properly.
  3621   001588 3adf15          	LD	A,(OLDDRV)	;and get the old drive and select it.
  3622   00158b 32d615          	LD	(EPARAM),A
  3623   00158e cd4514          	CALL	SETDSK
  3624   001591 2a0f0b          GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
  3625   001594 f9              	LD	SP,HL
  3626   001595 2a450b          	LD	HL,(STATUS)	;get return status.
  3627   001598 7d              	LD	A,L		;force version 1.4 compatability.
  3628   001599 44              	LD	B,H
  3629   00159a c9              	RET			;and go back to user.
  3630                          ;
  3631                          ;   Function #40. This is a special entry to do random i/o.
  3632                          ; For the case where we are writing to unused disk space, this
  3633                          ; space will be zeroed out first. This must be a M/PM special
  3634                          ; purpose function, because why would any normal program even
  3635                          ; care about the previous contents of a sector about to be
  3636                          ; written over.
  3637                          ;
  3638   00159b cd5114          WTSPECL:CALL	AUTOSEL		;select proper drive.
  3639   00159e 3e02            	LD	A,2		;use special write mode.
  3640   0015a0 32d515          	LD	(MODE),A
  3641   0015a3 0e00            	LD	C,0		;set write indicator.
  3642   0015a5 cd0713          	CALL	POSITN1		;position the file.
  3643   0015a8 cc0312          	CALL	Z,WTSEQ1	;and write (if no errors).
  3644   0015ab c9              	RET
  3645                          ;
  3646                          ;**************************************************************
  3647                          ;*
  3648                          ;*     BDOS data storage pool.
  3649                          ;*
  3650                          ;**************************************************************
  3651                          ;
  3652   0015ac e5              EMPTYFCB: DB	0E5H		;empty directory segment indicator.
  3653   0015ad 0000            WRTPRT:	DW	0		;write protect status for all 16 drives.
  3654   0015af 0000            LOGIN:	DW	0		;drive active word (1 bit per drive).
  3655   0015b1 8000            USERDMA:DW	080H		;user's dma address (defaults to 80h).
  3656                          ;
  3657                          ;   Scratch areas from parameter block.
  3658                          ;
  3659   0015b3 0000            SCRATCH1: DW	0		;relative position within dir segment for file (0-3).
  3660   0015b5 0000            SCRATCH2: DW	0		;last selected track number.
  3661   0015b7 0000            SCRATCH3: DW	0		;last selected sector number.
  3662                          ;
  3663                          ;   Disk storage areas from parameter block.
  3664                          ;
  3665   0015b9 0000            DIRBUF:	DW	0		;address of directory buffer to use.
  3666   0015bb 0000            DISKPB:	DW	0		;contains address of disk parameter block.
  3667   0015bd 0000            CHKVECT:DW	0		;address of check vector.
  3668   0015bf 0000            ALOCVECT: DW	0		;address of allocation vector (bit map).
  3669                          ;
  3670                          ;   Parameter block returned from the bios.
  3671                          ;
  3672   0015c1 0000            SECTORS:DW	0		;sectors per track from bios.
  3673   0015c3 00              BLKSHFT:DB	0		;block shift.
  3674   0015c4 00              BLKMASK:DB	0		;block mask.
  3675   0015c5 00              EXTMASK:DB	0		;extent mask.
  3676   0015c6 0000            DSKSIZE:DW	0		;disk size from bios (number of blocks-1).
  3677   0015c8 0000            DIRSIZE:DW	0		;directory size.
  3678   0015ca 0000            ALLOC0:	DW	0		;storage for first bytes of bit map (dir space used).
  3679   0015cc 0000            ALLOC1:	DW	0
  3680   0015ce 0000            OFFSET:	DW	0		;first usable track number.
  3681   0015d0 0000            XLATE:	DW	0		;sector translation table address.
  3682                          ;
  3683                          ;
  3684   0015d2 00              CLOSEFLG: DB	0		;close flag (=0ffh is extent written ok).
  3685   0015d3 00              RDWRTFLG: DB	0		;read/write flag (0ffh=read, 0=write).
  3686   0015d4 00              FNDSTAT:DB	0		;filename found status (0=found first entry).
  3687   0015d5 00              MODE:	DB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
  3688   0015d6 00              EPARAM:	DB	0		;storage for register (E) on entry to bdos.
  3689   0015d7 00              RELBLOCK: DB	0		;relative position within fcb of block number written.
  3690   0015d8 00              COUNTER:DB	0		;byte counter for directory name searches.
  3691   0015d9 00000000        SAVEFCB:DW	0,0		;save space for address of fcb (for directory searches).
  3692   0015dd 00              BIGDISK:DB	0		;if =0 then disk is > 256 blocks long.
  3693   0015de 00              AUTO:	DB	0		;if non-zero, then auto select activated.
  3694   0015df 00              OLDDRV:	DB	0		;on auto select, storage for previous drive.
  3695   0015e0 00              AUTOFLAG: DB	0		;if non-zero, then auto select changed drives.
  3696   0015e1 00              SAVNXT:	DB	0		;storage for next record number to access.
  3697   0015e2 00              SAVEXT:	DB	0		;storage for extent number of file.
  3698   0015e3 0000            SAVNREC:DW	0		;storage for number of records in file.
  3699   0015e5 0000            BLKNMBR:DW	0		;block number (physical sector) used within a file or logical sect
  3700   0015e7 0000            LOGSECT:DW	0		;starting logical (128 byte) sector of block (physical sector).
  3701   0015e9 00              FCBPOS:	DB	0		;relative position within buffer for fcb of file of interest.
  3702   0015ea 0000            FILEPOS:DW	0		;files position within directory (0 to max entries -1).
  3703                          ;
  3704                          ;   Disk directory buffer checksum bytes. One for each of the
  3705                          ; 16 possible drives.
  3706                          ;
  3707   0015ec 0000000000000000CKSUMTBL: DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                0000000000000000
  3708                          ;
  3709                          ;   Extra space ?
  3710                          ;
  3711   0015fc 00000000        	DB	0,0,0,0
  3712                          
  3713   001600 0000000000000000	DS	1024
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
  3714                          ;
  3715                          ;**************************************************************
  3716                          ;*
  3717                          ;*        B I O S   J U M P   T A B L E
  3718                          ;*
  3719                          ;**************************************************************
  3720                          ;
  3721                          BOOT:	equ	BIOS		;NOTE WE USE FAKE DESTINATIONS
  3722                          WBOOT:	equ	BIOS + 3
  3723                          CONST:	equ	BIOS + 6
  3724                          CONIN:	equ	BIOS + 9
  3725                          CONOUT:	equ	BIOS + 12
  3726                          LIST:	equ	BIOS + 15
  3727                          PUNCH:	equ	BIOS + 18
  3728                          READER:	equ	BIOS + 21
  3729                          HOME:	equ	BIOS + 24
  3730                          SELDSK:	equ	BIOS + 27
  3731                          SETTRK:	equ	BIOS + 30
  3732                          SETSEC:	equ	BIOS + 33
  3733                          SETDMA:	equ	BIOS + 36
  3734                          READ:	equ	BIOS + 39
  3735                          WRITE:	equ	BIOS + 42
  3736                          PRSTAT:	equ	BIOS + 45
  3737                          SECTRN:	equ	BIOS + 48
  3738                          ;
  3739                          ;*
  3740                          ;******************   E N D   O F   C P / M   *****************
  3741                          ;*
  3742                          
  3743                          ;	include "cpm22bios.asm"
  3744                          
