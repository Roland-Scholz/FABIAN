z80test.asm:
     1                          		include "mc68681.asm"
mc68681.asm:
     1                          ;--------------------------------------------------------------------------------
     2                          ; equates for MC68681 DUART
     3                          ;
     4                          ; see ./doc/scc68681.pdf
     5                          ;--------------------------------------------------------------------------------
     6                          MODEA		equ	0
     7                          STATA		equ	1
     8                          CLOCKA		equ	1
     9                          COMMA		equ	2
    10                          RECA		equ	3
    11                          TRANSA		equ	3
    12                          IPCHANGE	equ	4
    13                          AUXCTRL		equ	4
    14                          ISR		equ	5
    15                          IMR		equ	5
    16                          CNTMSB		equ	6
    17                          CNTLSB		equ	7
    18                          MODEB		equ	8
    19                          STATB		equ	9
    20                          CLOCKB		equ	9
    21                          COMMB		equ	10
    22                          RECB		equ	11
    23                          TRANSB		equ	11
    24                          IVR		equ	12
    25                          INPORT		equ	13
    26                          OPCTRL		equ	13
    27                          STRTCNT		equ	14
    28                          OPSET		equ	14
    29                          STOPCNT		equ	15
    30                          OPRES		equ	15
    31                          
z80test.asm:
     2                          
     3                          adr0038		equ	038h
     4                          
     5                          
     6                          
     7                          
     8                          ;PS2DATA		equ	IP2
     9                          ;PS2CLK		equ	IP1
    10                          
    11                          CR:		equ	$0d
    12                          
    13                          CCHM		equ	$1C	;move cursor home
    14                          CCBT		equ	$1D	;move cursor to bottom
    15                          CCLM		equ	$1E	;move cursor to left margin
    16                          CCRM		equ	$1F	;move cursor to right margin
    17                          
    18                          				;SUPERF equ 0
    19                          
    20                          CLS		equ	$01	;clear screen
    21                          BACK		equ	$08	;backspace
    22                          LF		equ	$0A	;$9B	;end of line (RETURN)
    23                          ESC		equ	$1B	;escape key
    24                          CCUP		equ	$1C	;cursor up
    25                          CCDN		equ	$1D	;cursor down
    26                          CCLF		equ	$1E	;cursor left
    27                          CCRT		equ	$1F	;cursor right
    28                          CSPACE		equ	$20	;space
    29                          TABU		equ	09	;tabulator
    30                          CILN		equ	$9D	;insert line
    31                          CDCH		equ	$FE	;delete character
    32                          CICH		equ	$FF	;insert character
    33                          
    34                          HELP		equ	$11	;key code for HELP
    35                          CNTLF1		equ	$83	;key code for CTRL-F1
    36                          CNTLF2		equ	$84	;key code for CTRL-F2
    37                          CNTLF3		equ	$93	;key code for CTRL-F3
    38                          CNTLF4		equ	$94	;key code for CTRL-F4
    39                          CNTL1		equ	$9F	;key code for CTRL-1
    40                          
    41                          ;	special key scan-codes
    42                          ALTGR		equ	$11	;extended!
    43                          ALR		equ	$11
    44                          CLSHIFT		equ	$12
    45                          CLSTRG		equ	$14
    46                          CRSHIFT		equ	$59
    47                          CCAPS		equ	$58
    48                          
    49                          FATBUF		equ	$F800
    50                          DATBUF		equ	$FA00
    51                          
    52                          		org	$2000
    53                          
    54   000000 cde503          		call	sdInit
    55   000003 111100          		ld	de, sec2
    56   000006 cdb704          		call	sdReadDat
    57   000009 c9              		ret
    58                          
    59   00000a 111100          		ld	de, sec2
    60   00000d cd4205          		call	sdWriteDat
    61   000010 c9              		ret
    62                          
    63   000011 02000000        sec2:		db	2, 0, 0, 0
    64                          
    65   000015 2100d8          		ld	hl, $d800
    66   000018 110080          		ld	de, $8000
    67   00001b 010016          		ld	BC, $1600
    68   00001e 1a              compare:	ld	a, (de)
    69   00001f be              		cp	(hl)
    70   000020 2008            		jr	NZ, noequal
    71   000022 23              		inc	hl
    72   000023 13              		inc	de
    73   000024 0b              		dec	bc
    74   000025 78              		ld	a, b
    75   000026 b1              		or	c
    76   000027 20f5            		jr	NZ, compare
    77   000029 c9              		ret
    78                          
    79   00002a cdbb00          noequal:	call	printadr
    80   00002d eb              		ex	de, hl
    81   00002e cdbb00          		call	printadr
    82   000031 c9              		ret
    83                          
    84   000032 00              debug:		db	0
    85                          
    86                          	include "common.asm"
common.asm:
     1                          ;--------------------------------------------------------------
     2                          ;
     3                          ;--------------------------------------------------------------
     4                          copystr:
     5   000033 7e              		ld	a, (HL)
     6   000034 b7              		or	a
     7   000035 c8              		ret	Z
     8   000036 12              		ld	(DE), a
     9   000037 23              		inc	HL
    10   000038 13              		inc	DE
    11   000039 18f8            		jr	copystr
    12                          
    13                          ;--------------------------------------------------------------
    14                          ;
    15                          ;--------------------------------------------------------------
    16                          printstr:
    17   00003b af              		xor	a
    18   00003c 86              		add	a, (HL)
    19   00003d c8              		ret	Z
    20   00003e cd5d00          		call	chrouta
    21   000041 23              		inc	HL
    22   000042 18f7            		jr	printstr
    23                          
    24                          ;--------------------------------------------------------------
    25                          ;
    26                          ;--------------------------------------------------------------
    27                          space:
    28   000044 c5              		push	bc
    29   000045 0e20            		ld	c, 32
    30   000047 cd5e00          		call	chrout
    31   00004a c1              		pop	bc
    32   00004b c9              		ret
    33                          
    34                          ;--------------------------------------------------------------
    35                          ;
    36                          ;--------------------------------------------------------------
    37                          newline:
    38   00004c c5              		push	bc
    39   00004d 0e0d            		ld	c, 13
    40   00004f cd5e00          		call	chrout
    41   000052 c1              		pop	bc
    42   000053 c9              		ret
    43                          ;		ld	c, 10
    44                          ;		jp	chrout
    45                          
    46                          ;--------------------------------------------------------------
    47                          ; get a character in A from rs232 (1)
    48                          ;
    49                          ;--------------------------------------------------------------
    50                          chrin:
    51   000054 db01            		in	a, (STATA)
    52   000056 e601            		and	a, 1
    53   000058 28fa            		jr	Z, chrin
    54   00005a db03            		in	a, (RECA)
    55   00005c c9              		ret
    56                          
    57                          ;--------------------------------------------------------------
    58                          ; output a character in A over rs232 (1)
    59                          ;--------------------------------------------------------------
    60                          chrouta:
    61   00005d 4f              		ld	c, a
    62                          chrout:
    63   00005e f5              		push	AF
    64   00005f db01            chrout1:	in	a, (STATA)
    65   000061 e604            		and	a, 4
    66   000063 28fa            		jr	Z, chrout1
    67   000065 79              		ld	a, c
    68   000066 d303            		out	(TRANSA), a
    69   000068 f1              		pop	AF
    70   000069 c9              		ret
    71                          
    72                          ;--------------------------------------------------------------
    73                          ; get a character in A from rs232 (2)
    74                          ;
    75                          ;--------------------------------------------------------------
    76   00006a 010000          serin:		ld	bc, 0
    77   00006d db09            serin1:		in	a, (STATB)
    78   00006f e601            		and	a, 1
    79   000071 2007            		jr	NZ, serin2
    80   000073 10f8            		djnz	b, serin1
    81   000075 0d              		dec	c
    82   000076 20f5            		jr	NZ, serin1
    83   000078 37              		scf
    84   000079 c9              		ret
    85   00007a db0b            serin2:		in	a, (RECB)
    86   00007c c9              		ret
    87                          
    88                          ;--------------------------------------------------------------
    89                          ; output a character in A over rs232 (1)
    90                          ;
    91                          ;--------------------------------------------------------------
    92                          serout:
    93   00007d f5              		push	AF
    94   00007e db09            serout1:	in	a, (STATB)
    95   000080 e604            		and	a, 4
    96   000082 28fa            		jr	Z, serout1
    97   000084 f1              		pop	AF
    98   000085 d30b            		out	(TRANSB), a
    99   000087 c9              		ret
   100                          
   101                          ;--------------------------------------------------------------
   102                          ; prints byte in A in hexadecimal format
   103                          ;--------------------------------------------------------------
   104                          printhex:
   105   000088 f5              		push    AF
   106   000089 f5              		push    AF
   107   00008a 1f              		rra
   108   00008b 1f              		rra
   109   00008c 1f              		rra
   110   00008d 1f              		rra
   111   00008e cd9700          		call    printnib
   112   000091 f1              		pop     AF
   113   000092 cd9700          		call    printnib
   114   000095 f1              		pop     AF
   115   000096 c9              		ret
   116                          printnib:
   117   000097 e60f            		and     0fh
   118   000099 fe0a            		cp      0ah
   119   00009b 3802            		jr      C, printnib1
   120   00009d c607            		add     a, 07h
   121                          printnib1:
   122   00009f c630            		add     a, '0'
   123                          ;print:
   124   0000a1 c5              		push    BC
   125   0000a2 4f              		ld      c, a
   126   0000a3 cd5e00          		call    chrout
   127   0000a6 c1              		pop     BC
   128   0000a7 c9              		ret
   129                          
   130                          ;--------------------------------------------------------------
   131                          ;
   132                          ;--------------------------------------------------------------
   133   0000a8 e5              printstack:	push	hl
   134   0000a9 210000          		ld	hl, 0
   135   0000ac 39              		add	hl, sp
   136   0000ad cdbb00          		call	printadr
   137   0000b0 e1              		pop	hl
   138   0000b1 c9              		ret
   139                          
   140                          ;--------------------------------------------------------------
   141                          ;
   142                          ;--------------------------------------------------------------
   143                          getupper:
   144   0000b2 cd5400          		call	chrin
   145   0000b5 fe61            		cp	'a'
   146   0000b7 d8              		ret	C
   147   0000b8 d620            		sub	32
   148   0000ba c9              		ret
   149                          
   150                          ;--------------------------------------------------------------
   151                          ;
   152                          ;--------------------------------------------------------------
   153   0000bb 7c              printadr:	ld	a, h
   154   0000bc cd8800          		call	printhex
   155   0000bf 7d              		ld	a, l
   156   0000c0 cd8800          		call	printhex
   157   0000c3 c34400          		jp	space
   158                          ;--------------------------------------------------------------
   159                          ;	(de, Carry) = (de) - (hl)
   160                          ;--------------------------------------------------------------
   161   0000c6 c5              sbc32:		push	bc
   162   0000c7 d5              		push	de
   163   0000c8 e5              		push	hl
   164                          
   165   0000c9 b7              		or	a				;clear carry
   166   0000ca 0604            		ld	b, 4				;sbc 4 bytes
   167   0000cc 1a              sbc32a:		ld	a, (de)
   168   0000cd 9e              		sbc	(hl)
   169   0000ce 12              		ld	(de), a
   170   0000cf 13              		inc	de
   171   0000d0 23              		inc	hl
   172   0000d1 10f9            		djnz	sbc32a
   173                          
   174   0000d3 e1              		pop	hl
   175   0000d4 d1              		pop	de
   176   0000d5 c1              		pop	bc
   177   0000d6 c9              		ret
   178                          
   179                          ;--------------------------------------------------------------
   180                          ;	Z = (DE == HL)
   181                          ;--------------------------------------------------------------
   182   0000d7 c5              equal32:	push	bc
   183   0000d8 d5              		push	de
   184   0000d9 e5              		push	hl
   185                          
   186   0000da 0604            		ld	b, 4				;cmp 4 bytes
   187   0000dc 1a              equal32a:	ld	a, (de)
   188   0000dd be              		cp	a, (hl)
   189   0000de 2004            		jr	NZ, equal32b
   190   0000e0 13              		inc	de
   191   0000e1 23              		inc	hl
   192   0000e2 10f8            		djnz	equal32a
   193                          
   194   0000e4 e1              equal32b:	pop	hl
   195   0000e5 d1              		pop	de
   196   0000e6 c1              		pop	bc
   197   0000e7 c9              		ret
   198                          
   199                          ;--------------------------------------------------------------
   200                          ;	Carry = (de) - (hl)
   201                          ;--------------------------------------------------------------
   202   0000e8 c5              cmp32:		push	bc
   203   0000e9 d5              		push	de
   204   0000ea e5              		push	hl
   205                          
   206   0000eb b7              		or	a				;clear carry
   207   0000ec 0604            		ld	b, 4				;cmp 4 bytes
   208   0000ee 1a              cmp32a:		ld	a, (de)
   209   0000ef 9e              		sbc	a, (hl)
   210   0000f0 13              		inc	de
   211   0000f1 23              		inc	hl
   212   0000f2 10fa            		djnz	cmp32a
   213                          
   214   0000f4 e1              		pop	hl
   215   0000f5 d1              		pop	de
   216   0000f6 c1              		pop	bc
   217   0000f7 c9              		ret
   218                          
   219                          ;--------------------------------------------------------------
   220                          ;	(de) = (hl) + (de)
   221                          ;--------------------------------------------------------------
   222   0000f8 f5              add32:		push	af
   223   0000f9 c5              		push	bc
   224   0000fa d5              		push	de
   225   0000fb e5              		push	hl
   226                          
   227   0000fc b7              		or	a				;clear carry
   228   0000fd 0604            		ld	b, 4				;add 4 bytes
   229   0000ff 1a              add32a:		ld	a, (de)
   230   000100 8e              		adc	(hl)
   231   000101 12              		ld	(de), a
   232   000102 23              		inc	hl
   233   000103 13              		inc	de
   234   000104 10f9            		djnz	add32a
   235                          
   236   000106 e1              		pop	hl
   237   000107 d1              		pop	de
   238   000108 c1              		pop	bc
   239   000109 f1              		pop	af
   240   00010a c9              		ret
   241                          
   242                          ;--------------------------------------------------------------
   243                          ;	(de) = (hl)
   244                          ;--------------------------------------------------------------
   245   00010b c5              copy32:		push	bc
   246   00010c d5              		push	de
   247   00010d e5              		push	hl
   248                          
   249   00010e 010400          		ld	bc, 4
   250   000111 edb0            		ldir
   251                          
   252   000113 e1              		pop	hl
   253   000114 d1              		pop	de
   254   000115 c1              		pop	bc
   255   000116 c9              		ret
   256                          
   257                          ;--------------------------------------------------------------
   258                          ; are all 4 bytes hl is pointing to zero?
   259                          ;--------------------------------------------------------------
   260   000117 c5              isZero32:	push	bc
   261   000118 e5              		push	hl
   262   000119 af              		xor	a
   263   00011a 0604            		ld	b, 4
   264   00011c b6              isZero32a:	or	(hl)
   265   00011d 2003            		jr	NZ, isZero32b
   266   00011f 23              		inc	hl
   267   000120 10fa            		djnz	isZero32a
   268   000122 e1              isZero32b:	pop	hl
   269   000123 c1              		pop	bc
   270   000124 c9              		ret
   271                          
   272                          ;--------------------------------------------------------------
   273                          ;
   274                          ;	(DE) = 4 x zeros
   275                          ;--------------------------------------------------------------
   276   000125 f5              clear32:	push	af
   277   000126 c5              		push	bc
   278   000127 d5              		push	de
   279   000128 af              		xor	a
   280   000129 0604            		ld	b, 4
   281   00012b 12              clear32a:	ld	(de), a
   282   00012c 13              		inc	de
   283   00012d 10fc            		djnz	clear32a
   284   00012f d1              		pop	de
   285   000130 c1              		pop	bc
   286   000131 f1              		pop	af
   287   000132 c9              		ret
   288                          
   289                          ;--------------------------------------------------------------
   290                          ;; multiply DE and BC
   291                          ;; DE is equivalent to the number in the top row in our algorithm
   292                          ;; and BC is equivalent to the number in the bottom row in our algorithm
   293                          ;--------------------------------------------------------------
   294                          mul16:
   295   000133 3e10            		ld 	a, 16				; this is the number of bits of the number to process
   296   000135 210000          		ld 	hl, 0				; HL is updated with the partial result, and at the end it will hold
   297                          							; the final result.
   298                          mul16loop:
   299   000138 cb38            		srl	b
   300   00013a cb19            		rr	c       			;; divide BC by 2 and shifting the state of bit 0 into the carry
   301                          							;; if carry = 0, then state of bit 0 was 0, (the rightmost digit was 0)
   302                          							;; if carry = 1, then state of bit 1 was 1. (the rightmost digit was 1)
   303                          							;; if rightmost digit was 0, then the result would be 0, and we do the add.
   304                          							;; if rightmost digit was 1, then the result is DE and we do the add.
   305   00013c 3001            		jr	nc, mul16noadd
   306                          
   307                          							;; will get to here if carry = 1
   308   00013e 19              		add	hl, de
   309                          
   310                          mul16noadd:
   311                              ;; at this point BC has already been divided by 2
   312                          
   313   00013f eb              		ex	de,	hl 			;; swap DE and HL
   314   000140 29              		add	hl, hl				;; multiply DE by 2
   315   000141 eb              		ex	de,	hl 			;; swap DE and HL
   316                          
   317                              ;; at this point DE has been multiplied by 2
   318                          
   319   000142 3d              		dec	a
   320   000143 20f3            		jr	nz, mul16loop			;; process more bits
   321   000145 c9              		ret
   322                          
z80test.asm:
    87                          	include	"fat16.asm"
fat16.asm:
     1                          FATDEBUG	equ	0
     2                          
     3                          OP0		equ	1
     4                          OP1		equ	2
     5                          OP2		equ	4
     6                          
     7                          IP0		equ	1
     8                          IP1		equ	2
     9                          IP2		equ	4
    10                          
    11                          ;--------------------------------------------------------------
    12                          ; SD CARD constants
    13                          ;--------------------------------------------------------------
    14                          CMD0		equ	$40 +  0	;GO_IDLE_STATE	0x40, 64
    15                          CMD1		equ	$40 +  1	;reset
    16                          CMD8		equ	$40 +  8	;SEND_IF_COND	0x48, 72
    17                          CMD9		equ	$40 +  9	;SEND_CSD	0x49, 73
    18                          CMD13		equ	$40 + 13	;get_status	0x4D, 77
    19                          CMD17		equ	$40 + 17	;read  sector 	0x51, 81
    20                          CMD24		equ	$40 + 24	;write sector 	0x58, 88
    21                          CMD41		equ	$40 + 41	;SEND_OP_COND	0x69, 105 (leave idle state)
    22                          CMD55		equ	$40 + 55	;ACMD 		0x77, 119
    23                          CMD58		equ	$40 + 58	;READ_OCR	0x7A, 122
    24                          
    25                          DATEND		equ	DATBUF + $200
    26                          
    27                          DATA_START_BLOCK	equ $FE
    28                          DATA_RES_MASK		equ $1F
    29                          DATA_RES_ACCEPTED	equ $05
    30                          
    31                          CMD0CHK		equ $95
    32                          CMD1CHK		equ $F9
    33                          CMD8CHK		equ $87
    34                          
    35                          R1_IDLE_STATE	equ 1
    36                          R1_ILLEGAL_COMMAND equ 4
    37                          
    38                          SDCS		equ	OP0
    39                          SDMOSI		equ	OP1
    40                          SDCLK		equ	OP2
    41                          SDMISO		equ	IP0
    42                          
    43                          FEOF		equ	$FF
    44                          FNOTFOUND	equ	$FE
    45                          
    46                          
    47                          ;--------------------------------------------------------------
    48                          ; Input
    49                          ; HL 	pointer to 4-byte seek-length
    50                          ;--------------------------------------------------------------
    51                          fseek:
    52   000146 cd1701          		call	isZero32			;first request?
    53   000149 2807            		jr	Z, fseek8
    54                          
    55   00014b 111406          		ld	de, currpos			;no, currpos equal?
    56   00014e cdd700          		call	equal32
    57   000151 c8              		ret	z				;yes nothing to do
    58                          
    59   000152 e5              fseek8:		push	hl
    60   000153 cdcc02          		call	fopen1				;reset file-Ptr
    61                          
    62   000156 e1              		pop	hl
    63   000157 112d06          		ld	de, bytesavail
    64   00015a cde800          		call	cmp32				;bytesavail - seeksize
    65   00015d 3006            		jr	NC, fseek1			;seeksize <= bytesavail
    66   00015f 3eff            		ld	a, FEOF				;no
    67   000161 323b06          		ld	(fstatus), a
    68   000164 c9              		ret
    69                          
    70   000165 cdc600          fseek1:		call	sbc32				;byteavail -= seeklen
    71   000168 111406          		ld	de, currpos			;currpos = seeklen
    72   00016b cd0b01          		call	copy32
    73                          
    74   00016e 113906          		ld	de, datptr
    75   000171 7e              		ld	a, (hl)				;copy 9 bits to datptr
    76   000172 12              		ld	(de), a
    77   000173 4f              		ld	c, a				;save a in bc
    78   000174 23              		inc	hl
    79   000175 13              		inc	de
    80   000176 7e              		ld	a, (hl)
    81   000177 e601            		and	1
    82   000179 47              		ld	b, a				;save a in bc
    83   00017a c6fa            		add	DATBUF >> 8			;carry clear
    84   00017c 12              		ld	(de), a
    85   00017d c5              		push	bc
    86                          
    87   00017e 23              		inc	hl
    88   00017f 23              		inc	hl
    89   000180 112706          		ld	de, datsec + 3
    90   000183 af              		xor	a				;clear 4th byte
    91   000184 12              		ld	(de), a
    92                          
    93   000185 0603            		ld	b, 3				;copy 3 bytes and shift right once
    94   000187 1b              fseek2:		dec	de				;giving datsec
    95   000188 7e              		ld	a, (hl)
    96   000189 1f              		rra
    97   00018a 12              		ld	(de), a
    98   00018b 2b              		dec	hl
    99   00018c 10f9            		djnz	fseek2
   100                          
   101   00018e af              		xor	a
   102   00018f c1              		pop	bc
   103   000190 210002          		ld	hl, $200
   104   000193 ed42            		sbc	hl, bc
   105   000195 222a06          		ld	(bytes2read), hl
   106                          
   107   000198 212406          		ld	hl, datsec			;copy datsec to var32
   108   00019b 11f705          		ld	de, var32
   109   00019e cd0b01          		call	copy32
   110                          
   111   0001a1 3ad605          		ld	a, (secclus)			;rotate secclus bitposition to right
   112   0001a4 4f              		ld	c, a
   113   0001a5 cb19            fseek4:		rr	c
   114   0001a7 380c            		jr	C, fseek3			;done
   115   0001a9 0603            		ld	b, 3
   116   0001ab 21f905          		ld	hl, var32 + 2
   117   0001ae cb1e            fseek5:		rr	(hl)
   118   0001b0 2b              		dec	hl
   119   0001b1 10fb            		djnz	fseek5
   120   0001b3 18f0            		jr	fseek4
   121                          
   122   0001b5 212406          fseek3:		ld	hl, datsec			;datsec
   123   0001b8 3ad605          		ld	a, (secclus)
   124   0001bb 3d              		dec	a
   125   0001bc a6              		and	(hl)
   126   0001bd 324006          		ld	(fsecmask), a
   127   0001c0 47              		ld	b, a
   128   0001c1 3ad605          		ld	a, (secclus)
   129   0001c4 90              		sub	b
   130   0001c5 322c06          		ld	(secs2read), a
   131                          
   132                          
   133   0001c8 2af705          		ld	hl, (var32)
   134   0001cb e5              fseek6:		push	hl				;traverse var32 + 1(firstclust) clusters
   135   0001cc cde602          		call	fatNextCluster
   136   0001cf e1              		pop	hl
   137   0001d0 7d              		ld	a, l
   138   0001d1 b4              		or	a, h
   139   0001d2 2803            		jr	Z, fseek7
   140   0001d4 2b              		dec	hl
   141   0001d5 18f4            		jr	fseek6
   142                          
   143   0001d7 cdbd03          fseek7:		call	clust2sec
   144   0001da 3a4006          		ld	a, (fsecmask)
   145   0001dd 32ff05          		ld	(var8), a
   146   0001e0 112406          		ld	de, datsec
   147   0001e3 21ff05          		ld	hl, var8
   148   0001e6 cdf800          		call	add32
   149   0001e9 cdb704          		call	sdReadDat
   150                          
   151                          ;		ld	hl, (datptr)
   152                          ;		call	printadr
   153                          ;		ld	hl, (datsec)
   154                          ;		call	printadr
   155                          ;		ld	hl, (var32)
   156                          ;		call	printadr
   157                          ;		ld	hl, (bytesavail)
   158                          ;		call	printadr
   159                          ;		ld	hl, (bytes2read)
   160                          ;		call	printadr
   161                          ;		ld	a, (secs2read)
   162                          ;		call	printhexdebug
   163   0001ec c9              		ret
   164                          
   165                          ;--------------------------------------------------------------
   166                          ; Input
   167                          ; BC	number of bytes to write
   168                          ; HL	pointer to buffer to read from
   169                          ;
   170                          ; Output
   171                          ; A	status, 0 = OK, negativ = Error
   172                          ;--------------------------------------------------------------
   173                          fwrite:
   174                          
   175                          ;--------------------------------------------------------------
   176                          ; Input
   177                          ; BC	number of bytes to read
   178                          ; HL	pointer to buffer
   179                          ;
   180                          ; Output
   181                          ; A	status, 0 = OK, negativ = Error
   182                          ;--------------------------------------------------------------
   183   0001ed e5              fread:		push	hl
   184   0001ee ed433306        		ld	(freadbytes), bc		;bytes still to be read during fread
   185   0001f2 223706          		ld	(fbuffer), hl			;save hl in fbuffer
   186   0001f5 af              		xor	a
   187   0001f6 323b06          		ld	(fstatus), a			;clear status
   188   0001f9 67              		ld	h, a
   189   0001fa 6f              		ld	l, a
   190   0001fb 223106          		ld	(fbytesread), hl		;clear fbytesread
   191                          
   192                          freadloop:
   193                          	IF FATDEBUG = 1
   194                          		call	fdump
   195                          	ENDIF
   196   0001fe 213306          		ld	hl, freadbytes			;bytes to be read?
   197   000201 cd1701          		call	isZero32
   198   000204 280d            		jr	Z, freadex			;no -> finished
   199                          
   200   000206 212d06          		ld	hl, bytesavail			;are still bytes available?
   201   000209 cd1701          		call	isZero32
   202   00020c 200b            		jr	NZ, fread1
   203   00020e 3eff            		ld	a, FEOF
   204   000210 323b06          		ld	(fstatus),a
   205   000213 e1              freadex:	pop	hl				;reload hl with adr of buffer
   206   000214 ed4b3106        		ld	bc, (fbytesread)		;load bc with bytes read
   207   000218 c9              		ret
   208                          
   209   000219 112d06          fread1:		ld	de, bytesavail			;if bytesavail < freadbytes
   210   00021c 213306          		ld	hl, freadbytes
   211   00021f cde800          		call	cmp32
   212   000222 3009            		jr	NC, fread2
   213   000224 3eff            		ld	a, FEOF
   214   000226 323b06          		ld	(fstatus), a
   215   000229 eb              		ex	de, hl				;freadbytes = bytesavail
   216   00022a cd0b01          		call	copy32
   217                          
   218   00022d ed4b3306        fread2:		ld	bc, (freadbytes)
   219   000231 af              		xor	a				;clear carry
   220   000232 2a2a06          		ld	hl, (bytes2read)		;if bytes2read < freadbytes?
   221   000235 ed42            		sbc	hl, bc
   222   000237 3004            		jr	NC, fread3
   223   000239 ed4b2a06        		ld	bc, (bytes2read)
   224                          
   225   00023d 78              fread3:		ld	a, b				;is bytes2read zero?
   226   00023e b1              		or	a, c
   227   00023f 201d            		jr	NZ, fread4			;no, continue coying data
   228                          
   229   000241 112406          		ld	de, datsec			;increase data sector number
   230   000244 21f305          		ld	hl, const1
   231   000247 cdf800          		call	add32
   232                          
   233   00024a 212c06          		ld	hl, secs2read	 		;read new cluster?
   234   00024d 35              		dec	(hl)
   235   00024e 2006            		jr	NZ, fread6			;not zero, just go with incremented sector-number
   236                          
   237   000250 cde602          		call	fatNextCluster			;get next cluster in curclus
   238   000253 cdbd03          		call	clust2sec			;compute sector-number
   239                          
   240                          fread6:
   241   000256 cd9e02          		call	fatInitSector
   242                          
   243                          ;		ld	hl, (bytes2read)		;$200 to read?
   244                          ;		ld	(var16), hl
   245                          ;		ld	a, h
   246                          ;		cp	2
   247                          ;		jr	NZ, fread5
   248                          ;
   249                          ;		ld	hl, (fbuffer)			;write sector directly into receiving buffer
   250                          ;		call	sdReadSec
   251                          ;		ld	(fbuffer), hl
   252                          ;		jr	fread7
   253                          
   254                          fread5:
   255   000259 cdb704          		call	sdReadDat
   256   00025c 18cf            		jr	fread2				;bytes2read is <> 0 so we always end up at fread4
   257                          
   258   00025e ed43fb05        fread4:		ld	(var16), bc			;copy available sector data to buffer
   259   000262 ed5b3706        		ld	de, (fbuffer)
   260   000266 2a3906          		ld	hl, (datptr)
   261   000269 edb0            		ldir
   262   00026b ed533706        		ld	(fbuffer), de
   263   00026f 223906          		ld	(datptr), hl
   264                          
   265   000272 af              fread7:		xor	a				;bytes2read -= var16
   266   000273 2a2a06          		ld	hl, (bytes2read)
   267   000276 ed4bfb05        		ld	bc, (var16)
   268   00027a ed42            		sbc	hl, bc
   269   00027c 222a06          		ld	(bytes2read), hl
   270                          
   271   00027f 2a3106          		ld	hl, (fbytesread)		;fbytesread += var16
   272   000282 09              		add	hl, bc
   273   000283 223106          		ld	(fbytesread), hl
   274                          
   275   000286 112d06          		ld	de, bytesavail			;bytesavail -= bytes2read
   276   000289 21fb05          		ld	hl, var16
   277   00028c cdc600          		call	sbc32
   278                          
   279   00028f 113306          		ld	de, freadbytes			;freadbytes -= bytes2read
   280   000292 cdc600          		call	sbc32
   281                          
   282   000295 111406          		ld	de, currpos			;currpos += bytes2read
   283   000298 cdf800          		call	add32
   284   00029b c3fe01          		jp	freadloop
   285                          
   286                          ;--------------------------------------------------------------
   287                          ;
   288                          ;--------------------------------------------------------------
   289                          fatInitSector:
   290   00029e 2100fa          		ld	hl, DATBUF			;datptr = DATBUF
   291   0002a1 223906          		ld	(datptr), hl
   292                          
   293   0002a4 3ad605          		ld	a, (secclus)			;secs2read = secclus
   294   0002a7 322c06          		ld	(secs2read), a
   295                          
   296   0002aa 210002          		ld	hl, 512				;bytes to read = 512
   297   0002ad 222a06          		ld	(bytes2read), hl
   298                          
   299   0002b0 213006          		ld	hl, bytesavail + 3
   300   0002b3 7e              		ld	a, (hl)				;if filesize < 512 then
   301   0002b4 2b              		dec	hl
   302   0002b5 b6              		or	a, (hl)
   303   0002b6 c0              		ret	NZ				;> $FFFF!
   304   0002b7 2b              		dec	hl
   305   0002b8 7e              		ld	a, (hl)
   306   0002b9 fe02            		cp	2				;>= $200?
   307   0002bb d0              		ret	NC				;yes
   308                          
   309   0002bc 2a2d06          		ld	hl, (bytesavail)		;bytes2read = filesize
   310   0002bf 222a06          		ld	(bytes2read), hl
   311                          
   312   0002c2 c9              		ret
   313                          ;
   314                          ;
   315                          ;
   316   0002c3 cd1d03          fopen:		call	dirSearch
   317   0002c6 2004            		jr	NZ, fopen1
   318   0002c8 3efe            		ld	a, FNOTFOUND
   319   0002ca b7              		or	a
   320   0002cb c9              		ret
   321                          
   322                          fopen1:
   323   0002cc 111406          		ld	de, currpos			;currpos = 0
   324   0002cf cd2501          		call	clear32
   325                          
   326   0002d2 211006          		ld	hl, filesize			;bytesavail = filesize
   327   0002d5 112d06          		ld	de, bytesavail
   328   0002d8 cd0b01          		call	copy32
   329                          
   330   0002db 210000          		ld	hl, 0
   331   0002de 222a06          		ld	(bytes2read), hl
   332   0002e1 222806          		ld	(curclus), hl
   333                          
   334                          ;		dec	hl
   335                          ;		ld	(lastfatsec), hl
   336                          ;		ld	(lastfatsec + 2), hl
   337                          
   338   0002e4 af              		xor	a
   339   0002e5 c9              		ret
   340                          
   341                          ;--------------------------------------------------------------
   342                          ;
   343                          ;--------------------------------------------------------------
   344                          	IF FATDEBUG = 1
   345                          fdump:		ld	hl, (fbuffer)
   346                          		call	printadr
   347                          		ld	hl, (datptr)
   348                          		call	printadr
   349                          		ld	hl, (bytesavail)
   350                          		call	printadr
   351                          		ld	hl, (bytes2read)
   352                          		call	printadr
   353                          		ld	hl, (currpos)
   354                          		call	printadr
   355                          		ld	hl, (freadbytes)
   356                          		call	printadr
   357                          		ld	hl, (curclus)
   358                          		call	printadr
   359                          
   360                          		jp	newline
   361                          	ENDIF
   362                          
   363                          ;--------------------------------------------------------------
   364                          ; gets next cluster after curclus and stores in curclus
   365                          ;--------------------------------------------------------------
   366                          fatNextCluster:
   367   0002e6 2a2806          		ld	hl, (curclus)			;is curclus = 0, go with curclus = firstclust
   368   0002e9 7d              		ld	a, l
   369   0002ea b4              		or	a, h
   370   0002eb 2006            		jr	NZ, fatNextCluster1		;no
   371   0002ed ed4b0e06        		ld	bc, (firstclust)
   372   0002f1 1825            		jr	fatNextCluster2
   373                          
   374                          fatNextCluster1:
   375   0002f3 21e105          		ld	hl, fatbase			;computer FAT sector containing cluster
   376   0002f6 111806          		ld	de, fatsector
   377   0002f9 cd0b01          		call	copy32
   378   0002fc 3a2906          		ld	a, (curclus + 1)
   379   0002ff 32ff05          		ld	(var8), a
   380   000302 21ff05          		ld	hl, var8
   381   000305 cdf800          		call	add32				;fatsector = fatbase + hi(firstclust)
   382   000308 cda604          		call	sdReadFat
   383                          
   384   00030b 2a2806          		ld	hl, (curclus)			;lo(curclus) * 2
   385   00030e 2600            		ld	h, 0
   386   000310 29              		add	hl, hl
   387   000311 0100f8          		ld	bc, FATBUF
   388   000314 09              		add	hl, bc				;+ FATBUF
   389   000315 4e              		ld	c, (hl)
   390   000316 23              		inc	hl
   391   000317 46              		ld	b, (hl)
   392                          fatNextCluster2:
   393   000318 ed432806        		ld	(curclus), bc
   394   00031c c9              		ret
   395                          
   396                          ;--------------------------------------------------------------
   397                          ; search root-dir for file like "dirpattern"
   398                          ;--------------------------------------------------------------
   399   00031d cd3a03          dirSearch:	call	dirReadFirst			;read first root-entry
   400   000320 c8              dirSearch1:	ret	Z				;exit if zero
   401   000321 060b            		ld	b, 11				;compare 11-bytes of dir name
   402   000323 110306          		ld	de, dirpattern
   403   000326 1a              dirSearch2:	ld	a, (de)
   404   000327 fe3f            		cp	'?'
   405   000329 2803            		jr	Z, dirSearch3
   406   00032b be              		cp	(hl)
   407   00032c 2007            		jr	NZ, dirSearch4
   408   00032e 13              dirSearch3:	inc	de
   409   00032f 23              		inc	hl
   410   000330 10f4            		djnz	dirSearch2
   411   000332 f601            		or	1
   412   000334 c9              		ret
   413   000335 cd6a03          dirSearch4:	call	dirReadNext			;get next dir
   414   000338 18e6            		jr	dirSearch1
   415                          ;
   416                          ;
   417                          ;
   418                          dirReadFirst:
   419   00033a 21e505          		ld	hl, dirbase			;from dirbase
   420   00033d 11ed05          		ld	de, dirsec			;to dirsec
   421   000340 cd0b01          		call	copy32
   422                          
   423                          dirReadSector:
   424   000343 cdb704          		call	sdReadDat			;load directory sectorgiven in DE
   425   000346 2100fa          		ld	hl, DATBUF 			;start at begin of dir-data
   426   000349 22f105          		ld	(dirptr), hl
   427                          
   428   00034c 7e              dirRead2:	ld	a, (hl)				;first byte of name zero?
   429   00034d b7              		or	a
   430   00034e c8              		ret	Z				;yes, dir-ed reached, quit ZERO flag set
   431                          
   432   00034f e5              		push	hl
   433   000350 dde1            		pop	ix				;ix = hl
   434   000352 dd7e0b          		ld	a, (ix + 11)			;load attribute byte
   435   000355 e61f            		and	%00011111			;mask out archive ($20) and 2 highest bits
   436   000357 2014            		jr	NZ, dirRead1			;if no file -> next dir
   437                          
   438   000359 0606            		ld	b, 6
   439   00035b 110e06          		ld	de, firstclust			;to firstclust, filesize
   440   00035e dd7e1a          dirRead5:	ld	a, (ix + $1a)
   441   000361 12              		ld	(de), a
   442   000362 13              		inc	de
   443   000363 dd23            		inc	ix
   444   000365 10f7            		djnz	dirRead5
   445   000367 f601            		or	1				;reset ZERO flag
   446   000369 c9              		ret
   447                          
   448   00036a 2af105          dirReadNext:	ld	hl, (dirptr)
   449   00036d 112000          dirRead1:	ld	de, 32				;hl = hl + 32
   450   000370 19              		add	hl, de
   451   000371 22f105          		ld	(dirptr), hl
   452                          
   453   000374 7c              		ld	a, h
   454   000375 fefc            		cp	DATEND >> 8
   455   000377 20d3            		jr	NZ, dirRead2
   456                          
   457   000379 11ed05          		ld	de, dirsec			;increment dirsector 32-bit
   458   00037c 21f305          		ld	hl, const1
   459   00037f cdf800          		call	add32
   460   000382 18bf            		jr	dirReadSector
   461                          
   462                          ;--------------------------------------------------------------
   463                          ; prints entire directory
   464                          ;--------------------------------------------------------------
   465                          dirPrint:;	ld	hl, allpattern			;copy allpattern to dirpattern
   466                          	;	ld	de, dirpattern
   467                          	;	ld	bc, 11
   468                          	;	ldir
   469                          
   470   000384 cd3a03          		call	dirReadFirst
   471   000387 c8              dirPrint1:	ret	Z				;return if zero
   472   000388 cd9003          		call	dirPrintEntry
   473   00038b cd6a03          		call	dirReadNext
   474   00038e 18f7            		jr	dirPrint1
   475                          
   476                          ;--------------------------------------------------------------
   477                          ; prints dir @ hl
   478                          ;--------------------------------------------------------------
   479   000390 e5              dirPrintEntry:	push	hl
   480   000391 2af105          		ld	hl, (dirptr)			;print dir name 8 space 3
   481   000394 0608            		ld	b, 8
   482   000396 cdb503          		call	dirPrintEntry1
   483   000399 cd4400          		call	space
   484   00039c 0603            		ld	b, 3
   485   00039e cdb503          		call	dirPrintEntry1
   486                          
   487   0003a1 cd4400          		call	space
   488   0003a4 2a1206          		ld	hl, (filesize + 2)
   489   0003a7 cdbb00          		call	printadr
   490   0003aa 2a1006          		ld	hl, (filesize)
   491   0003ad cdbb00          		call	printadr
   492                          
   493   0003b0 cd4c00          		call	newline
   494   0003b3 e1              		pop	hl
   495   0003b4 c9              		ret
   496                          
   497   0003b5 4e              dirPrintEntry1:	ld	c, (hl)
   498   0003b6 cd5e00          		call	chrout
   499   0003b9 23              		inc	hl
   500   0003ba 10f9            		djnz	dirPrintEntry1
   501   0003bc c9              		ret
   502                          
   503                          
   504                          ;--------------------------------------------------------------
   505                          ; computes the first data-sector from cluster-number
   506                          ;
   507                          ; datsec = (curclus - 2) * secclus + datbase
   508                          ; de : points to datsec
   509                          ;--------------------------------------------------------------
   510   0003bd 2a2806          clust2sec:	ld	hl, (curclus)
   511   0003c0 2b              		dec	hl
   512   0003c1 2b              		dec	hl				;minus 2
   513   0003c2 110000          		ld	de, 0
   514   0003c5 3ad605          		ld	a, (secclus)
   515                          
   516   0003c8 1f              clust2sec2:	rra
   517   0003c9 380a            		jr	C, clust2sec1			;carry set, finished
   518   0003cb cb15            		rl	l
   519   0003cd cb14            		rl	h
   520   0003cf cb13            		rl	e
   521   0003d1 cb12            		rl	d
   522   0003d3 18f3            		jr	clust2sec2
   523                          
   524   0003d5 222406          clust2sec1:	ld	(datsec), hl
   525   0003d8 ed532606        		ld	(datsec + 2), de
   526   0003dc 112406          		ld	de, datsec
   527   0003df 21e905          		ld	hl, datbase
   528   0003e2 c3f800          		jp	add32
   529                          
   530                          ;--------------------------------------------------------------
   531                          ;
   532                          ;--------------------------------------------------------------
   533   0003e5 cd7f05          sdInit:		call	sdDeselect
   534   0003e8 3e04            		ld	a, SDCLK			;bring SDCLK low
   535   0003ea d30e            		out	(OPSET), a
   536   0003ec 160c            		ld	d, 12				;clock 96 times
   537   0003ee cd8605          		call	sdReadbyteX
   538                          
   539                          ;
   540                          ; send CMD0
   541                          ;
   542   0003f1 cdc505          		call	sdClrAdr
   543   0003f4 3e95            		ld	a, CMD0CHK			;load checksum
   544   0003f6 32d405          		ld	(sdchk), a
   545   0003f9 3e40            sdInit1:	ld	a, CMD0				;command in A
   546   0003fb cdab05          		call	sdCardCmd
   547   0003fe fe01            		cp	R1_IDLE_STATE
   548   000400 20e3            		jr	NZ, sdInit
   549                          
   550                          ;
   551                          ; send CMD8
   552                          ;
   553                          
   554   000402 cdc505          sdInit2:	call	sdClrAdr
   555   000405 2101aa          		ld	hl, $aa01
   556   000408 22d205          		ld	(sdadr+2), hl
   557   00040b 3e87            		ld	a, CMD8CHK
   558   00040d 32d405          		ld	(sdchk), a
   559   000410 3e48            		ld	a, CMD8
   560   000412 cdab05          		call	sdCardCmd
   561                          ;		and	#R1_ILLEGAL_COMMAND
   562                          ;		cmp	#R1_ILLEGAL_COMMAND
   563                          ;		bne	sdInit3
   564                          
   565                          ;		ldx #3
   566                          ;		jsr readByteX
   567                          
   568                          
   569                          
   570                          ;
   571                          ; ACMD41 = CMD55 + CMD41
   572                          ;
   573   000415 cd7f05          sdInit6:	call	sdDeselect
   574   000418 cdc505          		call	sdClrAdr
   575   00041b 3e77            		ld	a, CMD55
   576   00041d cdab05          		call	sdCardCmd
   577                          
   578   000420 3e40            		ld	a, $40
   579   000422 32d005          		ld	(sdadr), a
   580   000425 3e69            		ld	a, CMD41
   581   000427 cdab05          		call	sdCardCmd
   582   00042a 20e9            		jr	NZ, sdInit6			;result not 0, start over
   583                          
   584                          ;sdInit4:	call	sdDeselect
   585                          ;		ld	a, CMD58			;read OCR, ($3A)
   586                          ;		ld	(sdcmd), a
   587                          ;		call	sdCardCmd
   588                          ;		jr	NZ, sdInit4
   589                          ;
   590                          ;		ld	d, 3
   591                          ;		call	sdReadbyteX
   592                          
   593   00042c 111806          		ld	de, fatsector			;read sector 0
   594   00042f cd2501          		call	clear32
   595   000432 cda604          		call	sdReadFat
   596                          
   597   000435 2100f8          		ld	hl, FATBUF			;from
   598   000438 01c601          		ld	bc, $1c6			;sdbuffer + $1c6
   599   00043b 09              		add	hl, bc
   600   00043c 111806          		ld	de, fatsector			;to fatsector
   601   00043f cd0b01          		call	copy32
   602                          
   603   000442 cda604          		call	sdReadFat
   604                          
   605   000445 2100f8          		ld	hl, FATBUF			;from
   606   000448 010d00          		ld	bc, 13				;sdbuffer + 13
   607   00044b 09              		add	hl, bc
   608   00044c 11d605          		ld	de, secclus			;to secclus
   609   00044f 010b00          		ld	bc, 11				;copy 11-bytes
   610   000452 edb0            		ldir
   611                          
   612                          
   613   000454 2ad705          		ld	hl, (ressec)			;fatbase = dirbase = fatsector + ressec
   614   000457 22fb05          		ld	(var16), hl			;copy resec to var16
   615   00045a 211806          		ld	hl, fatsector			;copy sdsector to fatbase
   616   00045d 11e105          		ld	de, fatbase
   617   000460 cd0b01          		call	copy32
   618   000463 21fb05          		ld	hl, var16			;add resec to fatbase
   619   000466 cdf800          		call	add32
   620   000469 eb              		ex	de, hl				;copy fatbase to dirbase
   621   00046a 11e505          		ld	de, dirbase
   622   00046d cd0b01          		call	copy32
   623                          
   624   000470 2adf05          		ld	hl, (secsfat)
   625   000473 22fb05          		ld	(var16), hl
   626   000476 21fb05          		ld	hl, var16
   627   000479 3ad905          		ld	a, (numfats)			;dirbase += secsfat * numfats
   628   00047c 47              		ld	b, a
   629   00047d cdf800          fatCompDirbase:	call	add32
   630   000480 10fb            		djnz	fatCompDirbase
   631                          
   632                          							;datbase = (numdir / 16) + dirbase
   633   000482 2ada05          		ld	hl, (numdir)			;datbase = numdir
   634   000485 0604            		ld	b, 4
   635   000487 cb3c            fatcompDatbase:	srl	h
   636   000489 cb1d            		rr	l
   637   00048b 10fa            		djnz	fatcompDatbase
   638                          
   639   00048d ed5be505        		ld	de, (dirbase)
   640   000491 19              		add	hl, de				;datbase += dirbase
   641   000492 22e905          		ld	(datbase), hl
   642   000495 c9              		ret
   643                          
   644                          ;--------------------------------------------------------------
   645                          ; DE: address of 4-byte sector number
   646                          ;--------------------------------------------------------------
   647   000496 21d305          sdSetSector:	ld	hl, sdadr + 3
   648   000499 af              		xor	a
   649   00049a 77              		ld	(hl), a
   650   00049b 2b              		dec	hl
   651   00049c 0603            		ld	b, 3
   652   00049e 1a              sdSetSector1:	ld	a, (de)
   653                          	if DEBUG = 1
   654                          		call	printhexdebug
   655                          	endif
   656   00049f 17              		rla
   657   0004a0 77              		ld	(hl), a
   658   0004a1 13              		inc	de
   659   0004a2 2b              		dec	hl
   660   0004a3 10f9            		djnz	sdSetSector1
   661   0004a5 c9              		ret
   662                          
   663                          ;--------------------------------------------------------------
   664                          ;
   665                          ;--------------------------------------------------------------
   666                          sdReadFat:
   667   0004a6 211c06          		ld	hl, lastfatsec			;FAT sector in DE already read?
   668   0004a9 cdd700          		call	equal32
   669   0004ac c8              		ret	Z				;yes
   670                          
   671   0004ad eb              		ex	de, hl				;copy sector to lastfatsec
   672   0004ae cd0b01          		call	copy32
   673   0004b1 eb              		ex	de, hl
   674                          
   675   0004b2 2100f8          		ld	hl, FATBUF
   676   0004b5 180f            		jr	sdReadSec
   677                          
   678                          ;--------------------------------------------------------------
   679                          ; reads one sector in (DE) into DATBUF
   680                          ;--------------------------------------------------------------
   681                          sdReadDat:
   682   0004b7 212006          		ld	hl, lastdatsec			;FAT sector in DE already read?
   683   0004ba cdd700          		call	equal32
   684   0004bd c8              		ret	Z				;yes
   685                          
   686   0004be eb              		ex	de, hl				;copy sector to lastdatsec
   687   0004bf cd0b01          		call	copy32
   688   0004c2 eb              		ex	de, hl
   689   0004c3 2100fa          		ld	hl, DATBUF
   690                          
   691                          ;--------------------------------------------------------------
   692                          ; hl		buffer to load data into
   693                          ; de		pointer to 4-byte sector number
   694                          ;--------------------------------------------------------------
   695   0004c6 e5              sdReadSec:	push	hl
   696   0004c7 cd9604          		call	sdSetSector
   697   0004ca 3e51            		ld	a, CMD17			;read block
   698   0004cc cdab05          		call	sdCardCmd
   699                          
   700   0004cf cd8d05          sdReadSec2:	call	sdReadByte			;data token until $FE, i.e. bit 0 = 0;
   701   0004d2 cb19            		rr	c
   702   0004d4 38f9            		jr	C, sdReadSec2
   703                          
   704   0004d6 3e02            		ld	a, SDMOSI
   705   0004d8 d30f            		out	(OPRES), a			;SDMOSI = 1
   706                          
   707   0004da e1              		pop	hl
   708   0004db 110002          		ld	de, 512				;read 512 bytes
   709   0004de 0604            		ld	b, SDCLK
   710                          sdReadSec1:
   711   0004e0 db0d            		in	a, (INPORT)
   712   0004e2 1f              		rra
   713   0004e3 cb11            		rl	c
   714   0004e5 78              		ld	a, b
   715   0004e6 d30f            		out	(OPRES), a			;sdClock high
   716   0004e8 d30e            		out	(OPSET), a			;sdClock low
   717   0004ea db0d            		in	a, (INPORT)
   718   0004ec 1f              		rra
   719   0004ed cb11            		rl	c
   720   0004ef 78              		ld	a, b
   721   0004f0 d30f            		out	(OPRES), a			;sdClock high
   722   0004f2 d30e            		out	(OPSET), a			;sdClock low
   723   0004f4 db0d            		in	a, (INPORT)
   724   0004f6 1f              		rra
   725   0004f7 cb11            		rl	c
   726   0004f9 78              		ld	a, b
   727   0004fa d30f            		out	(OPRES), a			;sdClock high
   728   0004fc d30e            		out	(OPSET), a			;sdClock low
   729   0004fe db0d            		in	a, (INPORT)
   730   000500 1f              		rra
   731   000501 cb11            		rl	c
   732   000503 78              		ld	a, b
   733   000504 d30f            		out	(OPRES), a			;sdClock high
   734   000506 d30e            		out	(OPSET), a			;sdClock low
   735   000508 db0d            		in	a, (INPORT)
   736   00050a 1f              		rra
   737   00050b cb11            		rl	c
   738   00050d 78              		ld	a, b
   739   00050e d30f            		out	(OPRES), a			;sdClock high
   740   000510 d30e            		out	(OPSET), a			;sdClock low
   741   000512 db0d            		in	a, (INPORT)
   742   000514 1f              		rra
   743   000515 cb11            		rl	c
   744   000517 78              		ld	a, b
   745   000518 d30f            		out	(OPRES), a			;sdClock high
   746   00051a d30e            		out	(OPSET), a			;sdClock low
   747   00051c db0d            		in	a, (INPORT)
   748   00051e 1f              		rra
   749   00051f cb11            		rl	c
   750   000521 78              		ld	a, b
   751   000522 d30f            		out	(OPRES), a			;sdClock high
   752   000524 d30e            		out	(OPSET), a			;sdClock low
   753   000526 db0d            		in	a, (INPORT)
   754   000528 1f              		rra
   755   000529 cb11            		rl	c
   756   00052b 78              		ld	a, b
   757   00052c d30f            		out	(OPRES), a			;sdClock high
   758   00052e d30e            		out	(OPSET), a			;sdClock low
   759                          
   760   000530 71              		ld	(hl), c
   761   000531 23              		inc	hl
   762   000532 1d              		dec	e
   763   000533 c2e004          		jp	NZ, sdReadSec1
   764   000536 15              		dec	d
   765   000537 20a7            		jr	NZ, sdReadSec1
   766                          
   767   000539 1602            		ld	d, 2				;2-byte checksum
   768   00053b cd8605          		call	sdReadbyteX
   769   00053e cd7f05          		call	sdDeselect
   770   000541 c9              		ret
   771                          
   772                          
   773                          ;--------------------------------------------------------------
   774                          ; writes one sector in (DE) into DATBUF
   775                          ;--------------------------------------------------------------
   776   000542 2100fa          sdWriteDat:	ld	hl, DATBUF
   777                          ;--------------------------------------------------------------
   778                          ; hl		buffer to copy data from
   779                          ; de		pointer to 4-byte sector number
   780                          ;--------------------------------------------------------------
   781   000545 e5              sdWriteSec:	push	hl
   782   000546 cd9604          		call	sdSetSector
   783   000549 3e58            		ld	a, CMD24			;write sector
   784   00054b cdab05          		call	sdCardCmd
   785                          
   786   00054e 0efe            		ld	c, DATA_START_BLOCK
   787   000550 cd8f05          		call	sdSendByte
   788                          
   789   000553 e1              		pop	hl
   790   000554 110002          		ld	de, 512				;read 512 bytes
   791   000557 4e              sdWriteSec1:	ld	c, (hl)
   792   000558 cd8f05          		call	sdSendByte
   793   00055b 23              		inc	hl
   794   00055c 1d              		dec	e
   795   00055d c25705          		jp	NZ, sdWriteSec1
   796   000560 15              		dec	d
   797   000561 20f4            		jr	NZ, sdWriteSec1
   798                          
   799   000563 cd8d05          sdWriteSec2:	call	sdReadByte
   800   000566 79              		ld	a, c
   801   000567 feff            		cp	$FF
   802   000569 28f8            		jr	Z, sdWriteSec2			;loop if $ff
   803                          
   804                          ;		and	DATA_RES_MASK			;assume data accepted
   805                          ;		cp	DATA_RES_ACCEPTED		; "00000101" = 5 ?
   806                          
   807   00056b cd7605          		call	sdWait
   808   00056e cd7f05          		call	sdDeselect
   809   000571 c9              		ret
   810                          
   811                          ;--------------------------------------------------------------
   812                          ;
   813                          ;--------------------------------------------------------------
   814   000572 3e01            sdSelect:	ld	a, SDCS
   815   000574 d30e            		out	(OPSET), a			;SDCS low (active)
   816   000576 cd8d05          sdWait:		call	sdReadByte
   817   000579 3eff            		ld	a, 255
   818   00057b b9              		cp	c
   819   00057c 20f8            		jr	NZ, sdWait
   820   00057e c9              		ret
   821                          
   822                          ;--------------------------------------------------------------
   823                          ;
   824                          ;--------------------------------------------------------------
   825   00057f 3e01            sdDeselect:	ld	a, SDCS
   826   000581 d30f            		out	(OPRES), a
   827   000583 c38d05          		jp	sdReadByte
   828                          
   829                          ;--------------------------------------------------------------
   830                          ;
   831                          ;--------------------------------------------------------------
   832   000586 cd8d05          sdReadbyteX:	call	sdReadByte
   833   000589 15              		dec	d
   834   00058a 20fa            		jr	NZ, sdReadbyteX
   835   00058c c9              		ret
   836                          
   837                          ;--------------------------------------------------------------
   838                          ; Input
   839                          ; c		byte to send to sd-card
   840                          ;--------------------------------------------------------------
   841   00058d 0eff            sdReadByte:	ld	c, $ff
   842   00058f 0608            sdSendByte:	ld	b, 8
   843   000591 db0d            sdSendByte2:	in	a, (INPORT)
   844   000593 1f              		rra
   845   000594 cb11            		rl	c
   846   000596 3e02            		ld	a, SDMOSI
   847   000598 daa005          		jp	C, sdSendByte4
   848   00059b d30e            		out	(OPSET), a			;carry 0, SDMOSI = 0
   849   00059d c3a205          		jp	sdSendByte3
   850   0005a0 d30f            sdSendByte4:	out	(OPRES), a			;carry 1, SDMOSI = 1
   851   0005a2 3e04            sdSendByte3:	ld	a, SDCLK
   852   0005a4 d30f            		out	(OPRES), a			;sdClock high
   853   0005a6 d30e            		out	(OPSET), a			;sdClock low
   854   0005a8 10e7            		djnz	sdSendByte2
   855   0005aa c9              		ret
   856                          
   857                          ;--------------------------------------------------------------
   858                          ; sends command in A to SD card
   859                          ;--------------------------------------------------------------
   860   0005ab 21cf05          sdCardCmd:	ld	hl, sdcmd
   861   0005ae 77              		ld	(hl), a
   862                          
   863                          	if DEBUG = 1
   864                          		ld	c, 'C'
   865                          		call	chroutdebug
   866                          		call	printhexdebug
   867                          		call	spacedebug
   868                          	endif
   869                          
   870   0005af 1606            sdCardCmd3:	ld	d, 6
   871   0005b1 cd7205          		call	sdSelect
   872   0005b4 4e              sdCardCmd1:	ld	c, (hl)
   873   0005b5 cd8f05          		call	sdSendByte
   874   0005b8 23              		inc	hl
   875   0005b9 15              		dec	d
   876   0005ba 20f8            		jr	NZ, sdCardCmd1
   877   0005bc cd8d05          sdCardCmd2:	call	sdReadByte
   878   0005bf 79              		ld	a, c
   879                          	if DEBUG = 1
   880                          		call	printhexdebug
   881                          	endif
   882   0005c0 b7              		or	a, a
   883   0005c1 fabc05          		jp	M, sdCardCmd2
   884                          	if DEBUG = 1
   885                          		call	spacedebug
   886                          	endif
   887                          
   888   0005c4 c9              		ret
   889                          
   890                          ;--------------------------------------------------------------
   891                          ;
   892                          ;--------------------------------------------------------------
   893   0005c5 210000          sdClrAdr:	ld	hl, 0
   894   0005c8 22d005          		ld	(sdadr), hl
   895   0005cb 22d205          		ld	(sdadr + 2), hl
   896   0005ce c9              		ret
   897                          
   898                          	if DEBUG = 1
   899                          printadrdebug:
   900                          		push	af
   901                          		ld	a, (debug)
   902                          		or	a
   903                          		jr	Z, printadrdebex
   904                          		pop	af
   905                          		jp	printadr
   906                          printadrdebex:	pop	af
   907                          		ret
   908                          
   909                          
   910                          printhexdebug:
   911                          		push	af
   912                          		ld	a, (debug)
   913                          		or	a
   914                          		jr	Z, printhexdex
   915                          		pop	af
   916                          		jp	printhex
   917                          printhexdex:	pop	af
   918                          		ret
   919                          
   920                          
   921                          
   922                          chroutdebug:
   923                          		push	af
   924                          		ld	a, (debug)
   925                          		or	a
   926                          		jr	Z, chroutdebugex
   927                          		pop	af
   928                          		jp	chrout
   929                          chroutdebugex:	pop	af
   930                          		ret
   931                          
   932                          spacedebug:
   933                          		push	af
   934                          		ld	a, (debug)
   935                          		or	a
   936                          		jr	Z, spacedebugex
   937                          		pop	af
   938                          		jp	space
   939                          spacedebugex:	pop	af
   940                          		ret
   941                          
   942                          newlinedebug:
   943                          		push	af
   944                          		ld	a, (debug)
   945                          		or	a
   946                          		jr	Z, newlinedebugex
   947                          		pop	af
   948                          		jp	newline
   949                          newlinedebugex:	pop	af
   950                          		ret
   951                          	endif
   952                          
   953                          ;--------------------------------------------------------------
   954                          ; variables and constants
   955                          ;--------------------------------------------------------------
   956   0005cf 00              sdcmd:		db	0			;1-byte SD card command
   957   0005d0 00000000        sdadr:		db	0, 0, 0, 0		;4-byte SD card address
   958   0005d4 00              sdchk:		db	0			;1-byte SD card checksum
   959   0005d5 00              sdres:		db	0			;1-byte SD card R1 result
   960                          
   961                          ;
   962                          ; FATBUF + 13, 11-bytes holding basic FAT info
   963   0005d6 00              secclus:	db	0			;1-byte FAT sectors per cluster
   964   0005d7 0000            ressec:		db	0, 0			;2-byte	DAT reserved sectors
   965   0005d9 00              numfats:	db	0			;1-byte number of FATS
   966   0005da 0000            numdir:		db	0, 0			;2-byte max number of 32-bytes root directoy entries
   967   0005dc 0000            numsecs:	db	0, 0			;2-byte number of sectors in this volume
   968   0005de 00              media:		db	0			;1-byte 0xF8 is the standard value for “fixed” (nonremovable) media. For removable media, 0xF0 is frequently used.
   969   0005df 0000            secsfat:	db	0, 0			;2-byte FAT12/FAT16 16-bit count of sectors occupied by one FAT
   970                          
   971   0005e1 00000000        fatbase:	db	0, 0, 0, 0		;4-byte	first sector of FAT
   972   0005e5 00000000        dirbase:	db	0, 0, 0, 0		;4-byte	first sector of root directory
   973   0005e9 00000000        datbase:	db	0, 0, 0, 0		;4-byte	first sector of data section
   974                          
   975   0005ed 00000000        dirsec:		db	0, 0, 0, 0		;4-byte	current sector of root directory
   976   0005f1 0000            dirptr:		dw	0			;2-byte pointer in directory data
   977                          						;32-byte directory structure
   978                          ;dirname:	dw	0, 0, 0, 0		;8-byte
   979                          ;dirext:		db 0, 0, 0		;3-byte
   980                          ;dirattr:	db	0			;1-byte
   981                          ;dirreserved:	db	0			;1-byte
   982                          ;dirdatetime:	db	0, 0, 0, 0, 0, 0, 0	;7-byte
   983                          ;dirclusthi:	dw	0			;2-byte (always 0 for FAT16)
   984                          ;dirwritetd:	dw	0, 0			;4-byte write time/date
   985                          ;dircluster:	dw	0			;2-byte first cluster of data
   986                          ;dirfilesize:	dw	0, 0			;4-byte size of file in bytes
   987                          
   988   0005f3 01000000        const1:		db	1, 0, 0, 0		;4-byte const1
   989   0005f7 00000000        var32:		dw	0, 0
   990   0005fb 00000000        var16:		dw	0, 0
   991   0005ff 00000000        var8:		dw	0, 0
   992                          
   993   000603 4449534b30303f3fdirpattern:	db	"DISK00??DSK"	;
                44534b          
   994                          ;allpattern:	db	"???????????"	;
   995                          ;kilopattern:	db	"KILO????C??"	;
   996                          
   997                          ;
   998                          ; file related data
   999                          ;
  1000   00060e 0000            firstclust:	dw 0				;2-byte first cluster of file
  1001   000610 00000000        filesize:	dw 0, 0				;4-byte length of file
  1002   000614 00000000        currpos:	dw 0, 0
  1003                          
  1004   000618 00000000        fatsector:	dw 0, 0				;4-byte actual FAT sector read
  1005   00061c ffffffff        lastfatsec:	dw $ffff, $ffff			;4-byte last read FAT sector
  1006   000620 ffffffff        lastdatsec:	dw $ffff, $ffff			;4-byte last read data sector
  1007   000624 00000000        datsec:		dw 0, 0				;4-byte current data sector read
  1008   000628 0000            curclus:	dw 0				;2-byte current cluster
  1009   00062a 0000            bytes2read:	dw 0				;2-byte remaining bytes in sector to read
  1010   00062c 00              secs2read:	db 0				;1-byte sectors to read in cluster
  1011   00062d 00000000        bytesavail:	dw 0, 0				;4-byte bytes still available in file
  1012   000631 0000            fbytesread:	dw 0				;2-byte bytes read during fread
  1013   000633 00000000        freadbytes:	dw 0, 0				;4-byte
  1014   000637 0000            fbuffer:	dw 0				;2-byte buffer data to be copied to
  1015   000639 0000            datptr:		dw 0				;2-byte pointer into data sector
  1016   00063b 00              fstatus:	db 0				;1-byte status of operation
  1017   00063c 00000000        fseeklen:	dw 0, 0				;4-byte length of fseek
  1018   000640 00              fsecmask:	db 0				;1-byte mask for sector in fseek
  1019                          
z80test.asm:
    88                          
    89                          	if	NOEXCLUDE
    90                          
    91                          		di
    92                          
    93                          		jp	skip
    94                          
    95                          
    96                          		ld	a, 0c3h				;ld jump
    97                          		ld	(adr0038), a
    98                          
    99                          		ld	hl, intproc
   100                          		ld	(adr0038 + 1), hl
   101                          		im	1				;interrupt mode 1, goto $38
   102                          
   103                          		ld	a, $E2				;BRG set 2 and timer = X1/CLK and IP1 change
   104                          		out	(AUXCTRL), a
   105                          
   106                          		ld	a, $82				;enable IP0-3 change
   107                          		out	(IMR), a			;enable RxRDY A interrupt
   108                          
   109                          skip:
   110                          		ld	hl, 0
   111                          		ld	(rxstat), hl
   112                          		ld	(rxrdy), hl
   113                          		ld	(rxshift), hl
   114                          		ld	(rxaltgr), hl
   115                          		ld	(sdsector), hl
   116                          		ld	(sdsector + 1), hl
   117                          
   118                          ;		ei
   119                          
   120                          ;
   121                          ;
   122                          ;
   123                          
   124                          
   125                          		call	sdInit				;initSd and read FAT data
   126                          
   127                          		call	dirPrint
   128                          		call	fopen
   129                          		ret	NZ
   130                          
   131                          readloop:
   132                          		ld	hl, 0
   133                          		ld	(fseeklen + 2), hl
   134                          		ld	hl, 1000
   135                          		ld	(fseeklen), hl
   136                          		ld	hl, fseeklen
   137                          		call	fseek
   138                          
   139                          		ld	bc, $80
   140                          		ld	hl, $1000
   141                          		call	fread
   142                          
   143                          ;		push	bc
   144                          ;		push	hl
   145                          ;		call	printadr
   146                          ;		push	bc
   147                          ;		pop	hl
   148                          ;		call	printadr
   149                          ;		ld	a, (fstatus)
   150                          ;		call	printhex
   151                          ;		call	newline
   152                          
   153                          		ld	d, b
   154                          		ld	e, c
   155                          
   156                          readloop1:	ld	c, (hl)
   157                          		call	conout
   158                          		inc	hl
   159                          		dec	de
   160                          		ld	a, d
   161                          		or	a, e
   162                          		jr	NZ, readloop1
   163                          
   164                          		ld	a, (fstatus)
   165                          ;		call	printhex
   166                          		or	a
   167                          		ret	NZ
   168                          		ret
   169                          		jr	readloop
   170                          
   171                          ;--------------------------------------------------------------
   172                          		include	"common.asm"
   173                          		include "fat16.asm"
   174                          ;--------------------------------------------------------------
   175                          
   176                          ;--------------------------------------------------------------
   177                          ;
   178                          ;
   179                          ;--------------------------------------------------------------
   180                          intproc:	ex	af, af'
   181                          		exx
   182                          
   183                          intproc1:	in	a, (ISR)
   184                          		ld	b, a
   185                          
   186                          		and	2				;RxRdy A?
   187                          		jr	Z, intIPchange
   188                          
   189                          intReceive:	in	a, (RECA)
   190                          		out	(TRANSA),a
   191                          
   192                          intIPchange:
   193                          		ld	a, b
   194                          		and	128
   195                          		jr	Z, intprocex
   196                          
   197                          
   198                          		in	a, (IPCHANGE)			;IP1 = low?
   199                          		and	PS2CLK
   200                          		jr	NZ, intprocex			;IP1 = high, no nothing
   201                          
   202                          		ld	hl, rxstat			;status 0 (start-bit expected)
   203                          		ld	a, (hl)				;load status
   204                          		or	a				;test if zero
   205                          		jr	NZ, intIPdata			;status <> 0
   206                          		in	a, (IPCHANGE)
   207                          		and	PS2DATA				;start-bit 0?
   208                          		jr	NZ, intprocex			;no, do nothing
   209                          		inc	(hl)				;increment rxstat
   210                          
   211                          		jr	intprocex
   212                          
   213                          
   214                          intIPdata:	inc	(hl)				;inc rxstat
   215                          		inc	hl				;hl = rxval
   216                          		cp	9
   217                          		jr	NC, intIPstop
   218                          
   219                          		in	a, (IPCHANGE)			;PS2DATA = IP0
   220                          		rra					;shift until bit in C
   221                          		rr	(hl)				;shift in result
   222                          		jr	intprocex
   223                          
   224                          intIPstop:	cp	10
   225                          		jr	NZ, intprocex
   226                          
   227                          		xor	a
   228                          		ld	(rxstat), a			;set rxstat to 0
   229                          
   230                          		call	decodeKey
   231                          
   232                          
   233                          intprocex:	exx
   234                          		ex	af, af'
   235                          		ei
   236                          		ret
   237                          
   238                          ;
   239                          ;
   240                          ;
   241                          decodeKey:	ld	a, (hl)				;load scan-code
   242                          		cp	$E0				;extended?
   243                          		jr	NZ, decodeBreak
   244                          		ld	(rxextended), a
   245                          		ret
   246                          
   247                          decodeBreak:	cp	$F0				;break-key?
   248                          		jr	NZ, decodeShift			;no -> make
   249                          		ld	(rxbreak), a			;store Info
   250                          		ret
   251                          
   252                          decodeShift:	cp	CLSHIFT				;left-shift?
   253                          		jr	Z, decodeShift1
   254                          		cp	CRSHIFT
   255                          		jr	NZ, decodeStrg			;right-shift
   256                          decodeShift1:	ld	a, (rxbreak)
   257                          		xor	$f0
   258                          		ld	(rxshift), a			;save shift-info
   259                          		jr	decodeEnd			;clear break
   260                          
   261                          decodeStrg:	cp	CLSTRG
   262                          		jr	NZ, decodeChkBrk
   263                          		ld	a, (rxbreak)
   264                          		xor	$f0
   265                          		ld	(rxstrg), a			;save strg-info
   266                          		jr	decodeEnd
   267                          
   268                          decodeChkBrk:	ld	a, (rxbreak)			;break?
   269                          		or	a
   270                          		jr	Z, decodeNormal			;no
   271                          
   272                          		ld	a, (hl)				;load scan-code
   273                          		cp	ALTGR				;is it ALTGR?
   274                          		jr	NZ, decodeEnd			;no
   275                          		xor	a				;clear altgr
   276                          		ld	(rxaltgr), a
   277                          decodeEnd:	xor	a				;clear rxbreak
   278                          		ld	(rxbreak), a
   279                          		ld	(rxextended), a
   280                          		ret
   281                          
   282                          decodeNormal:	ld	c, (hl)				;load scan-code
   283                          		ld	b, 0
   284                          		ld	hl, CHARTABLE_NOSHIFT		;load normal table
   285                          		ld	a, (rxshift)
   286                          		or	a
   287                          		jr	Z, decodeMakeExt
   288                          		ld	hl, CHARTABLE_SHIFT		;load shift table
   289                          
   290                          decodeMakeExt:	ld	a, (rxextended)
   291                          		or	a
   292                          		jr	Z, decodeAltGr			;no extended
   293                          
   294                          		xor	a
   295                          		ld	(rxextended), a			;clear extended
   296                          
   297                          		ld	hl, EXT_TABLE_IND
   298                          		ld	a, (rxval)
   299                          		ld	b, 13
   300                          decodeMakeExt1:	cp	(hl)
   301                          		jr	Z, decodeMakeExt2
   302                          		inc	hl
   303                          		djnz	decodeMakeExt1
   304                          		ret
   305                          decodeMakeExt2: ld	bc, 13
   306                          		cp	ALTGR				;ALTGR-key?
   307                          		jr	NZ, decodeMake
   308                          		ld	(rxaltgr), a
   309                          		ret
   310                          
   311                          decodeAltGr:	ld	a, (rxaltgr)			;ALTGR-Presed?
   312                          		or	a
   313                          		jr	Z, decodeMake			;no
   314                          
   315                          		ld	a, (rxval)
   316                          		ld	b, 8
   317                          		ld	hl, ALTGR_TABLE_IND
   318                          decodeAltGr1:	cp 	(hl)
   319                          		jr	Z, decodeAltGr2
   320                          		inc	hl
   321                          		djnz	decodeAltGr1
   322                          		ret
   323                          decodeAltGr2:	ld	bc, 8
   324                          
   325                          decodeMake:	add	hl, bc
   326                          
   327                          		ld	b, 0
   328                          		ld	a, (rxstrg)
   329                          		or	a
   330                          		jr	Z, decodeMake1
   331                          		ld	b, 96
   332                          decodeMake1:	ld	a, (hl)
   333                          		sub	a, b
   334                          		ld	(rxval), a
   335                          		ld	(rxrdy), a
   336                          
   337                          		ret
   338                          
   339                          rxstat:		db	0
   340                          rxval:		db	0
   341                          rxrdy:		db	0
   342                          rxbreak:	db	0
   343                          rxshift:	db	0
   344                          rxstrg:		db	0
   345                          rxaltgr:	db	0
   346                          rxextended:	db	0
   347                          
   348                          
   349                          CHARTABLE_NOSHIFT:
   350                          ;		 	 00   01   02   03   04   05   06   07   08   09   0A   0B   0C   0D   0E   0F
   351                          		db	  0,   9,   0,   5,   3,   1,   2,  12,   0,  10,   8,   6,   4,TABU, '^',   0	; 00
   352                          		db     	  0,   0,   0,   0,   0, 'q', '1',   0,   0,   0, 'y', 's', 'a', 'w', '2',   0	; 10
   353                          		db	  0, 'c', 'x', 'd', 'e', '4', '3',   0,   0, ' ', 'v', 'f', 't', 'r', '5',   0	; 20
   354                          		db	  0, 'n', 'b', 'h', 'g', 'z', '6',   0,   0,   0, 'm', 'j', 'u', '7', '8',   0	; 30
   355                          		db	  0, ',', 'k', 'i', 'o', '0', '9',   0,   0, '.', '-', 'l', $94, 'p', 223,   0	; 40 	5c = \, 223 = ß
   356                          		db	  0,   0, $84,  'X',252, 180,   0,   0,   0,   0, LF, '+',   0, '#',   0,   0	; 50
   357                          		db	  0, '<',   0,   0,   0,   0,BACK,   0,   0, '1',   0, '4', '7',   0,   0,   0	; 60
   358                          		db	 '0', '.', '2', '5', '6', '8',ESC,   0,  11, '+', '3', '-', '*', '9', CLS,   0	; 70
   359                          		db	  0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0	; 80
   360                          
   361                          CHARTABLE_SHIFT:
   362                          ;		 	 00   01   02   03   04   05   06   07   08   09   0A   0B   0C   0D   0E   0F
   363                          		db	  0,   9,   0,   5,   3,   1,   2,  12,   0,  10,   8,   6,   4,TABU, $B0,   0	; 00
   364                          		db        0,   0,   0,   0,   0, 'Q', '!',   0,   0,   0, 'Y', 'S', 'A', 'W', '"',   0	; 10
   365                          		db	  0, 'C', 'X', 'D', 'E', '$', 167,   0,   0, ' ', 'V', 'F', 'T', 'R', '%',   0	; 20 	167=§
   366                          		db	  0, 'N', 'B', 'H', 'G', 'Z', '&',   0,   0,   0, 'M', 'J', 'U', '/', '(',   0	; 30
   367                          		db	  0, ';', 'K', 'I', 'O', '=', ')',   0,   0, ':', '_', 'L', $99, 'P', '?',   0	; 40
   368                          		db	  0,   0, $8E,   0, 220, '`',   0,   0,   0,   0,  LF, '*',   0, $27,   0,   0	; 50
   369                          		db	  0, '>',   0,   0,   0,   0,CDCH,   0,   0, '1',   0, CCLF, '7',   0,  0,   0	; 60
   370                          		db	'0', '.', CCDN, '5', CCRT, CCUP,  0,   0,  11, '+', '3', '-', '*', '9', 0,   0  ; 70
   371                          		db	  0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,  0,    0,   0	; 80
   372                          
   373                          ALTGR_TABLE_IND:
   374                          		db	$15	; q = @
   375                          		db	$61	; <> = |
   376                          		db	$5B	; *+ = ~
   377                          		db	$4E	; ?ß = \
   378                          		db	$3E	; 8( = [
   379                          		db	$46	; 9) = ]
   380                          		db	$3D	; 7/ = {
   381                          		db	$45	; 0= = }
   382                          
   383                          ALTGR_TABLE:	db	'@'
   384                          		db	'|'
   385                          		db	'~'
   386                          		db	$5C
   387                          		db	'['
   388                          		db	']'
   389                          		db	'{'
   390                          		db	'}'
   391                          
   392                          EXT_TABLE_IND:	db	ALTGR
   393                          		db	$4A	; /
   394                          		db	$5A	; ENTER
   395                          		db	$69	; END
   396                          		db	$6B	; LEFT
   397                          		db	$6C	; HOME
   398                          		db	$70	; INS
   399                          		db	$71	; DEL
   400                          		db	$72	; DOWN
   401                          		db	$74	; RIGHT
   402                          		db	$75	; Up
   403                          		db	$7A	; PAGE DOWN
   404                          		db	$7D	; PAGE UP
   405                          
   406                          EXT_TABLE:	db	ALTGR
   407                          		db	'/'	; NumPad division symbol
   408                          		db	LF	; ENTER
   409                          		db	CCBT	; cursor bottom with SuperFlag
   410                          		db	CCLF	; cursor left
   411                          		db	CCHM	; cursor home with SuperFLag
   412                          		db	CICH	; insert
   413                          		db	CDCH	; delete
   414                          		db	CCDN	; cursor down
   415                          		db	CCRT	; cursor right
   416                          		db	CCUP	; cursor up
   417                          		db	CCLM	; left margin with SuperFLag
   418                          		db	CCRM	; right margin with SuperFLag
   419                          ;--------------------------------------------------------------
   420                          ;--------------------------------------------------------------
   421                          ;--------------------------------------------------------------
   422                          
   423                          conout:		equ	chrout
   424                          conin:		equ	chrin
   425                          
   426                          		ENDIF
   427                          
