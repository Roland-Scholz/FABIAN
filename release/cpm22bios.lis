cpm22bios.asm:
     1                          	include "mc68681.asm"
mc68681.asm:
     1                          ;--------------------------------------------------------------------------------
     2                          ; equates for MC68681 DUART
     3                          ;
     4                          ; see ./doc/scc68681.pdf
     5                          ;--------------------------------------------------------------------------------
     6                          MODEA		equ	0
     7                          STATA		equ	1
     8                          CLOCKA		equ	1
     9                          COMMA		equ	2
    10                          RECA		equ	3
    11                          TRANSA		equ	3
    12                          IPCHANGE	equ	4
    13                          AUXCTRL		equ	4
    14                          ISR		equ	5
    15                          IMR		equ	5
    16                          CNTMSB		equ	6
    17                          CNTLSB		equ	7
    18                          MODEB		equ	8
    19                          STATB		equ	9
    20                          CLOCKB		equ	9
    21                          COMMB		equ	10
    22                          RECB		equ	11
    23                          TRANSB		equ	11
    24                          IVR		equ	12
    25                          INPORT		equ	13
    26                          OPCTRL		equ	13
    27                          STRTCNT		equ	14
    28                          OPSET		equ	14
    29                          STOPCNT		equ	15
    30                          OPRES		equ	15
    31                          
cpm22bios.asm:
     2                          
     3                          ;
     4                          ;	skeletal cbios for first level of CP/M 2.0 alteration
     5                          ;
     6                          msize		equ	64		;cp/m version memory size in kilobytes
     7                          ;
     8                          ;	"bias" is address offset from 3400h for memory systems
     9                          ;	than 16k (referred to as"b" throughout the text)
    10                          ;
    11                          bias		equ	(msize-20)*1024	;$B000
    12                          ccp		equ	3400h+bias	;base of ccp	($E400)
    13                          bdos		equ	ccp+806h	;base of bdos	($EC06)
    14                          bios		equ	ccp+1600h	;base of bios	($FA00)
    15                          cdisk		equ	0004h		;current disk number 0=a,... l5=p
    16                          iobyte		equ	0003h		;intel i/o byte
    17                          INBUFFE		equ	0DC06h
    18                          ;
    19                          	IFDEF STANDALONE
    20                          	org	bios		;origin of this program
    21                          	ENDIF
    22                          
    23                          
    24                          nsects		equ	$1600/128	;warm start sector count (44 sectors for BDOS + CCP)
    25                          ;
    26                          ;		jump vector for individual subroutines
    27                          ;
    28   000000 c38200          		jp	boot	;cold start
    29   000003 c38200          WBOOT:		jp	bwboot	;warm start
    30   000006 c3f500          CONST:		jp	bconst	;console status
    31   000009 c3fd00          CONIN:		jp	bconin	;console character in
    32   00000c c30701          CONOUT:		jp	bconout	;console character out
    33   00000f c31101          LIST:		jp	blist	;list character out
    34   000012 c31501          PUNCH:		jp	bpunch	;punch character out
    35   000015 c31701          READER:		jp	breader	;reader character out
    36   000018 c31c01          HOME:		jp	bhome	;lde head to home position
    37   00001b c32201          SELDSK:		jp	bseldsk	;select disk
    38   00001e c33601          SETTRK:		jp	bsettrk	;set track number
    39   000021 c33b01          SETSEC:		jp	bsetsec	;set sector number
    40   000024 c34301          SETDMA:		jp	bsetdma	;set dma address
    41   000027 c34801          READ:		jp	bread	;read disk
    42   00002a c37a01          WRITE:		jp	bwrite	;write disk
    43   00002d c31301          LISTST:		jp	blistst	;return list status
    44   000030 c34001          SECTRN:		jp	bsectran	;sector translate
    45                          ;
    46                          ;	dw	track
    47                          ;	fixed data tables for four-drive standard
    48                          ;	ibm-compatible 8" disks
    49                          ;
    50                          ;		disk Parameter header for disk 00
    51   000033 00000000        dpbase:		dw	0000h, 0000h
    52   000037 00000000        		dw	0000h, 0000h
    53   00003b 0e027300        		dw	dirbf, dpblk
    54   00003f 0a038e02        		dw	chk00, all00
    55                          ;		disk parameter header for disk 01
    56   000043 00000000        		dw	0000h, 0000h
    57   000047 00000000        		dw	0000h, 0000h
    58   00004b 0e027300        		dw	dirbf, dpblk
    59   00004f 1a03ad02        		dw	chk01, all01
    60                          ;		disk parameter header for disk 02
    61   000053 00000000        		dw	0000h, 0000h
    62   000057 00000000        		dw	0000h, 0000h
    63   00005b 0e027300        		dw	dirbf, dpblk
    64   00005f 2a03cc02        		dw	chk02, all02
    65                          ;		disk parameter header for disk 03
    66   000063 00000000        		dw	0000h, 0000h
    67   000067 00000000        		dw	0000h, 0000h
    68   00006b 0e027300        		dw	dirbf, dpblk
    69   00006f 3a03eb02        		dw	chk03, all03
    70                          ;
    71                          ;		sector translate vector
    72                          ;trans:		db	 1,  7, 13, 19	;sectors  1,  2,  3,  4
    73                          ;		db	25,  5, 11, 17	;sectors  5,  6,  7,  6
    74                          ;		db	23,  3,  9, 15	;sectors  9, 10, 11, 12
    75                          ;		db	21,  2,  8, 14	;sectors 13, 14, 15, 16
    76                          ;		db	20, 26,  6, 12	;sectors 17, 18, 19, 20
    77                          ;		db	18, 24,  4, 10	;sectors 21, 22, 23, 24
    78                          ;		db	16, 22		;sectors 25, 26
    79                          ;
    80                          dpblk:		;disk parameter block, common to all disks
    81   000073 1a00            		dw	26		;sectors per track
    82   000075 03              		db	3		;block shift factor
    83   000076 07              		db	7		;block mask
    84   000077 00              		db	0		;null mask
    85   000078 f200            		dw	242		;disk size-1
    86   00007a 3f00            		dw	63		;directory max
    87   00007c c0              		db	192		;alloc 0
    88   00007d 00              		db	0		;alloc 1
    89   00007e 1000            		dw	16		;check size
    90   000080 0200            		dw	2		;track offset
    91                          ;
    92                          ;	end of fixed tables
    93                          ;
    94                          ;	individual subroutines to perform each function
    95                          boot:	;simplest case is to just perform parameter initialization
    96                          
    97                          ;	ld	sp, 80h		;use space below buffer for stack
    98                          
    99                          
   100                          ;	jp	gocpm		;initialize and go to cp/m
   101                          ;
   102                          bwboot:	;simplest case is to read the disk until all sectors loaded
   103   000082 318000          		ld	sp, 80h		;use space below buffer for stack
   104                          
   105                          ;		ld	HL, 0100h
   106                          ;		ld	DE, 0101h
   107                          ;		ld	BC, 0F0FFh
   108                          ;		ld	(HL), 0
   109                          ;		ldir
   110                          
   111   000085 214a03          		ld	HL, copyright
   112   000088 cdb301          		call	printstr
   113                          
   114                          boot2:
   115                          ;		xor	a		;zero in the accum
   116   00008b 320300          		ld	(iobyte), a	;clear the iobyte
   117   00008e 320400          		ld	(cdisk), a	;select disk zero
   118                          
   119                          ;		ld	a, 3
   120                          ;opendisks:
   121                          ;		ld	(diskno), a
   122                          ;		push	AF
   123                          ;		call	cmdOpenDisk
   124                          ;		pop	AF
   125                          ;		dec	a
   126                          ;		jp	P, opendisks
   127                          
   128   000091 0e00            		ld	c, 0		;select disk 0
   129                          
   130   000093 cd2201          		call	bseldsk
   131   000096 cd1c01          		call	bhome		;go to track 00
   132                          ;		jp	gocpm
   133                          ;
   134                          
   135   000099 062c            		ld	b, nsects	;b counts * of sectors to load
   136   00009b 0e00            		ld	c, 0		;c has the current track number
   137   00009d 1600            		ld	d, 0		;d has the next sector to read
   138                          ;		note that we begin by reading track 0, sector 2 since sector 1
   139                          ;		contains the cold start loader, which is skipped in a warm start
   140   00009f 2100e4          		ld	HL, ccp		;base of cp/m (initial load point)
   141                          load1:		;load	one more sector
   142   0000a2 c5              		push	BC		;save sector count, current track
   143   0000a3 d5              		push	DE		;save next sector to read
   144   0000a4 e5              		push	HL		;save dma address
   145   0000a5 4a              		ld	c, d		;get sector address to register C
   146   0000a6 cd3b01          		call	bsetsec		;set sector address from register C
   147   0000a9 c1              		pop	BC		;recall dma address to b, C
   148   0000aa c5              		push	BC		;replace on stack for later recall
   149   0000ab cd4301          		call	bsetdma		;set dma address from b, C
   150                          ;
   151                          ;		drive set to 0, track set, sector set, dma address set
   152   0000ae cd4801          		call	bread
   153                          ;		cp	00h		;any errors?
   154   0000b1 b7              		or	a
   155   0000b2 c28200          		jp	NZ, bwboot	;retry the entire boot if an error occurs
   156                          ;
   157                          ;		no error, lde to next sector
   158   0000b5 e1              		pop	HL		;recall dma address
   159   0000b6 118000          		ld	DE, 128		;dma=dma+128
   160   0000b9 19              		add	HL, DE		;new dma address is in h, l
   161   0000ba d1              		pop	DE		;recall sector address
   162   0000bb c1              		pop	BC		;recall number of sectors remaining, and current trk
   163   0000bc 05              		dec	b		;sectors=sectors-1
   164   0000bd cad400          		jp	Z, gocpm	;transfer to cp/m if all have been loaded
   165                          ;
   166                          ;		more	sectors remain to load, check for track change
   167   0000c0 14              		inc	d
   168   0000c1 7a              		ld	a, d		;sector=26?, if so, change tracks
   169                          
   170   0000c2 e5              		push	HL
   171   0000c3 2a3d00          		ld	HL, (dpbase + $a) ;load Hl with dpblk of drive A:
   172   0000c6 be              		cp	(HL)
   173   0000c7 e1              		pop	HL
   174   0000c8 daa200          		jp	C, load1	;carry generated if sector<26
   175                          ;
   176                          ;		end of	current track,	go to next track
   177   0000cb 1600            		ld	d, 0		;begin with first sector of next track
   178   0000cd 0c              		inc	c		;track=track+1
   179                          ;
   180                          ;		save	register state, and change tracks
   181                          ;		push	BC
   182                          ;		push	DE
   183                          ;		push	HL
   184   0000ce cd3601          		call	bsettrk		;track address set from register c
   185                          ;		pop	HL
   186                          ;		pop	DE
   187                          ;		pop	BC
   188   0000d1 c3a200          		jp	load1		;for another sector
   189                          ;
   190                          ;		end of	load operation, set parameters and go to cp/m
   191                          gocpm:
   192   0000d4 3ec3            		ld	a, 0c3h		;c3 is a jp instruction
   193   0000d6 320000          		ld	(0), a		;for jp to wboot
   194   0000d9 210300          		ld	HL, WBOOT	;wboot entry point
   195   0000dc 220100          		ld	(1), HL		;set address field for jp at 0
   196                          ;
   197   0000df 320500          		ld	(5), a		;for jp to bdos
   198   0000e2 2106ec          		ld	HL, bdos	;bdos entry point
   199   0000e5 220600          		ld	(6), HL		;address field of Jump at 5 to bdos
   200                          ;
   201   0000e8 018000          		ld	BC, 80h		;default dma address is 80h
   202   0000eb cd4301          		call	bsetdma
   203                          ;
   204                          ;		ei			;enable the interrupt system
   205   0000ee 3a0400          		ld	a, (cdisk)	;get current disk number
   206   0000f1 4f              		ld	c, a		;send to the ccp
   207   0000f2 c300e4          		jp	ccp		;go to cp/m for further processing
   208                          ;
   209                          ;
   210                          ;	simple i/o handlers (must be filled in by user)
   211                          ;	in each case, the entry point is provided, with space reserved
   212                          ;	to insert your own code
   213                          ;
   214                          bconst:		;console status, return 0ffh if character ready, 00h if not
   215                          ;		ds     10h		;space for status subroutine
   216                          ;		in     00h
   217                          
   218   0000f5 db01            		in	a, (STATA)
   219   0000f7 e601            		and	a, 1
   220   0000f9 c8              		ret	Z		; zero, not ready
   221   0000fa 3eff            		ld	a, 0ffh		; $ff, ready
   222   0000fc c9              		ret
   223                          ;
   224                          bconin:	;console character into register a
   225                          ;	ds	10h		;space for input routine
   226                          ;--------------------------------------------------------------
   227                          ; get a character in A from rs232 (1)
   228                          ;
   229                          ;--------------------------------------------------------------
   230                          chrin:
   231   0000fd db01            		in	a, (STATA)
   232   0000ff e601            		and	a, 1
   233   000101 28fa            		jr	Z, chrin
   234   000103 db03            		in	a, (RECA)
   235   000105 c9              		ret
   236                          
   237                          ;		in      01h
   238                          ;		and	7fh		;strip parity bit
   239                          ;		ret
   240                          ;
   241                          chrouta:
   242   000106 4f              		ld	c, a
   243                          bconout:	;console character output from register c
   244                          ;--------------------------------------------------------------
   245                          ; output a character in A over rs232 (1)
   246                          ;
   247                          ;--------------------------------------------------------------
   248                          chrout:
   249   000107 db01            		in	a, (STATA)
   250   000109 e604            		and	a, 4
   251   00010b 28fa            		jr	Z, chrout
   252   00010d 79              		ld	a, c
   253   00010e d303            		out	(TRANSA), a
   254   000110 c9              		ret
   255                          
   256                          ;		ld	a, c		;get to accumulator
   257                          ;		ds	10h		;space for output routine
   258                          ;		out     01h
   259                          ;		ret
   260                          ;
   261                          blist:		;list character from register c
   262   000111 79              		ld	a, c	  	;character to register a
   263   000112 c9              		ret		  	;null subroutine
   264                          ;
   265                          blistst:		;return list status (0 if not ready, 1 if ready)
   266   000113 af              		xor	a	 	;0 is always ok to return
   267   000114 c9              		ret
   268                          ;
   269                          bpunch:		;punch	character from	register C
   270   000115 79              		ld	a, c		;character to register a
   271   000116 c9              		ret			;null subroutine
   272                          ;
   273                          ;
   274                          breader:	;reader character into register a from reader device
   275   000117 3e1a            		ld    a, 1ah		;enter end of file for now (replace later)
   276   000119 e67f            		ani    7fh		;remember to strip parity bit
   277   00011b c9              		ret
   278                          ;
   279                          ;
   280                          ;		i/o drivers for the disk follow
   281                          ;		for now, we will simply store the parameters away for use
   282                          ;		in the read and write	subroutines
   283                          ;
   284                          bhome:		;lde to the track 00	position of current drive
   285                          ;		translate this call into a settrk call with Parameter 00
   286   00011c 0e00            		ld    c, 0		;select track 0
   287   00011e cd3601          		call   bsettrk
   288   000121 c9              		ret			;we will lde to 00 on first read/write
   289                          ;
   290                          bseldsk:	;select disk given by register c
   291   000122 210000          		ld	HL, 0000h	;error return code
   292   000125 79              		ld	a, c
   293   000126 320902          		ld	(diskno), a
   294   000129 fe04            		cp	4		;must be between 0 and 3
   295   00012b d0              		ret	NC			;no carry if 4, 5,...
   296                          ;		disk number is in the proper range
   297                          ;		ds	10		;space for disk select
   298                          ;		compute proper disk Parameter header address
   299                          ;		ld	a, (diskno)
   300   00012c 6f              		ld	l, a		;l=disk number 0, 1, 2, 3
   301                          ;		ld	h, 0		;high order zero
   302   00012d 29              		add	HL, HL		;*2
   303   00012e 29              		add	HL, HL		;*4
   304   00012f 29              		add	HL, HL		;*8
   305   000130 29              		add	HL, HL		;*16 (size of each header)
   306   000131 113300          		ld	DE, dpbase
   307   000134 19              		add	HL, DE		;hl=,dpbase (diskno*16)
   308   000135 c9              		ret
   309                          ;
   310                          bsettrk:	;set track given by register c
   311   000136 79              		ld	a, c
   312   000137 320a02          		ld	(track), a
   313                          
   314                          ;		push	BC
   315                          ;		ld	c, 'T'
   316                          ;		call	chrout
   317                          ;		pop	BC
   318                          ;		ld	a, c
   319                          ;		call	printhex
   320                          ;		pop	BC
   321                          ;		push	BC
   322                          ;		ld	a, b
   323                          ;		call	printhex
   324                          ;		ld	a, c
   325                          ;		call	printhex
   326   00013a c9              		ret
   327                          ;
   328                          bsetsec:	;set sector given by register c
   329   00013b 79              		ld	a, c
   330   00013c 320b02          		ld	(sector), a
   331                          
   332                          ;		push	BC
   333                          ;		ld	c, 'S'
   334                          ;		call	chrout
   335                          ;		pop	BC
   336                          ;		ld	a, c
   337                          ;		jp	printhex
   338   00013f c9              		ret
   339                          ;
   340                          ;
   341                          bsectran:
   342                          	;translate the sector given by bc using the
   343                          	;translate table given by de
   344   000140 69              		ld	l, c
   345   000141 60              		ld	h, b
   346   000142 c9              		ret
   347                          
   348                          ;		xchg			;hl=.trans
   349                          ;		dad	b		;hl=.trans (sector)
   350                          ;		ld	l, m		;l=trans (sector)
   351                          ;		ld	h, 0		;hl=trans (sector)
   352                          ;		ret			;with value in hl
   353                          ;
   354                          bsetdma:	;set	dma address given by registers b and c
   355                          ;		ld	l, c		;low order address
   356                          ;		ld	h, b		;high order address
   357   000143 ed430c02        		ld	(dmaad), BC	;save the address
   358   000147 c9              		ret
   359                          
   360                          ;
   361                          bread:
   362                          		;perform read operation (usually this is similar to write
   363                          		;so we will allow space to set up read command, then use
   364                          		;common code in write)
   365                          
   366                          ;		ld	c, 'R'
   367                          ;		call	chrout
   368                          
   369                          ;		call	newline
   370                          ;;		call	cmdGetSector
   371                          ;		call	newline
   372                          
   373                          ;		ld	a, (seclen)
   374                          ;		cp	128
   375                          ;		jp	NZ, error
   376                          ;
   377                          ;		ld	HL, secdata		;copy ROM to RAM from
   378                          ;		ld	DE, (dmaad)		;to
   379                          ;		ld	BC, 128			;length
   380                          ;		ldir
   381                          
   382                          readsec:
   383   000148 3e52            		ld	a, 'R'		;read
   384   00014a cdde01          		call	serout
   385   00014d 3a0902          		ld	a, (diskno)	;disk 0
   386   000150 cdde01          		call	serout
   387   000153 3a0a02          		ld	a, (track)	;track 2
   388   000156 cdde01          		call	serout
   389   000159 3a0b02          		ld	a, (sector)	;sector 0
   390   00015c cdde01          		call	serout
   391                          
   392   00015f cdcb01          		call	serin		;check ack
   393   000162 38e4            		jr	C, readsec	;timeout?, redo
   394                          
   395                          readsec3:
   396   000164 fe41            		cp	'A'
   397   000166 2803            		jr	Z, readsec2	;ack OK
   398   000168 3e01            		ld	a, 1		;else return 1 (= unrecov. error)
   399   00016a c9              		ret
   400                          readsec2:
   401   00016b 2a0c02          		ld	hl, (dmaad)
   402   00016e 1680            		ld	d, 128
   403   000170 cdcb01          readsec1:	call	serin
   404   000173 77              		ld	(hl), a
   405   000174 23              		inc	hl
   406   000175 15              		dec	d
   407   000176 20f8            		jr	NZ, readsec1
   408                          
   409                          ;		call	newline
   410                          ;		ld	hl, (dmaad)
   411                          ;		ld	b, 128
   412                          ;		ld	d, 16
   413                          ;readsec4:	ld	a, (hl)
   414                          ;		inc	hl
   415                          ;		call	printhex
   416                          ;		call	space
   417                          ;		dec	d
   418                          ;		jr	nz, readsec5
   419                          ;		ld	d, 16
   420                          ;		call	newline
   421                          ;readsec5:	djnz	b, readsec4
   422                          
   423                          
   424   000178 af              		xor	a
   425   000179 c9              		ret
   426                          ;		jp	waitio		;to perform the actual i/o
   427                          ;
   428                          bwrite:
   429                          		;perform a write operation
   430                          		;ds	10h		;set up write command
   431                          		;ld	c, 'W'
   432                          		;call	chrout
   433                          		;out	02h
   434                          ;;		call	cmdPutSector
   435                          writesec:
   436   00017a 3e57            		ld	a, 'W'		;write
   437   00017c cdde01          		call	serout
   438   00017f 3a0902          		ld	a, (diskno)	;disk 0
   439   000182 cdde01          		call	serout
   440   000185 3a0a02          		ld	a, (track)	;track 2
   441   000188 cdde01          		call	serout
   442   00018b 3a0b02          		ld	a, (sector)	;sector 0
   443   00018e cdde01          		call	serout
   444                          
   445   000191 0680            		ld	b, 128
   446   000193 2a0c02          		ld	hl, (dmaad)
   447   000196 7e              writesec1:	ld	a, (hl)
   448   000197 23              		inc	hl
   449   000198 cdde01          		call	serout
   450   00019b 10f9            		djnz	b, writesec1
   451                          
   452   00019d cdcb01          		call	serin		;check ack
   453   0001a0 3806            		jr	C, writesec2	;timeout?, error
   454   0001a2 fe41            		cp	a, 'A'		;ack?
   455   0001a4 2002            		jr	NZ, writesec2	;no error
   456                          
   457   0001a6 af              		xor	a
   458   0001a7 c9              		ret
   459                          
   460   0001a8 3e01            writesec2:	ld	a, 1
   461   0001aa c9              		ret
   462                          
   463                          copystr:
   464   0001ab 7e              		ld	a, (HL)
   465   0001ac b7              		or	a
   466   0001ad c8              		ret	Z
   467   0001ae 12              		ld	(DE), a
   468   0001af 23              		inc	HL
   469   0001b0 13              		inc	DE
   470   0001b1 18f8            		jr	copystr
   471                          
   472                          printstr:
   473   0001b3 af              		xor	a
   474   0001b4 86              		add	a, (HL)
   475   0001b5 c8              		ret	Z
   476   0001b6 cd0601          		call	chrouta
   477   0001b9 23              		inc	HL
   478   0001ba 18f7            		jr	printstr
   479                          
   480                          space:
   481   0001bc 0e20            		ld	c, 32
   482   0001be c30701          		jp	chrout
   483                          
   484                          newline:
   485   0001c1 0e0d            		ld	c, 13
   486   0001c3 cd0701          		call	chrout
   487   0001c6 0e0a            		ld	c, 10
   488   0001c8 c30701          		jp	chrout
   489                          
   490                          ;--------------------------------------------------------------
   491                          ; get a character in A from rs232 (2)
   492                          ;
   493                          ;--------------------------------------------------------------
   494   0001cb 010000          serin:		ld	bc, 0
   495   0001ce db09            serin1:		in	a, (STATB)
   496   0001d0 e601            		and	a, 1
   497   0001d2 2007            		jr	NZ, serin2
   498   0001d4 10f8            		djnz	b, serin1
   499   0001d6 0d              		dec	c
   500   0001d7 20f5            		jr	NZ, serin1
   501   0001d9 37              		scf
   502   0001da c9              		ret
   503   0001db db0b            serin2:		in	a, (RECB)
   504   0001dd c9              		ret
   505                          
   506                          ;--------------------------------------------------------------
   507                          ; output a character in A over rs232 (1)
   508                          ;
   509                          ;--------------------------------------------------------------
   510                          serout:
   511   0001de f5              		push	AF
   512   0001df db09            serout1:	in	a, (STATB)
   513   0001e1 e604            		and	a, 4
   514   0001e3 28fa            		jr	Z, serout1
   515   0001e5 f1              		pop	AF
   516   0001e6 d30b            		out	(TRANSB), a
   517   0001e8 c9              		ret
   518                          
   519                          ;--------------------------------------------------------------
   520                          ; prints byte in A in hexadecimal format
   521                          ;--------------------------------------------------------------
   522                          printhex:
   523   0001e9 f5              		push    AF
   524   0001ea f5              		push    AF
   525   0001eb 1f              		rra
   526   0001ec 1f              		rra
   527   0001ed 1f              		rra
   528   0001ee 1f              		rra
   529   0001ef cdf801          		call    printnib
   530   0001f2 f1              		pop     AF
   531   0001f3 cdf801          		call    printnib
   532   0001f6 f1              		pop     AF
   533   0001f7 c9              		ret
   534                          printnib:
   535   0001f8 e60f            		and     0fh
   536   0001fa fe0a            		cp      0ah
   537   0001fc 3802            		jr      C, printnib1
   538   0001fe c607            		add     a, 07h
   539                          printnib1:
   540   000200 c630            		add     a, '0'
   541                          print:
   542   000202 c5              		push    BC
   543   000203 4f              		ld      c, a
   544   000204 cd0701          		call    chrout
   545   000207 c1              		pop     BC
   546   000208 c9              		ret
   547                          
   548                          ;
   549                          ;waitio:	;enter	here from read	and write to perform the actual i/o
   550                          ;		operation. return a 00h in register a if the operation completes
   551                          ;		properly, and 0lh if an error occurs during the read or write
   552                          ;
   553                          ;		in this case, we have saved the disk number in 'diskno' (0, 1)
   554                          ;				the track number in 'track' (0-76)
   555                          ;				the sector number in 'sector' (1-26)
   556                          ;				the dma address in 'dmaad' (0-65535)
   557                          ;		ds	256		;space reserved for i/o drivers
   558                          ;		ld	a, 1		;error condition
   559                          ;		ret			;replaced when filled-in
   560                          ;
   561                          ;		the remainder of the cbios is reserved uninitialized
   562                          ;		data area, and does not need to be a Part of the
   563                          ;		system	memory image (the space must be available,
   564                          ;		however, between"begdat" and"enddat").
   565                          ;
   566   000209 00              diskno:		ds	1		;disk number 0-15
   567   00020a 00              track:		ds	1		;two bytes for expansion
   568   00020b 00              sector:		ds	1		;two bytes for expansion
   569   00020c 0000            dmaad:		ds	2		;direct memory address
   570                          ;
   571                          ;		scratch ram area for bdos use
   572                          begdat		equ	$	 	;beginning of data area
   573   00020e 0000000000000000dirbf:		ds	128	 	;scratch directory area
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
   574   00028e 0000000000000000all00:		ds	31	 	;allocation vector 0
                0000000000000000
                0000000000000000
                00000000000000  
   575   0002ad 0000000000000000all01:		ds	31	 	;allocation vector 1
                0000000000000000
                0000000000000000
                00000000000000  
   576   0002cc 0000000000000000all02:		ds	31	 	;allocation vector 2
                0000000000000000
                0000000000000000
                00000000000000  
   577   0002eb 0000000000000000all03:		ds	31	 	;allocation vector 3
                0000000000000000
                0000000000000000
                00000000000000  
   578   00030a 0000000000000000chk00:		ds	16		;check vector 0
                0000000000000000
   579   00031a 0000000000000000chk01:		ds	16		;check vector 1
                0000000000000000
   580   00032a 0000000000000000chk02:		ds	16	 	;check vector 2
                0000000000000000
   581   00033a 0000000000000000chk03:		ds	16	 	;check vector 3
                0000000000000000
   582                          ;
   583                          enddat		equ	$	 	;end of data area
   584                          datsiz		equ	$-begdat;	;size of data area
   585                          
   586                          
   587                          		IFDEF NOEXCLUDE
   588                          cmdOpenDisk:
   589                          		ld	a, (diskno)
   590                          		call	bin2deca
   591                          		ld	HL, opendiskno
   592                          		call	dec2disp
   593                          		ld	HL, (opendiskno)
   594                          		ld	(opendiskno1), HL
   595                          
   596                          		ld	HL, opendisk
   597                          		jp	sendCommand
   598                          
   599                          
   600                          cmdPutSector:
   601                          		ld	a, (diskno)		; write diskno
   602                          		call	bin2deca		; in paintext
   603                          		ld	HL, putsdisk		; to getsdisk
   604                          		call	dec2disp
   605                          		ld	a, (track)		; write track
   606                          		call	bin2deca
   607                          		ld	HL, putstrack
   608                          		call	dec2disp
   609                          		ld	a, (sector)		; write sector
   610                          		call	bin2deca
   611                          		ld	HL, putssector
   612                          		call	dec2disp
   613                          
   614                          		ld	HL, (dmaad)		;128 from (dmadat)
   615                          		ld	DE, secdata		;to secdata
   616                          		ld	BC, 128			;set length length
   617                          		ld	(seclen), BC
   618                          		ldir
   619                          
   620                          		ld	DE, seclen
   621                          		ld	HL, putsdata-2
   622                          		call	codeBase64
   623                          		ld	HL, 00a0dh
   624                          		ld	(putsdata-2), HL
   625                          
   626                          		ld	HL, putsector
   627                          		jp	sendCommand
   628                          
   629                          
   630                          cmdGetSector:
   631                          		ld	a, (diskno)		; write diskno
   632                          		call	bin2deca		; in paintext
   633                          		ld	HL, getsdisk		; to getsdisk
   634                          		call	dec2disp
   635                          		ld	a, (track)		; write track
   636                          		call	bin2deca
   637                          		ld	HL, getstrack
   638                          		call	dec2disp
   639                          		ld	a, (sector)		; write sector
   640                          		call	bin2deca
   641                          		ld	HL, getssector
   642                          		call	dec2disp
   643                          
   644                          		ld	HL, getsector		; send the sector-command
   645                          		call	sendCommand
   646                          
   647                          ;		ld	a, h
   648                          ;		call	printhex
   649                          ;		ld	a, l
   650                          ;		call	printhex
   651                          ;		ld	a, d
   652                          ;		call	printhex
   653                          ;		ld	a, e
   654                          ;		call	printhex
   655                          ;		ld	c, 32
   656                          ;		call	chrout
   657                          
   658                          		ex	DE, HL			;DE = OK + 5
   659                          		dec	HL			;HL - 4
   660                          		dec	HL
   661                          		dec	HL
   662                          		dec	HL
   663                          		xor	a
   664                          		ld	(HL), a
   665                          		ld	a, 172			;decode from
   666                          		dec	HL
   667                          		ld	(HL), a
   668                          		ld	DE, seclen		;into seclen
   669                          		jp	decodeBase64
   670                          
   671                          
   672                          
   673                          sendCommand:
   674                          		push	HL
   675                          		push	HL
   676                          
   677                          		ld	HL, atstatus		;status of connection
   678                          		call	writeesp
   679                          		ld	a, (line + 21)
   680                          		cp	'3'
   681                          		jp	Z, sendCommand1		;if 3 send command
   682                          
   683                          sendCommand3:
   684                          		ld	HL, connect
   685                          		call	writeesp
   686                          		jr	NC, sendCommand1
   687                          
   688                          enterIP:
   689                          		ld	HL, iptext
   690                          		call	printstr
   691                          		call	getline
   692                          		ld	HL, line
   693                          		ld	DE, connectip
   694                          		call	copystr
   695                          
   696                          		dec	DE
   697                          		ld	HL, porttext
   698                          		call	copystr
   699                          		ld	(DE), a
   700                          ;		jp	error
   701                          		jr	sendCommand3
   702                          
   703                          sendCommand1:
   704                          		pop	HL
   705                          		call	strlen			;length in DE
   706                          ;		ld	a, d
   707                          ;		call	printhex
   708                          ;		ld	a, e
   709                          ;		call	printhex
   710                          		call	bin2dec			;e in hex to a in dec
   711                          		ld	HL, cipsendlenl		;prite dec to display
   712                          		call	dec2disp
   713                          		ld	HL, 03030h		;"00" into
   714                          		ld	(cipsendlenh), HL
   715                          		ld	a, d
   716                          		or	a
   717                          		jr	Z, sendCommand2
   718                          		ld	HL, 03230h		;02
   719                          		ld	(cipsend+11), HL
   720                          		ld	HL, 03638h		;86
   721                          		ld	(cipsend+13), HL
   722                          
   723                          sendCommand2:
   724                          		ld	HL, cipsend
   725                          		call	writeesp
   726                          		jr	NC, sendCommand4
   727                          		pop	HL
   728                          		xor	a
   729                          		call	printhex
   730                          		jr	sendCommand
   731                          
   732                          
   733                          ;		call	prtline
   734                          sendCommand4:
   735                          		call	espin
   736                          		call	espin
   737                          
   738                          
   739                          		pop	HL
   740                          		push	HL
   741                          		call	writeesp
   742                          		pop	HL
   743                          		ret
   744                          
   745                          ;		ret	NC
   746                          ;		ld	a, 1
   747                          ;		call	printhex
   748                          ;		jr	sendCommand
   749                          
   750                          
   751                          error:
   752                          		ld	b, 0
   753                          e1:		djnz	e1
   754                          		ld	a, 080h			;OP7 = HIGH
   755                          		out	(OPRES), a
   756                          		jp	0
   757                          
   758                          connect:	DB	"AT+CIPSTART=\"TCP\",\""
   759                          connectip:	DB	"192.168.178.22"
   760                          		DB	"\","
   761                          connectport:	DB	"4434",13,10,0,0,0
   762                          
   763                          cipsend:	DB	"AT+CIPSEND="
   764                          cipsendlenh:	DB	"00"
   765                          cipsendlenl:	DB	"xx",13,10,0
   766                          
   767                          opendisk:	DB	"GET /disk?func=open&disk="
   768                          opendiskno:	DB	"00"
   769                          		DB	"&filename=disk"
   770                          opendiskno1:	DB	"00.dsk HTTP/1.0",13,10,13,10,0
   771                          
   772                          getsector:	DB	"GET /sectordata?disk="
   773                          getsdisk:	DB	"00"
   774                          		DB	"&track="
   775                          getstrack:	DB	"00"
   776                          		DB	"&sector="
   777                          getssector:	DB	"00"
   778                          		DB	" HTTP/1.1",13,10
   779                          		DB	"Host: roland.z80",13,10,13,10,0
   780                          
   781                          putsector:	DB	"PUT /sectordata?disk="
   782                          putsdisk:	DB	"00"
   783                          		DB	"&track="
   784                          putstrack:	DB	"00"
   785                          		DB	"&sector="
   786                          putssector:	DB	"00"
   787                          		DB	" HTTP/1.0",13,10
   788                          		DB	"Host: roland.z80",13,10
   789                          		DB	"Accept: text/plain",13,10
   790                          		DB	"Content-Length: 172",13,10,13,10
   791                          putsdata:	DS	172
   792                          		DB	0
   793                          atstatus:	DB	"AT+CIPSTATUS",13,10,0
   794                          iptext:		DB	13,10,"IP:",0
   795                          porttext:	DB	"\",4434",13,10,0
   796                          
   797                          
   798                          ;--------------------------------------------------------------
   799                          ; DE: Pointer to input-area
   800                          ; HL: Base64 coded output input
   801                          ;
   802                          ; area: 2-byte          len
   803                          ;       xxx-byte        data
   804                          ;--------------------------------------------------------------
   805                          codeBase64:
   806                          		push    HL              ; IY = ptr to out-length
   807                          		pop     IY
   808                          		inc     HL
   809                          		inc     HL
   810                          		push    HL              ; save ptr to out-data
   811                          
   812                          		ld      a, (DE)
   813                          		neg
   814                          		ld      c, a
   815                          		inc     DE
   816                          		ld      a, (DE)
   817                          		neg
   818                          		ld      b, a
   819                          		inc     DE              ; BC = in-len
   820                          		push    BC
   821                          		pop     IX
   822                          		add     IX, DE
   823                          
   824                          		ld      c, 0
   825                          
   826                          code_loop1:
   827                          		ex      DE, HL          ;switch to input-pointer
   828                          		ld      a, c
   829                          		inc     c
   830                          		and     3
   831                          
   832                          		jr      NZ, code1
   833                          
   834                          		ld      a, (HL)
   835                          		rra
   836                          		rra
   837                          		and     00111111b
   838                          		call    codeB64
   839                          		jr      code_loop
   840                          
   841                          code1:
   842                          		dec     a
   843                          		jr      NZ, code2
   844                          		ld      a, (HL)
   845                          		rla
   846                          		rla
   847                          		rla
   848                          		rla
   849                          		and     00110000b
   850                          		ld      b, a
   851                          		inc     HL
   852                          		ld      a, (HL)
   853                          		rra
   854                          		rra
   855                          		rra
   856                          		rra
   857                          		and     %00001111
   858                          		or      b
   859                          		call    codeB64
   860                          		jr      code_loop
   861                          
   862                          code2:
   863                          		dec     a
   864                          		jr      NZ, code3
   865                          		ld      a, (HL)
   866                          		rla
   867                          		rla
   868                          		and     00111100b
   869                          		ld      b, a
   870                          		inc     HL
   871                          		ld      a, (HL)
   872                          		rlca
   873                          		rlca
   874                          		and     00000011b
   875                          		or      b
   876                          		call    codeB64
   877                          
   878                          code_loop:
   879                          		ex      DE, HL                  ;switch to output-pointer
   880                          		ld      (HL), a                 ;store base64 symbol
   881                          		inc     HL
   882                          		jr      code_loop1
   883                          
   884                          code3:
   885                          		ld      a, (HL)
   886                          		inc     HL
   887                          		and     00111111b
   888                          		call    codeB64
   889                          
   890                          		ex      DE, HL                  ;switch HL to output-pointer
   891                          		ld      (HL), a                 ;store base64 symbol
   892                          		inc     HL
   893                          
   894                          		push    DE
   895                          		push    HL
   896                          		ex      DE, HL
   897                          		push    IX
   898                          		pop     DE
   899                          		sbc     HL, DE
   900                          		ld      b, l
   901                          		pop     HL
   902                          		pop     DE
   903                          
   904                          		jp      M, code_loop1
   905                          		push    HL
   906                          code3a:
   907                          		jr      Z, code3b
   908                          		dec     HL
   909                          		ld      (HL), '='
   910                          		djnz    code3a
   911                          code3b:
   912                          		pop     HL
   913                          		pop     DE
   914                          		sbc     HL, DE
   915                          		ld      (IY), l
   916                          		ld      (IY + 1), h
   917                          		ret
   918                          
   919                          
   920                          
   921                          ;--------------------------------------------------------------
   922                          ; DE: Pointer to output-area
   923                          ; HL: Base64 coded input
   924                          ;
   925                          ; area: 2-byte          len
   926                          ;       xxx-byte        data
   927                          ;--------------------------------------------------------------
   928                          decodeBase64:
   929                          		ld      c, (HL)                 ; load lo, hi length
   930                          		inc     HL
   931                          		ld      b, (HL)
   932                          		inc     HL
   933                          		push    BC
   934                          		exx
   935                          		pop     BC                      ; put length in BC'
   936                          		exx
   937                          
   938                          		ld      c, 0
   939                          
   940                          		push    DE                      ; save out-ptr on stack
   941                          		inc     DE                      ; skip-out-length
   942                          		inc     DE
   943                          		push    DE                      ; save it, too
   944                          
   945                          decode_loop1:
   946                          		call    decodeB64               ; load in-byte in (HL) and decode into a
   947                          		ld      b, a
   948                          		ld      a, c
   949                          		inc     c
   950                          		jr      C, decode_loop2         ; if decodeB64 has set Carry, input was '='
   951                          
   952                          		inc     HL                      ; increment input-pointer
   953                          		ex      DE, HL                  ; switch to output-pointer
   954                          		and     3
   955                          
   956                          		jr      NZ, decode1
   957                          
   958                          		ld      a, b
   959                          		rla
   960                          		rla
   961                          		and     11111100b
   962                          		ld      (HL), a
   963                          		jr      decode_loop
   964                          
   965                          decode1:
   966                          		dec     a
   967                          		jr      NZ, decode2
   968                          		ld      a, b
   969                          		rra
   970                          		rra
   971                          		rra
   972                          		rra
   973                          		and     00000011b
   974                          		or      (HL)
   975                          		ld      (HL), a
   976                          		inc     HL
   977                          		ld      a, b
   978                          		rla
   979                          		rla
   980                          		rla
   981                          		rla
   982                          		and     11110000b
   983                          		ld      (HL), a
   984                          		jr      decode_loop
   985                          
   986                          decode2:
   987                          		dec     a
   988                          		jr      NZ, decode3
   989                          		ld      a, b
   990                          		rra
   991                          		rra
   992                          		and     00001111b
   993                          		or      (HL)
   994                          		ld      (HL), a
   995                          		inc     HL
   996                          		ld      a, b
   997                          		rrca
   998                          		rrca
   999                          		and     11000000b
  1000                          		ld      (HL), a
  1001                          		jr      decode_loop
  1002                          
  1003                          decode3:
  1004                          		ld      a, b
  1005                          		or      (HL)
  1006                          		ld      (HL), a
  1007                          		inc     HL
  1008                          
  1009                          decode_loop:
  1010                          		ex      DE, HL                  ; switch to input-pointer
  1011                          
  1012                          		exx
  1013                          		dec     BC
  1014                          		ld      a, b
  1015                          		or      c
  1016                          		exx
  1017                          		jr      NZ, decode_loop1
  1018                          
  1019                          decode_loop2:
  1020                          		ex      DE, HL                  ; switch to output-pointer
  1021                          		pop     DE                      ; get start of output
  1022                          
  1023                          		or      a                       ; reset carry!
  1024                          		sbc     HL, DE                  ; len = end - start
  1025                          		pop     DE                      ; load address of output-len
  1026                          		ex      DE, HL                  ; switch to output-len
  1027                          		ld      (HL), E                 ; save len
  1028                          		inc     HL
  1029                          		ld      (HL), D
  1030                          		ret
  1031                          
  1032                          
  1033                          
  1034                          decodeB64:
  1035                          		ld      a, (HL)
  1036                          
  1037                          		cp      '='
  1038                          		jr      NZ, decodeB64e
  1039                          		xor     a
  1040                          		scf
  1041                          		ret
  1042                          decodeB64e:
  1043                          		cp      '+'
  1044                          		jr      NZ, decodeB64a
  1045                          		ld      a, 62
  1046                          		ret
  1047                          decodeB64a:
  1048                          		cp      '/'
  1049                          		jr      NZ, decodeB64b
  1050                          		ld      a, 63
  1051                          		ret
  1052                          decodeB64b:
  1053                          		cp      ':'
  1054                          		jr      NC, decodeB64c          ; not 0-9?
  1055                          		add     a, 4                    ; '0' = 48 -> 52
  1056                          		ret
  1057                          decodeB64c:
  1058                          		cp      'Z'+1
  1059                          		jr      NC, decodeB64d          ; not A-Z?
  1060                          		sub     'A'                     ; 'A' = 65 -> 0
  1061                          		ret
  1062                          decodeB64d:                             	; then a-z
  1063                          		sub     71
  1064                          		ret
  1065                          
  1066                          
  1067                          
  1068                          codeB64:
  1069                          		cp      26
  1070                          		jr      NC, codeB64a
  1071                          		add     a, 'A'                     ; < 0-25
  1072                          		ret
  1073                          codeB64a:
  1074                          		cp      52
  1075                          		jr      NC, codeB64b
  1076                          		add     a, 71
  1077                          		ret
  1078                          codeB64b:
  1079                          		cp      62
  1080                          		jr      NC, codeB64c
  1081                          		sub     4
  1082                          		ret
  1083                          codeB64c:
  1084                          		cp      62
  1085                          		jr      NZ, codeB64d
  1086                          		ld      a, '+'
  1087                          		ret
  1088                          codeB64d:
  1089                          		ld      a, '/'
  1090                          		ret
  1091                          ;
  1092                          ;
  1093                          ;
  1094                          dec2disp:	push    af
  1095                          		rrca
  1096                          		rrca
  1097                          		rrca
  1098                          		rrca
  1099                          		call    dec2nibble
  1100                          		inc	HL
  1101                          		pop     af
  1102                          
  1103                          dec2nibble:   	or      0xf0
  1104                          		daa
  1105                          		add     a,0xa0
  1106                          		adc     a,0x40
  1107                          		ld	(HL), a
  1108                          		ret
  1109                          
  1110                          
  1111                          bin2deca:	ld	e, a
  1112                          bin2dec:	ld	b, 8
  1113                          		xor	a
  1114                          bin2dec1:	rlc	e
  1115                          		adc	a, a
  1116                          		daa
  1117                          		djnz	bin2dec1
  1118                          		ret
  1119                          
  1120                          
  1121                          
  1122                          strlen:		ld	DE, 0
  1123                          strlen1:
  1124                          		ld	a, (HL)
  1125                          		or	a
  1126                          		ret	z
  1127                          		inc	DE
  1128                          		inc	HL
  1129                          		jr	strlen1
  1130                          
  1131                          
  1132                          
  1133                          getesp:
  1134                          		ld	HL, line
  1135                          getesp2:
  1136                          		push	HL
  1137                          		pop	DE		; DE = HL
  1138                          getesp1:
  1139                          		call	espin
  1140                          		ld	(HL), a
  1141                          		inc	HL
  1142                          		cp	10
  1143                          		jr	NZ, getesp1	; read until EOL
  1144                          
  1145                          		ex	DE, HL
  1146                          		ld	a, (HL)
  1147                          		inc	HL
  1148                          		ld	b, (HL)
  1149                          		inc	HL
  1150                          		inc	HL
  1151                          		inc	HL
  1152                          		inc	HL
  1153                          		ld	c, (HL)
  1154                          		ex	DE, HL
  1155                          		cp	'O'		; "OK"?
  1156                          		jr	Z, getespK
  1157                          		cp	'E'		; "ERR"?
  1158                          		jr	Z, getespR
  1159                          		ld	a, c
  1160                          		cp	'F'		; "FAIL"?
  1161                          		jr	NZ, getesp2
  1162                          		ex	DE, HL
  1163                          		inc	HL
  1164                          		ld	a, (HL)
  1165                          		ex	DE, HL
  1166                          		cp	'A'
  1167                          		jr	Z, getesperr
  1168                          		jr	getesp2
  1169                          
  1170                          getespK:	ld	a, b
  1171                          		cp	'K'
  1172                          		jr	NZ, getesp2
  1173                          		xor	a
  1174                          		ld	(HL), a
  1175                          		ret
  1176                          
  1177                          getespR:	ld	a, b
  1178                          		cp	'R'
  1179                          		jr	NZ, getesp2
  1180                          getesperr:	xor	a
  1181                          		ld	(HL), a
  1182                          		scf
  1183                          		ret
  1184                          
  1185                          getespE:	ld	a, b
  1186                          		cp	'E'
  1187                          		jr	NZ, getesp2
  1188                          		jr	getesperr
  1189                          writeesp:
  1190                          		ld	a, (HL)
  1191                          		or	a
  1192                          		jr	Z, getesp
  1193                          		call	espout
  1194                          ;		call	chrout
  1195                          		inc	HL
  1196                          		jr	writeesp
  1197                          
  1198                          putesp:
  1199                          		ld	HL, line
  1200                          putesp1:
  1201                          		ld	a, (HL)
  1202                          		cp	10
  1203                          		jr	NZ, putesp2
  1204                          		ld	a, 13
  1205                          		call	espout
  1206                          		ld	a, 10
  1207                          		jp	espout
  1208                          putesp2:	call	espout
  1209                          		inc	HL
  1210                          		jr	putesp1
  1211                          
  1212                          
  1213                          
  1214                          getline:	ld	HL, line-1
  1215                          getline1:
  1216                          		inc	HL
  1217                          		call	chrin
  1218                          		ld	(HL), a
  1219                          		call	chrouta
  1220                          ;		ld	a, c
  1221                          		cp	a, 10
  1222                          		jr	NZ, getline1
  1223                          		xor	a
  1224                          		ld	(HL), a
  1225                          		ret
  1226                          
  1227                          prtline:
  1228                          		ld	HL, line
  1229                          prtline1:
  1230                          		ld	a, (HL)
  1231                          		inc	HL
  1232                          		or	a
  1233                          		ret	Z
  1234                          		call	chrouta
  1235                          		jr	prtline1
  1236                          
  1237                          ;--------------------------------------------------------------
  1238                          ; get a character in A from rs232 (2)
  1239                          ;
  1240                          ;--------------------------------------------------------------
  1241                          espin:
  1242                          		in	a, (STATB)
  1243                          		and	a, 1
  1244                          		jr	Z, espin
  1245                          		in	a, (RECB)
  1246                          		ret
  1247                          
  1248                          espstat:	in	a, (STATB)
  1249                          		and	a, 1
  1250                          		ret
  1251                          
  1252                          ;--------------------------------------------------------------
  1253                          ; output a character in A over rs232 (2)
  1254                          ;
  1255                          ;--------------------------------------------------------------
  1256                          espout:
  1257                          		push	AF
  1258                          espout1:	in	a, (STATB)
  1259                          		and	a, 4
  1260                          		jr	Z, espout1
  1261                          		pop	AF
  1262                          		out	(TRANSB), a
  1263                          		ret
  1264                          
  1265                          line:		DS	300
  1266                          
  1267                          seclen:		DS	2
  1268                          secdata:	DS	128
  1269                          		ENDIF
  1270                          
  1271   00034a 1b5b6d0d        copyright:	DB	27, "[m", 13
  1272   00034e 5a383020        		DB	"Z80 "
  1273   000352 1b5b33356d46611b		DB	27, "[35mFa", 27, "[m"
                5b6d            
  1274   00035c 62756c6f757320  		DB	"bulous "
  1275   000363 1b5b33326d42691b		DB	27, "[32mBi", 27, "[m"
                5b6d            
  1276   00036d 6e61727920      		DB	"nary "
  1277   000372 1b5b33366d416e1b		DB	27, "[36mAn", 27, "[m"
                5b6d            
  1278   00037c 6968696c61746f72		DB	"ihilator",13
                0d              
  1279   000385 43502f4d20322e32		DB	"CP/M 2.2 Copyright 1979 (c) by Digital Research"
                20436f7079726967
                6874203139373920
                2863292062792044
                69676974616c2052
                65736561726368  
  1280   0003b4 00              		DB	0
  1281                          
  1282                          
  1283                          
  1284                          
  1285                          ;	end
  1286                          
