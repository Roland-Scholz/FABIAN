cpm22bios.asm:
     1                          MODEA		equ 0
     2                          STATA		equ 1
     3                          CLOCKA		equ 1
     4                          COMMA		equ 2
     5                          RECA		equ 3
     6                          TRANSA		equ 3
     7                          IPCHANGE	equ 4
     8                          AUXCTRL		equ 4
     9                          ISR		equ 5
    10                          IMR		equ 5
    11                          CNTMSB		equ 6
    12                          CNTLSB		equ 7
    13                          MODEB		equ 8
    14                          STATB		equ 9
    15                          CLOCKB		equ 9
    16                          COMMB		equ 10
    17                          RECB		equ 11
    18                          TRANSB		equ 11
    19                          IVR		equ 12
    20                          INPORT		equ 13
    21                          OPCTRL		equ 13
    22                          STRTCNT		equ 14
    23                          OPSET		equ 14
    24                          STOPCNT		equ 15
    25                          OPRES		equ 15
    26                          ;
    27                          ;	skeletal cbios for first level of CP/M 2.0 alteration
    28                          ;
    29                          msize		equ	64		;cp/m version memory size in kilobytes
    30                          ;
    31                          ;	"bias" is address offset from 3400h for memory systems
    32                          ;	than 16k (referred to as"b" throughout the text)
    33                          ;
    34                          bias		equ	(msize-20)*1024
    35                          ccp		equ	3400h+bias	;base of ccp
    36                          bdos		equ	ccp+806h	;base of bdos
    37                          bios		equ	ccp+1600h	;base of bios
    38                          cdisk		equ	0004h		;current disk number 0=a,... l5=p
    39                          iobyte		equ	0003h		;intel i/o byte
    40                          INBUFFE		equ	0DC06h
    41                          ;
    42                          	IFDEF STANDALONE
    43                          	org	bios		;origin of this program
    44                          	ENDIF
    45                          
    46                          
    47                          ;nsects		equ	(3400h+bias-ccp)/128	;warm start sector count
    48                          nsects		equ	44
    49                          ;nsects		equ	17
    50                          ;
    51                          ;		jump vector for individual subroutines
    52                          ;
    53   000000 c38200          		jp	boot	;cold start
    54   000003 c38200          WBOOT:		jp	bwboot	;warm start
    55   000006 c3f100          CONST:		jp	bconst	;console status
    56   000009 c3f900          CONIN:		jp	bconin	;console character in
    57   00000c c30301          CONOUT:		jp	bconout	;console character out
    58   00000f c30d01          LIST:		jp	blist	;list character out
    59   000012 c31101          PUNCH:		jp	bpunch	;punch character out
    60   000015 c31301          READER:		jp	breader	;reader character out
    61   000018 c31801          HOME:		jp	bhome	;lde head to home position
    62   00001b c31e01          SELDSK:		jp	bseldsk	;select disk
    63   00001e c33201          SETTRK:		jp	bsettrk	;set track number
    64   000021 c33701          SETSEC:		jp	bsetsec	;set sector number
    65   000024 c33f01          SETDMA:		jp	bsetdma	;set dma address
    66   000027 c34401          READ:		jp	bread	;read disk
    67   00002a c37601          WRITE:		jp	bwrite	;write disk
    68   00002d c30f01          LISTST:		jp	blistst	;return list status
    69   000030 c33c01          SECTRN:		jp	bsectran	;sector translate
    70                          ;
    71                          ;	dw	track
    72                          ;	fixed data tables for four-drive standard
    73                          ;	ibm-compatible 8" disks
    74                          ;
    75                          ;		disk Parameter header for disk 00
    76   000033 00000000        dpbase:		dw	0000h, 0000h
    77   000037 00000000        		dw	0000h, 0000h
    78   00003b 0a027300        		dw	dirbf, dpblk
    79   00003f 06038a02        		dw	chk00, all00
    80                          ;		disk parameter header for disk 01
    81   000043 00000000        		dw	0000h, 0000h
    82   000047 00000000        		dw	0000h, 0000h
    83   00004b 0a027300        		dw	dirbf, dpblk
    84   00004f 1603a902        		dw	chk01, all01
    85                          ;		disk parameter header for disk 02
    86   000053 00000000        		dw	0000h, 0000h
    87   000057 00000000        		dw	0000h, 0000h
    88   00005b 0a027300        		dw	dirbf, dpblk
    89   00005f 2603c802        		dw	chk02, all02
    90                          ;		disk parameter header for disk 03
    91   000063 00000000        		dw	0000h, 0000h
    92   000067 00000000        		dw	0000h, 0000h
    93   00006b 0a027300        		dw	dirbf, dpblk
    94   00006f 3603e702        		dw	chk03, all03
    95                          ;
    96                          ;		sector translate vector
    97                          ;trans:		db	 1,  7, 13, 19	;sectors  1,  2,  3,  4
    98                          ;		db	25,  5, 11, 17	;sectors  5,  6,  7,  6
    99                          ;		db	23,  3,  9, 15	;sectors  9, 10, 11, 12
   100                          ;		db	21,  2,  8, 14	;sectors 13, 14, 15, 16
   101                          ;		db	20, 26,  6, 12	;sectors 17, 18, 19, 20
   102                          ;		db	18, 24,  4, 10	;sectors 21, 22, 23, 24
   103                          ;		db	16, 22		;sectors 25, 26
   104                          ;
   105                          dpblk:		;disk parameter block, common to all disks
   106   000073 1a00            		dw	26		;sectors per track
   107   000075 03              		db	3		;block shift factor
   108   000076 07              		db	7		;block mask
   109   000077 00              		db	0		;null mask
   110   000078 f200            		dw	242		;disk size-1
   111   00007a 3f00            		dw	63		;directory max
   112   00007c c0              		db	192		;alloc 0
   113   00007d 00              		db	0		;alloc 1
   114   00007e 1000            		dw	16		;check size
   115   000080 0200            		dw	2		;track offset
   116                          ;
   117                          ;	end of fixed tables
   118                          ;
   119                          ;	individual subroutines to perform each function
   120                          boot:	;simplest case is to just perform parameter initialization
   121                          
   122                          ;	ld	sp, 80h		;use space below buffer for stack
   123                          
   124                          
   125                          ;	jp	gocpm		;initialize and go to cp/m
   126                          ;
   127                          bwboot:	;simplest case is to read the disk until all sectors loaded
   128   000082 318000          		ld	sp, 80h		;use space below buffer for stack
   129                          
   130                          ;		ld	HL, 0100h
   131                          ;		ld	DE, 0101h
   132                          ;		ld	BC, 0F0FFh
   133                          ;		ld	(HL), 0
   134                          ;		ldir
   135                          
   136   000085 214603          		ld	HL, copyright
   137   000088 cdaf01          		call	printstr
   138                          
   139                          boot2:
   140                          ;		xor	a		;zero in the accum
   141   00008b 320300          		ld	(iobyte), a	;clear the iobyte
   142   00008e 320400          		ld	(cdisk), a	;select disk zero
   143                          
   144                          ;		ld	a, 3
   145                          ;opendisks:
   146                          ;		ld	(diskno), a
   147                          ;		push	AF
   148                          ;		call	cmdOpenDisk
   149                          ;		pop	AF
   150                          ;		dec	a
   151                          ;		jp	P, opendisks
   152                          
   153   000091 0e00            		ld	c, 0		;select disk 0
   154                          
   155   000093 cd1e01          		call	bseldsk
   156   000096 cd1801          		call	bhome		;go to track 00
   157                          ;		jp	gocpm
   158                          ;
   159   000099 062c            		ld	b, nsects	;b counts * of sectors to load
   160   00009b 0e00            		ld	c, 0		;c has the current track number
   161   00009d 1600            		ld	d, 0		;d has the next sector to read
   162                          ;		note that we begin by reading track 0, sector 2 since sector 1
   163                          ;		contains the cold start loader, which is skipped in a warm start
   164   00009f 2100e4          		ld	HL, ccp		;base of cp/m (initial load point)
   165                          load1:		;load	one more sector
   166   0000a2 c5              		push	BC		;save sector count, current track
   167   0000a3 d5              		push	DE		;save next sector to read
   168   0000a4 e5              		push	HL		;save dma address
   169   0000a5 4a              		ld	c, d		;get sector address to register C
   170   0000a6 cd3701          		call	bsetsec		;set sector address from register C
   171   0000a9 c1              		pop	BC		;recall dma address to b, C
   172   0000aa c5              		push	BC		;replace on stack for later recall
   173   0000ab cd3f01          		call	bsetdma		;set dma address from b, C
   174                          ;
   175                          ;		drive set to 0, track set, sector set, dma address set
   176   0000ae cd4401          		call	bread
   177                          ;		cp	00h		;any errors?
   178   0000b1 b7              		or	a
   179   0000b2 c28200          		jp	NZ, bwboot	;retry the entire boot if an error occurs
   180                          ;
   181                          ;		no error, lde to next sector
   182   0000b5 e1              		pop	HL		;recall dma address
   183   0000b6 118000          		ld	DE, 128		;dma=dma+128
   184   0000b9 19              		add	HL, DE		;new dma address is in h, l
   185   0000ba d1              		pop	DE		;recall sector address
   186   0000bb c1              		pop	BC		;recall number of sectors remaining, and current trk
   187   0000bc 05              		dec	b		;sectors=sectors-1
   188   0000bd cad000          		jp	Z, gocpm		;transfer to cp/m if all have been loaded
   189                          ;
   190                          ;		more	sectors remain to load, check for track change
   191   0000c0 14              		inc	d
   192   0000c1 7a              		ld	a, d		;sector=26?, if so, change tracks
   193   0000c2 fe1a            		cp	26
   194   0000c4 daa200          		jp	C, load1		;carry generated if sector<27
   195                          ;
   196                          ;		end of	current track,	go to next track
   197   0000c7 1600            		ld	d, 0		;begin with first sector of next track
   198   0000c9 0c              		inc	c		;track=track+1
   199                          ;
   200                          ;		save	register state, and change tracks
   201                          ;		push	BC
   202                          ;		push	DE
   203                          ;		push	HL
   204   0000ca cd3201          		call	bsettrk		;track address set from register c
   205                          ;		pop	HL
   206                          ;		pop	DE
   207                          ;		pop	BC
   208   0000cd c3a200          		jp	load1		;for another sector
   209                          ;
   210                          ;		end of	load operation, set parameters and go to cp/m
   211                          gocpm:
   212   0000d0 3ec3            		ld	a, 0c3h		;c3 is a jp instruction
   213   0000d2 320000          		ld	(0), a		;for jp to wboot
   214   0000d5 210300          		ld	HL, WBOOT	;wboot entry point
   215   0000d8 220100          		ld	(1), HL		;set address field for jp at 0
   216                          ;
   217   0000db 320500          		ld	(5), a		;for jp to bdos
   218   0000de 2106ec          		ld	HL, bdos	;bdos entry point
   219   0000e1 220600          		ld	(6), HL		;address field of Jump at 5 to bdos
   220                          ;
   221   0000e4 018000          		ld	BC, 80h		;default dma address is 80h
   222   0000e7 cd3f01          		call	bsetdma
   223                          ;
   224                          ;		ei			;enable the interrupt system
   225   0000ea 3a0400          		ld	a, (cdisk)	;get current disk number
   226   0000ed 4f              		ld	c, a		;send to the ccp
   227   0000ee c300e4          		jp	ccp		;go to cp/m for further processing
   228                          ;
   229                          ;
   230                          ;	simple i/o handlers (must be filled in by user)
   231                          ;	in each case, the entry point is provided, with space reserved
   232                          ;	to insert your own code
   233                          ;
   234                          bconst:		;console status, return 0ffh if character ready, 00h if not
   235                          ;		ds     10h		;space for status subroutine
   236                          ;		in     00h
   237                          
   238   0000f1 db01            		in	a, (STATA)
   239   0000f3 e601            		and	a, 1
   240   0000f5 c8              		ret	Z		; zero, not ready
   241   0000f6 3eff            		ld	a, 0ffh		; $ff, ready
   242   0000f8 c9              		ret
   243                          ;
   244                          bconin:	;console character into register a
   245                          ;	ds	10h		;space for input routine
   246                          ;--------------------------------------------------------------
   247                          ; get a character in A from rs232 (1)
   248                          ;
   249                          ;--------------------------------------------------------------
   250                          chrin:
   251   0000f9 db01            		in	a, (STATA)
   252   0000fb e601            		and	a, 1
   253   0000fd 28fa            		jr	Z, chrin
   254   0000ff db03            		in	a, (RECA)
   255   000101 c9              		ret
   256                          
   257                          ;		in      01h
   258                          ;		and	7fh		;strip parity bit
   259                          ;		ret
   260                          ;
   261                          chrouta:
   262   000102 4f              		ld	c, a
   263                          bconout:	;console character output from register c
   264                          ;--------------------------------------------------------------
   265                          ; output a character in A over rs232 (1)
   266                          ;
   267                          ;--------------------------------------------------------------
   268                          chrout:
   269   000103 db01            		in	a, (STATA)
   270   000105 e604            		and	a, 4
   271   000107 28fa            		jr	Z, chrout
   272   000109 79              		ld	a, c
   273   00010a d303            		out	(TRANSA), a
   274   00010c c9              		ret
   275                          
   276                          ;		ld	a, c		;get to accumulator
   277                          ;		ds	10h		;space for output routine
   278                          ;		out     01h
   279                          ;		ret
   280                          ;
   281                          blist:		;list character from register c
   282   00010d 79              		ld	a, c	  	;character to register a
   283   00010e c9              		ret		  	;null subroutine
   284                          ;
   285                          blistst:		;return list status (0 if not ready, 1 if ready)
   286   00010f af              		xor	a	 	;0 is always ok to return
   287   000110 c9              		ret
   288                          ;
   289                          bpunch:		;punch	character from	register C
   290   000111 79              		ld	a, c		;character to register a
   291   000112 c9              		ret			;null subroutine
   292                          ;
   293                          ;
   294                          breader:	;reader character into register a from reader device
   295   000113 3e1a            		ld    a, 1ah		;enter end of file for now (replace later)
   296   000115 e67f            		ani    7fh		;remember to strip parity bit
   297   000117 c9              		ret
   298                          ;
   299                          ;
   300                          ;		i/o drivers for the disk follow
   301                          ;		for now, we will simply store the parameters away for use
   302                          ;		in the read and write	subroutines
   303                          ;
   304                          bhome:		;lde to the track 00	position of current drive
   305                          ;		translate this call into a settrk call with Parameter 00
   306   000118 0e00            		ld    c, 0		;select track 0
   307   00011a cd3201          		call   bsettrk
   308   00011d c9              		ret			;we will lde to 00 on first read/write
   309                          ;
   310                          bseldsk:	;select disk given by register c
   311   00011e 210000          		ld	HL, 0000h	;error return code
   312   000121 79              		ld	a, c
   313   000122 320502          		ld	(diskno), a
   314   000125 fe04            		cp	4		;must be between 0 and 3
   315   000127 d0              		ret	NC			;no carry if 4, 5,...
   316                          ;		disk number is in the proper range
   317                          ;		ds	10		;space for disk select
   318                          ;		compute proper disk Parameter header address
   319                          ;		ld	a, (diskno)
   320   000128 6f              		ld	l, a		;l=disk number 0, 1, 2, 3
   321                          ;		ld	h, 0		;high order zero
   322   000129 29              		add	HL, HL		;*2
   323   00012a 29              		add	HL, HL		;*4
   324   00012b 29              		add	HL, HL		;*8
   325   00012c 29              		add	HL, HL		;*16 (size of each header)
   326   00012d 113300          		ld	DE, dpbase
   327   000130 19              		add	HL, DE		;hl=,dpbase (diskno*16)
   328   000131 c9              		ret
   329                          ;
   330                          bsettrk:	;set track given by register c
   331   000132 79              		ld	a, c
   332   000133 320602          		ld	(track), a
   333                          
   334                          ;		push	BC
   335                          ;		ld	c, 'T'
   336                          ;		call	chrout
   337                          ;		pop	BC
   338                          ;		ld	a, c
   339                          ;		call	printhex
   340                          ;		pop	BC
   341                          ;		push	BC
   342                          ;		ld	a, b
   343                          ;		call	printhex
   344                          ;		ld	a, c
   345                          ;		call	printhex
   346   000136 c9              		ret
   347                          ;
   348                          bsetsec:	;set sector given by register c
   349   000137 79              		ld	a, c
   350   000138 320702          		ld	(sector), a
   351                          
   352                          ;		push	BC
   353                          ;		ld	c, 'S'
   354                          ;		call	chrout
   355                          ;		pop	BC
   356                          ;		ld	a, c
   357                          ;		jp	printhex
   358   00013b c9              		ret
   359                          ;
   360                          ;
   361                          bsectran:
   362                          	;translate the sector given by bc using the
   363                          	;translate table given by de
   364   00013c 69              		ld	l, c
   365   00013d 60              		ld	h, b
   366   00013e c9              		ret
   367                          
   368                          ;		xchg			;hl=.trans
   369                          ;		dad	b		;hl=.trans (sector)
   370                          ;		ld	l, m		;l=trans (sector)
   371                          ;		ld	h, 0		;hl=trans (sector)
   372                          ;		ret			;with value in hl
   373                          ;
   374                          bsetdma:	;set	dma address given by registers b and c
   375                          ;		ld	l, c		;low order address
   376                          ;		ld	h, b		;high order address
   377   00013f ed430802        		ld	(dmaad), BC	;save the address
   378   000143 c9              		ret
   379                          
   380                          ;
   381                          bread:
   382                          		;perform read operation (usually this is similar to write
   383                          		;so we will allow space to set up read command, then use
   384                          		;common code in write)
   385                          
   386                          ;		ld	c, 'R'
   387                          ;		call	chrout
   388                          
   389                          ;		call	newline
   390                          ;;		call	cmdGetSector
   391                          ;		call	newline
   392                          
   393                          ;		ld	a, (seclen)
   394                          ;		cp	128
   395                          ;		jp	NZ, error
   396                          ;
   397                          ;		ld	HL, secdata		;copy ROM to RAM from
   398                          ;		ld	DE, (dmaad)		;to
   399                          ;		ld	BC, 128			;length
   400                          ;		ldir
   401                          
   402                          readsec:
   403   000144 3e52            		ld	a, 'R'		;read
   404   000146 cdda01          		call	serout
   405   000149 3a0502          		ld	a, (diskno)	;disk 0
   406   00014c cdda01          		call	serout
   407   00014f 3a0602          		ld	a, (track)	;track 2
   408   000152 cdda01          		call	serout
   409   000155 3a0702          		ld	a, (sector)	;sector 0
   410   000158 cdda01          		call	serout
   411                          
   412   00015b cdc701          		call	serin		;check ack
   413   00015e 38e4            		jr	C, readsec	;timeout?, redo
   414                          
   415                          readsec3:
   416   000160 fe41            		cp	'A'
   417   000162 2803            		jr	Z, readsec2	;ack OK
   418   000164 3e01            		ld	a, 1		;else return 1 (= unrecov. error)
   419   000166 c9              		ret
   420                          readsec2:
   421   000167 2a0802          		ld	hl, (dmaad)
   422   00016a 1680            		ld	d, 128
   423   00016c cdc701          readsec1:	call	serin
   424   00016f 77              		ld	(hl), a
   425   000170 23              		inc	hl
   426   000171 15              		dec	d
   427   000172 20f8            		jr	NZ, readsec1
   428                          
   429                          ;		call	newline
   430                          ;		ld	hl, (dmaad)
   431                          ;		ld	b, 128
   432                          ;		ld	d, 16
   433                          ;readsec4:	ld	a, (hl)
   434                          ;		inc	hl
   435                          ;		call	printhex
   436                          ;		call	space
   437                          ;		dec	d
   438                          ;		jr	nz, readsec5
   439                          ;		ld	d, 16
   440                          ;		call	newline
   441                          ;readsec5:	djnz	b, readsec4
   442                          
   443                          
   444   000174 af              		xor	a
   445   000175 c9              		ret
   446                          ;		jp	waitio		;to perform the actual i/o
   447                          ;
   448                          bwrite:
   449                          		;perform a write operation
   450                          		;ds	10h		;set up write command
   451                          		;ld	c, 'W'
   452                          		;call	chrout
   453                          		;out	02h
   454                          ;;		call	cmdPutSector
   455                          writesec:
   456   000176 3e57            		ld	a, 'W'		;write
   457   000178 cdda01          		call	serout
   458   00017b 3a0502          		ld	a, (diskno)	;disk 0
   459   00017e cdda01          		call	serout
   460   000181 3a0602          		ld	a, (track)	;track 2
   461   000184 cdda01          		call	serout
   462   000187 3a0702          		ld	a, (sector)	;sector 0
   463   00018a cdda01          		call	serout
   464                          
   465   00018d 0680            		ld	b, 128
   466   00018f 2a0802          		ld	hl, (dmaad)
   467   000192 7e              writesec1:	ld	a, (hl)
   468   000193 23              		inc	hl
   469   000194 cdda01          		call	serout
   470   000197 10f9            		djnz	b, writesec1
   471                          
   472   000199 cdc701          		call	serin		;check ack
   473   00019c 3806            		jr	C, writesec2	;timeout?, error
   474   00019e fe41            		cp	a, 'A'		;ack?
   475   0001a0 2002            		jr	NZ, writesec2	;no error
   476                          
   477   0001a2 af              		xor	a
   478   0001a3 c9              		ret
   479                          
   480   0001a4 3e01            writesec2:	ld	a, 1
   481   0001a6 c9              		ret
   482                          
   483                          copystr:
   484   0001a7 7e              		ld	a, (HL)
   485   0001a8 b7              		or	a
   486   0001a9 c8              		ret	Z
   487   0001aa 12              		ld	(DE), a
   488   0001ab 23              		inc	HL
   489   0001ac 13              		inc	DE
   490   0001ad 18f8            		jr	copystr
   491                          
   492                          printstr:
   493   0001af af              		xor	a
   494   0001b0 86              		add	a, (HL)
   495   0001b1 c8              		ret	Z
   496   0001b2 cd0201          		call	chrouta
   497   0001b5 23              		inc	HL
   498   0001b6 18f7            		jr	printstr
   499                          
   500                          space:
   501   0001b8 0e20            		ld	c, 32
   502   0001ba c30301          		jp	chrout
   503                          
   504                          newline:
   505   0001bd 0e0d            		ld	c, 13
   506   0001bf cd0301          		call	chrout
   507   0001c2 0e0a            		ld	c, 10
   508   0001c4 c30301          		jp	chrout
   509                          
   510                          ;--------------------------------------------------------------
   511                          ; get a character in A from rs232 (2)
   512                          ;
   513                          ;--------------------------------------------------------------
   514   0001c7 010000          serin:		ld	bc, 0
   515   0001ca db09            serin1:		in	a, (STATB)
   516   0001cc e601            		and	a, 1
   517   0001ce 2007            		jr	NZ, serin2
   518   0001d0 10f8            		djnz	b, serin1
   519   0001d2 0d              		dec	c
   520   0001d3 20f5            		jr	NZ, serin1
   521   0001d5 37              		scf
   522   0001d6 c9              		ret
   523   0001d7 db0b            serin2:		in	a, (RECB)
   524   0001d9 c9              		ret
   525                          
   526                          ;--------------------------------------------------------------
   527                          ; output a character in A over rs232 (1)
   528                          ;
   529                          ;--------------------------------------------------------------
   530                          serout:
   531   0001da f5              		push	AF
   532   0001db db09            serout1:	in	a, (STATB)
   533   0001dd e604            		and	a, 4
   534   0001df 28fa            		jr	Z, serout1
   535   0001e1 f1              		pop	AF
   536   0001e2 d30b            		out	(TRANSB), a
   537   0001e4 c9              		ret
   538                          
   539                          ;--------------------------------------------------------------
   540                          ; prints byte in A in hexadecimal format
   541                          ;--------------------------------------------------------------
   542                          printhex:
   543   0001e5 f5              		push    AF
   544   0001e6 f5              		push    AF
   545   0001e7 1f              		rra
   546   0001e8 1f              		rra
   547   0001e9 1f              		rra
   548   0001ea 1f              		rra
   549   0001eb cdf401          		call    printnib
   550   0001ee f1              		pop     AF
   551   0001ef cdf401          		call    printnib
   552   0001f2 f1              		pop     AF
   553   0001f3 c9              		ret
   554                          printnib:
   555   0001f4 e60f            		and     0fh
   556   0001f6 fe0a            		cp      0ah
   557   0001f8 3802            		jr      C, printnib1
   558   0001fa c607            		add     a, 07h
   559                          printnib1:
   560   0001fc c630            		add     a, '0'
   561                          print:
   562   0001fe c5              		push    BC
   563   0001ff 4f              		ld      c, a
   564   000200 cd0301          		call    chrout
   565   000203 c1              		pop     BC
   566   000204 c9              		ret
   567                          
   568                          ;
   569                          ;waitio:	;enter	here from read	and write to perform the actual i/o
   570                          ;		operation. return a 00h in register a if the operation completes
   571                          ;		properly, and 0lh if an error occurs during the read or write
   572                          ;
   573                          ;		in this case, we have saved the disk number in 'diskno' (0, 1)
   574                          ;				the track number in 'track' (0-76)
   575                          ;				the sector number in 'sector' (1-26)
   576                          ;				the dma address in 'dmaad' (0-65535)
   577                          ;		ds	256		;space reserved for i/o drivers
   578                          ;		ld	a, 1		;error condition
   579                          ;		ret			;replaced when filled-in
   580                          ;
   581                          ;		the remainder of the cbios is reserved uninitialized
   582                          ;		data area, and does not need to be a Part of the
   583                          ;		system	memory image (the space must be available,
   584                          ;		however, between"begdat" and"enddat").
   585                          ;
   586   000205 00              diskno:		ds	1		;disk number 0-15
   587   000206 00              track:		ds	1		;two bytes for expansion
   588   000207 00              sector:		ds	1		;two bytes for expansion
   589   000208 0000            dmaad:		ds	2		;direct memory address
   590                          ;
   591                          ;		scratch ram area for bdos use
   592                          begdat		equ	$	 	;beginning of data area
   593   00020a 0000000000000000dirbf:		ds	128	 	;scratch directory area
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
   594   00028a 0000000000000000all00:		ds	31	 	;allocation vector 0
                0000000000000000
                0000000000000000
                00000000000000  
   595   0002a9 0000000000000000all01:		ds	31	 	;allocation vector 1
                0000000000000000
                0000000000000000
                00000000000000  
   596   0002c8 0000000000000000all02:		ds	31	 	;allocation vector 2
                0000000000000000
                0000000000000000
                00000000000000  
   597   0002e7 0000000000000000all03:		ds	31	 	;allocation vector 3
                0000000000000000
                0000000000000000
                00000000000000  
   598   000306 0000000000000000chk00:		ds	16		;check vector 0
                0000000000000000
   599   000316 0000000000000000chk01:		ds	16		;check vector 1
                0000000000000000
   600   000326 0000000000000000chk02:		ds	16	 	;check vector 2
                0000000000000000
   601   000336 0000000000000000chk03:		ds	16	 	;check vector 3
                0000000000000000
   602                          ;
   603                          enddat		equ	$	 	;end of data area
   604                          datsiz		equ	$-begdat;	;size of data area
   605                          
   606                          
   607                          		IFDEF NOEXCLUDE
   608                          cmdOpenDisk:
   609                          		ld	a, (diskno)
   610                          		call	bin2deca
   611                          		ld	HL, opendiskno
   612                          		call	dec2disp
   613                          		ld	HL, (opendiskno)
   614                          		ld	(opendiskno1), HL
   615                          
   616                          		ld	HL, opendisk
   617                          		jp	sendCommand
   618                          
   619                          
   620                          cmdPutSector:
   621                          		ld	a, (diskno)		; write diskno
   622                          		call	bin2deca		; in paintext
   623                          		ld	HL, putsdisk		; to getsdisk
   624                          		call	dec2disp
   625                          		ld	a, (track)		; write track
   626                          		call	bin2deca
   627                          		ld	HL, putstrack
   628                          		call	dec2disp
   629                          		ld	a, (sector)		; write sector
   630                          		call	bin2deca
   631                          		ld	HL, putssector
   632                          		call	dec2disp
   633                          
   634                          		ld	HL, (dmaad)		;128 from (dmadat)
   635                          		ld	DE, secdata		;to secdata
   636                          		ld	BC, 128			;set length length
   637                          		ld	(seclen), BC
   638                          		ldir
   639                          
   640                          		ld	DE, seclen
   641                          		ld	HL, putsdata-2
   642                          		call	codeBase64
   643                          		ld	HL, 00a0dh
   644                          		ld	(putsdata-2), HL
   645                          
   646                          		ld	HL, putsector
   647                          		jp	sendCommand
   648                          
   649                          
   650                          cmdGetSector:
   651                          		ld	a, (diskno)		; write diskno
   652                          		call	bin2deca		; in paintext
   653                          		ld	HL, getsdisk		; to getsdisk
   654                          		call	dec2disp
   655                          		ld	a, (track)		; write track
   656                          		call	bin2deca
   657                          		ld	HL, getstrack
   658                          		call	dec2disp
   659                          		ld	a, (sector)		; write sector
   660                          		call	bin2deca
   661                          		ld	HL, getssector
   662                          		call	dec2disp
   663                          
   664                          		ld	HL, getsector		; send the sector-command
   665                          		call	sendCommand
   666                          
   667                          ;		ld	a, h
   668                          ;		call	printhex
   669                          ;		ld	a, l
   670                          ;		call	printhex
   671                          ;		ld	a, d
   672                          ;		call	printhex
   673                          ;		ld	a, e
   674                          ;		call	printhex
   675                          ;		ld	c, 32
   676                          ;		call	chrout
   677                          
   678                          		ex	DE, HL			;DE = OK + 5
   679                          		dec	HL			;HL - 4
   680                          		dec	HL
   681                          		dec	HL
   682                          		dec	HL
   683                          		xor	a
   684                          		ld	(HL), a
   685                          		ld	a, 172			;decode from
   686                          		dec	HL
   687                          		ld	(HL), a
   688                          		ld	DE, seclen		;into seclen
   689                          		jp	decodeBase64
   690                          
   691                          
   692                          
   693                          sendCommand:
   694                          		push	HL
   695                          		push	HL
   696                          
   697                          		ld	HL, atstatus		;status of connection
   698                          		call	writeesp
   699                          		ld	a, (line + 21)
   700                          		cp	'3'
   701                          		jp	Z, sendCommand1		;if 3 send command
   702                          
   703                          sendCommand3:
   704                          		ld	HL, connect
   705                          		call	writeesp
   706                          		jr	NC, sendCommand1
   707                          
   708                          enterIP:
   709                          		ld	HL, iptext
   710                          		call	printstr
   711                          		call	getline
   712                          		ld	HL, line
   713                          		ld	DE, connectip
   714                          		call	copystr
   715                          
   716                          		dec	DE
   717                          		ld	HL, porttext
   718                          		call	copystr
   719                          		ld	(DE), a
   720                          ;		jp	error
   721                          		jr	sendCommand3
   722                          
   723                          sendCommand1:
   724                          		pop	HL
   725                          		call	strlen			;length in DE
   726                          ;		ld	a, d
   727                          ;		call	printhex
   728                          ;		ld	a, e
   729                          ;		call	printhex
   730                          		call	bin2dec			;e in hex to a in dec
   731                          		ld	HL, cipsendlenl		;prite dec to display
   732                          		call	dec2disp
   733                          		ld	HL, 03030h		;"00" into
   734                          		ld	(cipsendlenh), HL
   735                          		ld	a, d
   736                          		or	a
   737                          		jr	Z, sendCommand2
   738                          		ld	HL, 03230h		;02
   739                          		ld	(cipsend+11), HL
   740                          		ld	HL, 03638h		;86
   741                          		ld	(cipsend+13), HL
   742                          
   743                          sendCommand2:
   744                          		ld	HL, cipsend
   745                          		call	writeesp
   746                          		jr	NC, sendCommand4
   747                          		pop	HL
   748                          		xor	a
   749                          		call	printhex
   750                          		jr	sendCommand
   751                          
   752                          
   753                          ;		call	prtline
   754                          sendCommand4:
   755                          		call	espin
   756                          		call	espin
   757                          
   758                          
   759                          		pop	HL
   760                          		push	HL
   761                          		call	writeesp
   762                          		pop	HL
   763                          		ret
   764                          
   765                          ;		ret	NC
   766                          ;		ld	a, 1
   767                          ;		call	printhex
   768                          ;		jr	sendCommand
   769                          
   770                          
   771                          error:
   772                          		ld	b, 0
   773                          e1:		djnz	e1
   774                          		ld	a, 080h			;OP7 = HIGH
   775                          		out	(OPRES), a
   776                          		jp	0
   777                          
   778                          connect:	DB	"AT+CIPSTART=\"TCP\",\""
   779                          connectip:	DB	"192.168.178.22"
   780                          		DB	"\","
   781                          connectport:	DB	"4434",13,10,0,0,0
   782                          
   783                          cipsend:	DB	"AT+CIPSEND="
   784                          cipsendlenh:	DB	"00"
   785                          cipsendlenl:	DB	"xx",13,10,0
   786                          
   787                          opendisk:	DB	"GET /disk?func=open&disk="
   788                          opendiskno:	DB	"00"
   789                          		DB	"&filename=disk"
   790                          opendiskno1:	DB	"00.dsk HTTP/1.0",13,10,13,10,0
   791                          
   792                          getsector:	DB	"GET /sectordata?disk="
   793                          getsdisk:	DB	"00"
   794                          		DB	"&track="
   795                          getstrack:	DB	"00"
   796                          		DB	"&sector="
   797                          getssector:	DB	"00"
   798                          		DB	" HTTP/1.1",13,10
   799                          		DB	"Host: roland.z80",13,10,13,10,0
   800                          
   801                          putsector:	DB	"PUT /sectordata?disk="
   802                          putsdisk:	DB	"00"
   803                          		DB	"&track="
   804                          putstrack:	DB	"00"
   805                          		DB	"&sector="
   806                          putssector:	DB	"00"
   807                          		DB	" HTTP/1.0",13,10
   808                          		DB	"Host: roland.z80",13,10
   809                          		DB	"Accept: text/plain",13,10
   810                          		DB	"Content-Length: 172",13,10,13,10
   811                          putsdata:	DS	172
   812                          		DB	0
   813                          atstatus:	DB	"AT+CIPSTATUS",13,10,0
   814                          iptext:		DB	13,10,"IP:",0
   815                          porttext:	DB	"\",4434",13,10,0
   816                          
   817                          
   818                          ;--------------------------------------------------------------
   819                          ; DE: Pointer to input-area
   820                          ; HL: Base64 coded output input
   821                          ;
   822                          ; area: 2-byte          len
   823                          ;       xxx-byte        data
   824                          ;--------------------------------------------------------------
   825                          codeBase64:
   826                          		push    HL              ; IY = ptr to out-length
   827                          		pop     IY
   828                          		inc     HL
   829                          		inc     HL
   830                          		push    HL              ; save ptr to out-data
   831                          
   832                          		ld      a, (DE)
   833                          		neg
   834                          		ld      c, a
   835                          		inc     DE
   836                          		ld      a, (DE)
   837                          		neg
   838                          		ld      b, a
   839                          		inc     DE              ; BC = in-len
   840                          		push    BC
   841                          		pop     IX
   842                          		add     IX, DE
   843                          
   844                          		ld      c, 0
   845                          
   846                          code_loop1:
   847                          		ex      DE, HL          ;switch to input-pointer
   848                          		ld      a, c
   849                          		inc     c
   850                          		and     3
   851                          
   852                          		jr      NZ, code1
   853                          
   854                          		ld      a, (HL)
   855                          		rra
   856                          		rra
   857                          		and     00111111b
   858                          		call    codeB64
   859                          		jr      code_loop
   860                          
   861                          code1:
   862                          		dec     a
   863                          		jr      NZ, code2
   864                          		ld      a, (HL)
   865                          		rla
   866                          		rla
   867                          		rla
   868                          		rla
   869                          		and     00110000b
   870                          		ld      b, a
   871                          		inc     HL
   872                          		ld      a, (HL)
   873                          		rra
   874                          		rra
   875                          		rra
   876                          		rra
   877                          		and     %00001111
   878                          		or      b
   879                          		call    codeB64
   880                          		jr      code_loop
   881                          
   882                          code2:
   883                          		dec     a
   884                          		jr      NZ, code3
   885                          		ld      a, (HL)
   886                          		rla
   887                          		rla
   888                          		and     00111100b
   889                          		ld      b, a
   890                          		inc     HL
   891                          		ld      a, (HL)
   892                          		rlca
   893                          		rlca
   894                          		and     00000011b
   895                          		or      b
   896                          		call    codeB64
   897                          
   898                          code_loop:
   899                          		ex      DE, HL                  ;switch to output-pointer
   900                          		ld      (HL), a                 ;store base64 symbol
   901                          		inc     HL
   902                          		jr      code_loop1
   903                          
   904                          code3:
   905                          		ld      a, (HL)
   906                          		inc     HL
   907                          		and     00111111b
   908                          		call    codeB64
   909                          
   910                          		ex      DE, HL                  ;switch HL to output-pointer
   911                          		ld      (HL), a                 ;store base64 symbol
   912                          		inc     HL
   913                          
   914                          		push    DE
   915                          		push    HL
   916                          		ex      DE, HL
   917                          		push    IX
   918                          		pop     DE
   919                          		sbc     HL, DE
   920                          		ld      b, l
   921                          		pop     HL
   922                          		pop     DE
   923                          
   924                          		jp      M, code_loop1
   925                          		push    HL
   926                          code3a:
   927                          		jr      Z, code3b
   928                          		dec     HL
   929                          		ld      (HL), '='
   930                          		djnz    code3a
   931                          code3b:
   932                          		pop     HL
   933                          		pop     DE
   934                          		sbc     HL, DE
   935                          		ld      (IY), l
   936                          		ld      (IY + 1), h
   937                          		ret
   938                          
   939                          
   940                          
   941                          ;--------------------------------------------------------------
   942                          ; DE: Pointer to output-area
   943                          ; HL: Base64 coded input
   944                          ;
   945                          ; area: 2-byte          len
   946                          ;       xxx-byte        data
   947                          ;--------------------------------------------------------------
   948                          decodeBase64:
   949                          		ld      c, (HL)                 ; load lo, hi length
   950                          		inc     HL
   951                          		ld      b, (HL)
   952                          		inc     HL
   953                          		push    BC
   954                          		exx
   955                          		pop     BC                      ; put length in BC'
   956                          		exx
   957                          
   958                          		ld      c, 0
   959                          
   960                          		push    DE                      ; save out-ptr on stack
   961                          		inc     DE                      ; skip-out-length
   962                          		inc     DE
   963                          		push    DE                      ; save it, too
   964                          
   965                          decode_loop1:
   966                          		call    decodeB64               ; load in-byte in (HL) and decode into a
   967                          		ld      b, a
   968                          		ld      a, c
   969                          		inc     c
   970                          		jr      C, decode_loop2         ; if decodeB64 has set Carry, input was '='
   971                          
   972                          		inc     HL                      ; increment input-pointer
   973                          		ex      DE, HL                  ; switch to output-pointer
   974                          		and     3
   975                          
   976                          		jr      NZ, decode1
   977                          
   978                          		ld      a, b
   979                          		rla
   980                          		rla
   981                          		and     11111100b
   982                          		ld      (HL), a
   983                          		jr      decode_loop
   984                          
   985                          decode1:
   986                          		dec     a
   987                          		jr      NZ, decode2
   988                          		ld      a, b
   989                          		rra
   990                          		rra
   991                          		rra
   992                          		rra
   993                          		and     00000011b
   994                          		or      (HL)
   995                          		ld      (HL), a
   996                          		inc     HL
   997                          		ld      a, b
   998                          		rla
   999                          		rla
  1000                          		rla
  1001                          		rla
  1002                          		and     11110000b
  1003                          		ld      (HL), a
  1004                          		jr      decode_loop
  1005                          
  1006                          decode2:
  1007                          		dec     a
  1008                          		jr      NZ, decode3
  1009                          		ld      a, b
  1010                          		rra
  1011                          		rra
  1012                          		and     00001111b
  1013                          		or      (HL)
  1014                          		ld      (HL), a
  1015                          		inc     HL
  1016                          		ld      a, b
  1017                          		rrca
  1018                          		rrca
  1019                          		and     11000000b
  1020                          		ld      (HL), a
  1021                          		jr      decode_loop
  1022                          
  1023                          decode3:
  1024                          		ld      a, b
  1025                          		or      (HL)
  1026                          		ld      (HL), a
  1027                          		inc     HL
  1028                          
  1029                          decode_loop:
  1030                          		ex      DE, HL                  ; switch to input-pointer
  1031                          
  1032                          		exx
  1033                          		dec     BC
  1034                          		ld      a, b
  1035                          		or      c
  1036                          		exx
  1037                          		jr      NZ, decode_loop1
  1038                          
  1039                          decode_loop2:
  1040                          		ex      DE, HL                  ; switch to output-pointer
  1041                          		pop     DE                      ; get start of output
  1042                          
  1043                          		or      a                       ; reset carry!
  1044                          		sbc     HL, DE                  ; len = end - start
  1045                          		pop     DE                      ; load address of output-len
  1046                          		ex      DE, HL                  ; switch to output-len
  1047                          		ld      (HL), E                 ; save len
  1048                          		inc     HL
  1049                          		ld      (HL), D
  1050                          		ret
  1051                          
  1052                          
  1053                          
  1054                          decodeB64:
  1055                          		ld      a, (HL)
  1056                          
  1057                          		cp      '='
  1058                          		jr      NZ, decodeB64e
  1059                          		xor     a
  1060                          		scf
  1061                          		ret
  1062                          decodeB64e:
  1063                          		cp      '+'
  1064                          		jr      NZ, decodeB64a
  1065                          		ld      a, 62
  1066                          		ret
  1067                          decodeB64a:
  1068                          		cp      '/'
  1069                          		jr      NZ, decodeB64b
  1070                          		ld      a, 63
  1071                          		ret
  1072                          decodeB64b:
  1073                          		cp      ':'
  1074                          		jr      NC, decodeB64c          ; not 0-9?
  1075                          		add     a, 4                    ; '0' = 48 -> 52
  1076                          		ret
  1077                          decodeB64c:
  1078                          		cp      'Z'+1
  1079                          		jr      NC, decodeB64d          ; not A-Z?
  1080                          		sub     'A'                     ; 'A' = 65 -> 0
  1081                          		ret
  1082                          decodeB64d:                             	; then a-z
  1083                          		sub     71
  1084                          		ret
  1085                          
  1086                          
  1087                          
  1088                          codeB64:
  1089                          		cp      26
  1090                          		jr      NC, codeB64a
  1091                          		add     a, 'A'                     ; < 0-25
  1092                          		ret
  1093                          codeB64a:
  1094                          		cp      52
  1095                          		jr      NC, codeB64b
  1096                          		add     a, 71
  1097                          		ret
  1098                          codeB64b:
  1099                          		cp      62
  1100                          		jr      NC, codeB64c
  1101                          		sub     4
  1102                          		ret
  1103                          codeB64c:
  1104                          		cp      62
  1105                          		jr      NZ, codeB64d
  1106                          		ld      a, '+'
  1107                          		ret
  1108                          codeB64d:
  1109                          		ld      a, '/'
  1110                          		ret
  1111                          ;
  1112                          ;
  1113                          ;
  1114                          dec2disp:	push    af
  1115                          		rrca
  1116                          		rrca
  1117                          		rrca
  1118                          		rrca
  1119                          		call    dec2nibble
  1120                          		inc	HL
  1121                          		pop     af
  1122                          
  1123                          dec2nibble:   	or      0xf0
  1124                          		daa
  1125                          		add     a,0xa0
  1126                          		adc     a,0x40
  1127                          		ld	(HL), a
  1128                          		ret
  1129                          
  1130                          
  1131                          bin2deca:	ld	e, a
  1132                          bin2dec:	ld	b, 8
  1133                          		xor	a
  1134                          bin2dec1:	rlc	e
  1135                          		adc	a, a
  1136                          		daa
  1137                          		djnz	bin2dec1
  1138                          		ret
  1139                          
  1140                          
  1141                          
  1142                          strlen:		ld	DE, 0
  1143                          strlen1:
  1144                          		ld	a, (HL)
  1145                          		or	a
  1146                          		ret	z
  1147                          		inc	DE
  1148                          		inc	HL
  1149                          		jr	strlen1
  1150                          
  1151                          
  1152                          
  1153                          getesp:
  1154                          		ld	HL, line
  1155                          getesp2:
  1156                          		push	HL
  1157                          		pop	DE		; DE = HL
  1158                          getesp1:
  1159                          		call	espin
  1160                          		ld	(HL), a
  1161                          		inc	HL
  1162                          		cp	10
  1163                          		jr	NZ, getesp1	; read until EOL
  1164                          
  1165                          		ex	DE, HL
  1166                          		ld	a, (HL)
  1167                          		inc	HL
  1168                          		ld	b, (HL)
  1169                          		inc	HL
  1170                          		inc	HL
  1171                          		inc	HL
  1172                          		inc	HL
  1173                          		ld	c, (HL)
  1174                          		ex	DE, HL
  1175                          		cp	'O'		; "OK"?
  1176                          		jr	Z, getespK
  1177                          		cp	'E'		; "ERR"?
  1178                          		jr	Z, getespR
  1179                          		ld	a, c
  1180                          		cp	'F'		; "FAIL"?
  1181                          		jr	NZ, getesp2
  1182                          		ex	DE, HL
  1183                          		inc	HL
  1184                          		ld	a, (HL)
  1185                          		ex	DE, HL
  1186                          		cp	'A'
  1187                          		jr	Z, getesperr
  1188                          		jr	getesp2
  1189                          
  1190                          getespK:	ld	a, b
  1191                          		cp	'K'
  1192                          		jr	NZ, getesp2
  1193                          		xor	a
  1194                          		ld	(HL), a
  1195                          		ret
  1196                          
  1197                          getespR:	ld	a, b
  1198                          		cp	'R'
  1199                          		jr	NZ, getesp2
  1200                          getesperr:	xor	a
  1201                          		ld	(HL), a
  1202                          		scf
  1203                          		ret
  1204                          
  1205                          getespE:	ld	a, b
  1206                          		cp	'E'
  1207                          		jr	NZ, getesp2
  1208                          		jr	getesperr
  1209                          writeesp:
  1210                          		ld	a, (HL)
  1211                          		or	a
  1212                          		jr	Z, getesp
  1213                          		call	espout
  1214                          ;		call	chrout
  1215                          		inc	HL
  1216                          		jr	writeesp
  1217                          
  1218                          putesp:
  1219                          		ld	HL, line
  1220                          putesp1:
  1221                          		ld	a, (HL)
  1222                          		cp	10
  1223                          		jr	NZ, putesp2
  1224                          		ld	a, 13
  1225                          		call	espout
  1226                          		ld	a, 10
  1227                          		jp	espout
  1228                          putesp2:	call	espout
  1229                          		inc	HL
  1230                          		jr	putesp1
  1231                          
  1232                          
  1233                          
  1234                          getline:	ld	HL, line-1
  1235                          getline1:
  1236                          		inc	HL
  1237                          		call	chrin
  1238                          		ld	(HL), a
  1239                          		call	chrouta
  1240                          ;		ld	a, c
  1241                          		cp	a, 10
  1242                          		jr	NZ, getline1
  1243                          		xor	a
  1244                          		ld	(HL), a
  1245                          		ret
  1246                          
  1247                          prtline:
  1248                          		ld	HL, line
  1249                          prtline1:
  1250                          		ld	a, (HL)
  1251                          		inc	HL
  1252                          		or	a
  1253                          		ret	Z
  1254                          		call	chrouta
  1255                          		jr	prtline1
  1256                          
  1257                          ;--------------------------------------------------------------
  1258                          ; get a character in A from rs232 (2)
  1259                          ;
  1260                          ;--------------------------------------------------------------
  1261                          espin:
  1262                          		in	a, (STATB)
  1263                          		and	a, 1
  1264                          		jr	Z, espin
  1265                          		in	a, (RECB)
  1266                          		ret
  1267                          
  1268                          espstat:	in	a, (STATB)
  1269                          		and	a, 1
  1270                          		ret
  1271                          
  1272                          ;--------------------------------------------------------------
  1273                          ; output a character in A over rs232 (2)
  1274                          ;
  1275                          ;--------------------------------------------------------------
  1276                          espout:
  1277                          		push	AF
  1278                          espout1:	in	a, (STATB)
  1279                          		and	a, 4
  1280                          		jr	Z, espout1
  1281                          		pop	AF
  1282                          		out	(TRANSB), a
  1283                          		ret
  1284                          
  1285                          line:		DS	300
  1286                          
  1287                          seclen:		DS	2
  1288                          secdata:	DS	128
  1289                          		ENDIF
  1290                          
  1291   000346 1b5b6d0d        copyright:	DB	27, "[m", 13
  1292   00034a 5a383020        		DB	"Z80 "
  1293   00034e 1b5b33356d46611b		DB	27, "[35mFa", 27, "[m"
                5b6d            
  1294   000358 62756c6f757320  		DB	"bulous "
  1295   00035f 1b5b33326d42691b		DB	27, "[32mBi", 27, "[m"
                5b6d            
  1296   000369 6e61727920      		DB	"nary "
  1297   00036e 1b5b33366d416e1b		DB	27, "[36mAn", 27, "[m"
                5b6d            
  1298   000378 6968696c61746f72		DB	"ihilator",13
                0d              
  1299   000381 43502f4d20322e32		DB	"CP/M 2.2 Copyright 1979 (c) by Digital Research"
                20436f7079726967
                6874203139373920
                2863292062792044
                69676974616c2052
                65736561726368  
  1300   0003b0 00              		DB	0
  1301                          
  1302                          
  1303                          
  1304                          
  1305                          ;	end
  1306                          
