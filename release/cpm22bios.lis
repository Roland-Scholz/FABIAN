cpm22bios.asm:
     1                          	include "mc68681.asm"
mc68681.asm:
     1                          ;--------------------------------------------------------------------------------
     2                          ; equates for MC68681 DUART
     3                          ;
     4                          ; see ./doc/scc68681.pdf
     5                          ;--------------------------------------------------------------------------------
     6                          MODEA		equ	0
     7                          STATA		equ	1
     8                          CLOCKA		equ	1
     9                          COMMA		equ	2
    10                          RECA		equ	3
    11                          TRANSA		equ	3
    12                          IPCHANGE	equ	4
    13                          AUXCTRL		equ	4
    14                          ISR		equ	5
    15                          IMR		equ	5
    16                          CNTMSB		equ	6
    17                          CNTLSB		equ	7
    18                          MODEB		equ	8
    19                          STATB		equ	9
    20                          CLOCKB		equ	9
    21                          COMMB		equ	10
    22                          RECB		equ	11
    23                          TRANSB		equ	11
    24                          IVR		equ	12
    25                          INPORT		equ	13
    26                          OPCTRL		equ	13
    27                          STRTCNT		equ	14
    28                          OPSET		equ	14
    29                          STOPCNT		equ	15
    30                          OPRES		equ	15
    31                          
cpm22bios.asm:
     2                          
     3                          DEBUG		equ	0
     4                          
     5                          FATBUF		equ	$FC00		;address of 512-byte buffer for FAT
     6                          DATBUF		equ	FATBUF + $200	;adddres of 512-byte buffer for data
     7                          
     8                          ;
     9                          ;	skeletal cbios for first level of CP/M 2.0 alteration
    10                          ;
    11                          msize		equ	62		;cp/m version memory size in kilobytes
    12                          ;
    13                          ;	"bias" is address offset from 3400h for memory systems
    14                          ;	than 16k (referred to as"b" throughout the text)
    15                          ;									25616 (TP)	24592 (TP)
    16                          bias		equ	(msize-20)*1024	;		$B000 (64k)	$A800 (62k)
    17                          ccp		equ	3400h+bias	;base of ccp	$E400		$DC00		$D800 (61k)
    18                          bdos		equ	ccp+806h	;base of bdos	$EC06		$E406
    19                          bios		equ	ccp+1600h	;base of bios	$FA00		$F200		$EE00
    20                          cdisk		equ	0004h		;current disk number 0=a,... l5=p
    21                          iobyte		equ	0003h		;intel i/o byte
    22                          ;
    23                          	IFDEF STANDALONE
    24                          	org	bios		;origin of this program
    25                          	ENDIF
    26                          
    27                          nsects		equ	$1600/128	;warm start sector count (44 sectors for BDOS + CCP)
    28                          ;
    29                          ;		jump vector for individual subroutines
    30                          ;
    31   000000 c38200          		jp	boot	;cold start
    32   000003 c38500          WBOOT:		jp	bwboot	;warm start
    33   000006 c3fc00          CONST:		jp	bconst	;console status
    34   000009 c30401          CONIN:		jp	bconin	;console character in
    35   00000c c30701          CONOUT:		jp	bconout	;console character out
    36   00000f c30a01          LIST:		jp	blist	;list character out
    37   000012 c30e01          PUNCH:		jp	bpunch	;punch character out
    38   000015 c31001          READER:		jp	breader	;reader character out
    39   000018 c31501          HOME:		jp	bhome	;lde head to home position
    40   00001b c31b01          SELDSK:		jp	bseldsk	;select disk
    41   00001e c32f01          SETTRK:		jp	bsettrk	;set track number
    42   000021 c33401          SETSEC:		jp	bsetsec	;set sector number
    43   000024 c33c01          SETDMA:		jp	bsetdma	;set dma address
    44   000027 c34101          READ:		jp	bread	;read disk
    45   00002a c37d01          WRITE:		jp	bwrite	;write disk
    46   00002d c30c01          LISTST:		jp	blistst	;return list status
    47   000030 c33901          SECTRN:		jp	bsectran	;sector translate
    48                          ;
    49                          ;	dw	track
    50                          ;	fixed data tables for four-drive standard
    51                          ;	ibm-compatible 8" disks
    52                          ;
    53                          ;		disk Parameter header for disk 00
    54   000033 00000000        dpbase:		dw	0000h, 0000h
    55   000037 00000000        		dw	0000h, 0000h
    56   00003b 9a017300        		dw	dirbf, dpblk
    57   00003f 96021a02        		dw	chk00, all00
    58                          ;		disk parameter header for disk 01
    59   000043 00000000        		dw	0000h, 0000h
    60   000047 00000000        		dw	0000h, 0000h
    61   00004b 9a017300        		dw	dirbf, dpblk
    62   00004f a6023902        		dw	chk01, all01
    63                          ;		disk parameter header for disk 02
    64   000053 00000000        		dw	0000h, 0000h
    65   000057 00000000        		dw	0000h, 0000h
    66   00005b 9a017300        		dw	dirbf, dpblk
    67   00005f b6025802        		dw	chk02, all02
    68                          ;		disk parameter header for disk 03
    69   000063 00000000        		dw	0000h, 0000h
    70   000067 00000000        		dw	0000h, 0000h
    71   00006b 9a017300        		dw	dirbf, dpblk
    72   00006f c6027702        		dw	chk03, all03
    73                          ;
    74                          ;		sector translate vector
    75                          ;trans:		db	 1,  7, 13, 19	;sectors  1,  2,  3,  4
    76                          ;		db	25,  5, 11, 17	;sectors  5,  6,  7,  6
    77                          ;		db	23,  3,  9, 15	;sectors  9, 10, 11, 12
    78                          ;		db	21,  2,  8, 14	;sectors 13, 14, 15, 16
    79                          ;		db	20, 26,  6, 12	;sectors 17, 18, 19, 20
    80                          ;		db	18, 24,  4, 10	;sectors 21, 22, 23, 24
    81                          ;		db	16, 22		;sectors 25, 26
    82                          ;
    83                          dpblk:		;disk parameter block, common to all disks
    84   000073 1a00            		dw	26		;sectors per track
    85   000075 03              		db	3		;block shift factor
    86   000076 07              		db	7		;block mask
    87   000077 00              		db	0		;null mask
    88   000078 f200            		dw	242		;disk size-1
    89   00007a 3f00            		dw	63		;directory max
    90   00007c c0              		db	192		;alloc 0
    91   00007d 00              		db	0		;alloc 1
    92   00007e 1000            		dw	16		;check size
    93   000080 0200            		dw	2		;track offset
    94                          ;
    95                          ;	end of fixed tables
    96                          ;
    97                          ;	individual subroutines to perform each function
    98                          boot:	;simplest case is to just perform parameter initialization
    99                          ;		ld	sp, 80h		;use space below buffer for stack
   100                          
   101   000082 cd7505          		call	sdInit
   102                          
   103                          ;	jp	gocpm		;initialize and go to cp/m
   104                          ;
   105                          bwboot:	;simplest case is to read the disk until all sectors loaded
   106   000085 318000          		ld	sp, 80h		;use space below buffer for stack
   107                          
   108                          ;		ld	HL, 0100h
   109                          ;		ld	DE, 0101h
   110                          ;		ld	BC, 0F0FFh
   111                          ;		ld	(HL), 0
   112                          ;		ldir
   113                          
   114   000088 21e408          		ld	HL, copyright
   115   00008b cdd907          		call	printstr
   116                          
   117   00008e cd5304          		call	fopen
   118                          ;		call	dirPrintEntry
   119                          
   120   000091 af              		xor	a		;zero in the accum
   121   000092 320300          		ld	(iobyte), a	;clear the iobyte
   122   000095 320400          		ld	(cdisk), a	;select disk zero
   123                          
   124                          ;		ld	a, 3
   125                          ;opendisks:
   126                          ;		ld	(diskno), a
   127                          ;		push	AF
   128                          ;		call	cmdOpenDisk
   129                          ;		pop	AF
   130                          ;		dec	a
   131                          ;		jp	P, opendisks
   132                          
   133   000098 0e00            		ld	c, 0		;select disk 0
   134   00009a cd1b01          		call	bseldsk
   135   00009d cd1501          		call	bhome		;go to track 00
   136                          ;		jp	gocpm
   137                          ;
   138                          
   139   0000a0 062c            		ld	b, nsects	;b counts * of sectors to load
   140   0000a2 0e00            		ld	c, 0		;c has the current track number
   141   0000a4 1600            		ld	d, 0		;d has the next sector to read
   142                          					;note that we begin by reading track 0, sector 2 since sector 1
   143                          					;contains the cold start loader, which is skipped in a warm start
   144   0000a6 2100dc          		ld	HL, ccp		;base of cp/m (initial load point)
   145                          load1:					;load	one more sector
   146   0000a9 c5              		push	BC		;save sector count, current track
   147   0000aa d5              		push	DE		;save next sector to read
   148   0000ab e5              		push	HL		;save dma address
   149   0000ac 4a              		ld	c, d		;get sector address to register C
   150   0000ad cd3401          		call	bsetsec		;set sector address from register C
   151   0000b0 c1              		pop	BC		;recall dma address to b, C
   152   0000b1 c5              		push	BC		;replace on stack for later recall
   153   0000b2 cd3c01          		call	bsetdma		;set dma address from b, C
   154                          ;
   155                          					;drive set to 0, track set, sector set, dma address set
   156   0000b5 cd4101          		call	bread
   157                          ;		cp	00h		;any errors?
   158   0000b8 b7              		or	a
   159   0000b9 c28500          		jp	NZ, bwboot	;retry the entire boot if an error occurs
   160                          ;
   161                          					;no error, lde to next sector
   162   0000bc e1              		pop	HL		;recall dma address
   163   0000bd 118000          		ld	DE, 128		;dma=dma+128
   164   0000c0 19              		add	HL, DE		;new dma address is in h, l
   165   0000c1 d1              		pop	DE		;recall sector address
   166   0000c2 c1              		pop	BC		;recall number of sectors remaining, and current trk
   167   0000c3 05              		dec	b		;sectors=sectors-1
   168   0000c4 cadb00          		jp	Z, gocpm	;transfer to cp/m if all have been loaded
   169                          ;
   170                          					;more sectors remain to load, check for track change
   171   0000c7 14              		inc	d
   172   0000c8 7a              		ld	a, d		;sector=26?, if so, change tracks
   173                          
   174   0000c9 e5              		push	HL
   175   0000ca 2a3d00          		ld	HL, (dpbase + $a) ;load Hl with dpblk of drive A:
   176   0000cd be              		cp	(HL)
   177   0000ce e1              		pop	HL
   178   0000cf daa900          		jp	C, load1	;carry generated if sector<26
   179                          ;
   180                          					;end of	current track,	go to next track
   181   0000d2 1600            		ld	d, 0		;begin with first sector of next track
   182   0000d4 0c              		inc	c		;track=track+1
   183                          ;
   184                          ;		save	register state, and change tracks
   185                          ;		push	BC
   186                          ;		push	DE
   187                          ;		push	HL
   188   0000d5 cd2f01          		call	bsettrk		;track address set from register c
   189                          ;		pop	HL
   190                          ;		pop	DE
   191                          ;		pop	BC
   192   0000d8 c3a900          		jp	load1		;for another sector
   193                          ;
   194                          ;		end of	load operation, set parameters and go to cp/m
   195                          gocpm:
   196   0000db 3ec3            		ld	a, 0c3h		;c3 is a jp instruction
   197   0000dd 320000          		ld	(0), a		;for jp to wboot
   198   0000e0 210300          		ld	HL, WBOOT	;wboot entry point
   199   0000e3 220100          		ld	(1), HL		;set address field for jp at 0
   200                          ;
   201   0000e6 320500          		ld	(5), a		;for jp to bdos
   202   0000e9 2106e4          		ld	HL, bdos	;bdos entry point
   203   0000ec 220600          		ld	(6), HL		;address field of Jump at 5 to bdos
   204                          ;
   205   0000ef 018000          		ld	BC, 80h		;default dma address is 80h
   206   0000f2 cd3c01          		call	bsetdma
   207                          ;
   208                          ;		ei			;enable the interrupt system
   209   0000f5 3a0400          		ld	a, (cdisk)	;get current disk number
   210   0000f8 4f              		ld	c, a		;send to the ccp
   211   0000f9 c300dc          		jp	ccp		;go to cp/m for further processing
   212                          ;
   213                          ;
   214                          ;	simple i/o handlers (must be filled in by user)
   215                          ;	in each case, the entry point is provided, with space reserved
   216                          ;	to insert your own code
   217                          ;
   218                          bconst:		;console status, return 0ffh if character ready, 00h if not
   219                          ;		ds     10h		;space for status subroutine
   220                          ;		in     00h
   221                          
   222   0000fc db01            		in	a, (STATA)
   223   0000fe e601            		and	a, 1
   224   000100 c8              		ret	Z		; zero, not ready
   225   000101 3eff            		ld	a, 0ffh		; $ff, ready
   226   000103 c9              		ret
   227                          ;
   228                          bconin:					;console character into register a
   229                          ;		ds	10h		;space for input routine
   230   000104 c3f207          		jp	chrin
   231                          
   232                          
   233                          
   234                          ;		in      01h
   235                          ;		and	7fh		;strip parity bit
   236                          ;		ret
   237                          ;
   238                          bconout:				;console character output from register c
   239   000107 c3fc07          		jp	chrout
   240                          ;		ld	a, c		;get to accumulator
   241                          ;		ds	10h		;space for output routine
   242                          ;		out     01h
   243                          ;		ret
   244                          ;
   245                          blist:		;list character from register c
   246   00010a 79              		ld	a, c	  	;character to register a
   247   00010b c9              		ret		  	;null subroutine
   248                          ;
   249                          blistst:		;return list status (0 if not ready, 1 if ready)
   250   00010c af              		xor	a	 	;0 is always ok to return
   251   00010d c9              		ret
   252                          ;
   253                          bpunch:		;punch	character from	register C
   254   00010e 79              		ld	a, c		;character to register a
   255   00010f c9              		ret			;null subroutine
   256                          ;
   257                          ;
   258                          breader:	;reader character into register a from reader device
   259   000110 3e1a            		ld    a, 1ah		;enter end of file for now (replace later)
   260   000112 e67f            		ani    7fh		;remember to strip parity bit
   261   000114 c9              		ret
   262                          ;
   263                          ;
   264                          ;		i/o drivers for the disk follow
   265                          ;		for now, we will simply store the parameters away for use
   266                          ;		in the read and write	subroutines
   267                          ;
   268                          bhome:		;lde to the track 00	position of current drive
   269                          ;		translate this call into a settrk call with Parameter 00
   270   000115 0e00            		ld    c, 0		;select track 0
   271   000117 cd2f01          		call   bsettrk
   272   00011a c9              		ret			;we will lde to 00 on first read/write
   273                          ;
   274                          bseldsk:	;select disk given by register c
   275   00011b 210000          		ld	HL, 0000h	;error return code
   276   00011e 79              		ld	a, c
   277   00011f 329401          		ld	(diskno), a
   278   000122 fe04            		cp	4		;must be between 0 and 3
   279   000124 d0              		ret	NC			;no carry if 4, 5,...
   280                          ;		disk number is in the proper range
   281                          ;		ds	10		;space for disk select
   282                          ;		compute proper disk Parameter header address
   283                          ;		ld	a, (diskno)
   284   000125 6f              		ld	l, a		;l=disk number 0, 1, 2, 3
   285                          ;		ld	h, 0		;high order zero
   286   000126 29              		add	HL, HL		;*2
   287   000127 29              		add	HL, HL		;*4
   288   000128 29              		add	HL, HL		;*8
   289   000129 29              		add	HL, HL		;*16 (size of each header)
   290   00012a 113300          		ld	DE, dpbase
   291   00012d 19              		add	HL, DE		;hl=,dpbase (diskno*16)
   292   00012e c9              		ret
   293                          ;
   294                          bsettrk:	;set track given by register c
   295   00012f 79              		ld	a, c
   296   000130 329501          		ld	(track), a
   297                          
   298                          ;		push	BC
   299                          ;		ld	c, 'T'
   300                          ;		call	chrout
   301                          ;		pop	BC
   302                          ;		ld	a, c
   303                          ;		call	printhex
   304                          ;		pop	BC
   305                          ;		push	BC
   306                          ;		ld	a, b
   307                          ;		call	printhex
   308                          ;		ld	a, c
   309                          ;		call	printhex
   310   000133 c9              		ret
   311                          ;
   312                          bsetsec:	;set sector given by register c
   313   000134 79              		ld	a, c
   314   000135 329601          		ld	(sector), a
   315                          
   316                          ;		push	BC
   317                          ;		ld	c, 'S'
   318                          ;		call	chrout
   319                          ;		pop	BC
   320                          ;		ld	a, c
   321                          ;		jp	printhex
   322   000138 c9              		ret
   323                          ;
   324                          ;
   325                          bsectran:
   326                          	;translate the sector given by bc using the
   327                          	;translate table given by de
   328   000139 69              		ld	l, c
   329   00013a 60              		ld	h, b
   330   00013b c9              		ret
   331                          
   332                          ;		xchg			;hl=.trans
   333                          ;		dad	b		;hl=.trans (sector)
   334                          ;		ld	l, m		;l=trans (sector)
   335                          ;		ld	h, 0		;hl=trans (sector)
   336                          ;		ret			;with value in hl
   337                          ;
   338                          bsetdma:	;set	dma address given by registers b and c
   339                          ;		ld	l, c		;low order address
   340                          ;		ld	h, b		;high order address
   341   00013c ed439701        		ld	(dmaad), BC	;save the address
   342   000140 c9              		ret
   343                          
   344                          ;
   345                          bread:
   346                          		;perform read operation (usually this is similar to write
   347                          		;so we will allow space to set up read command, then use
   348                          		;common code in write)
   349                          	if DEBUG = 1
   350                          		ld	a, 0
   351                          		ld	(debug), a
   352                          
   353                          		ld	c, 'R'
   354                          		call	chroutdebug
   355                          		call	spacedebug
   356                          	endif
   357   000141 cd4f01          		call	seeksectrk
   358                          
   359                          
   360   000144 2a9701          		ld	hl, (dmaad)
   361   000147 018000          		ld	bc, 80h
   362   00014a cd7d03          		call	fread
   363                          
   364                          	if DEBUG = 1
   365                          		call	newlinedebug
   366                          	endif
   367   00014d af              		xor	a
   368                          	if DEBUG = 1
   369                          		ld	(debug), a
   370                          	endif
   371   00014e c9              		ret
   372                          ;		jp	waitio			;to perform the actual i/o
   373                          
   374                          
   375                          ;
   376                          ;
   377                          ;
   378   00014f 11cc07          seeksectrk:	ld	de, fseeklen		;clear fseeklen
   379   000152 cdc308          		call	clear32
   380                          
   381   000155 af              		xor	a			;seeklen = track * 26 + sector
   382   000156 ed4b9501        		ld	bc, (track)
   383   00015a 1e1a            		ld	e, 26
   384   00015c 47              		ld	b, a
   385   00015d 57              		ld	d, a
   386   00015e cdd108          		call	mul16
   387   000161 ed4b9601        		ld	bc, (sector)
   388   000165 0600            		ld	b, 0
   389   000167 09              		add	hl, bc
   390   000168 22cd07          		ld	(fseeklen + 1), hl
   391                          
   392   00016b af              		xor	a			;shift right one position
   393   00016c 0603            		ld	b, 3
   394   00016e 21ce07          		ld	hl, fseeklen + 2
   395   000171 cb1e            seeksectrk1:	rr	(hl)
   396   000173 2b              		dec	hl
   397   000174 10fb            		djnz	seeksectrk1
   398                          
   399                          	if DEBUG = 1
   400                          		ld	a, (debug)
   401                          		or	a
   402                          		jr	Z, seeksectrk2
   403                          
   404                          		ld	c, 'T'
   405                          		call	chroutdebug
   406                          		ld	c, 'S'
   407                          		call	chroutdebug
   408                          		ld	a, (track)
   409                          		ld	h, a
   410                          		ld	a, (sector)
   411                          		ld	l, a
   412                          		call	printadrdebug
   413                          
   414                          		ld	hl, (fseeklen + 2)
   415                          		call	printadrdebug
   416                          		ld	hl, (fseeklen)
   417                          		call	printadrdebug
   418                          	endif
   419                          
   420   000176 21cc07          seeksectrk2:	ld	hl, fseeklen
   421   000179 cdd602          		call	fseek			;call fseek
   422                          
   423                          	if DEBUG = 1
   424                          		ld	hl, (datsec)
   425                          		call	printadrdebug
   426                          		ld	hl, (datptr)
   427                          		call	printadrdebug
   428                          		ld	hl, (dmaad)
   429                          		call	printadrdebug
   430                          	endif
   431   00017c c9              		ret
   432                          ;
   433                          ;
   434                          bwrite:
   435                          	if DEBUG = 1
   436                          		ld	a, 0
   437                          		ld	(debug), a
   438                          
   439                          		ld	c, 'W'
   440                          		call	chroutdebug
   441                          		call	spacedebug
   442                          	endif
   443                          
   444   00017d cd4f01          		call	seeksectrk		;compute seeklen
   445                          
   446   000180 2a9701          		ld	hl, (dmaad)		;copy data to sector buffer
   447   000183 ed5bc907        		ld	de, (datptr)
   448   000187 018000          		ld	bc, 80h
   449   00018a edb0            		ldir
   450                          
   451   00018c 11b407          		ld	de, datsec
   452   00018f cdd206          		call	sdWriteDat
   453                          
   454                          	if DEBUG = 1
   455                          		call	newlinedebug
   456                          	endif
   457                          
   458   000192 af              		xor	a
   459                          	if DEBUG = 1
   460                          		ld	(debug), a
   461                          	endif
   462   000193 c9              		ret
   463                          ;
   464                          ;writesec2:	ld	a, 1
   465                          ;		ret
   466                          
   467                          
   468                          ;
   469                          ;waitio:	;enter	here from read	and write to perform the actual i/o
   470                          ;		operation. return a 00h in register a if the operation completes
   471                          ;		properly, and 0lh if an error occurs during the read or write
   472                          ;
   473                          ;		in this case, we have saved the disk number in 'diskno' (0, 1)
   474                          ;				the track number in 'track' (0-76)
   475                          ;				the sector number in 'sector' (1-26)
   476                          ;				the dma address in 'dmaad' (0-65535)
   477                          ;		ds	256		;space reserved for i/o drivers
   478                          ;		ld	a, 1		;error condition
   479                          ;		ret			;replaced when filled-in
   480                          ;
   481                          ;		the remainder of the cbios is reserved uninitialized
   482                          ;		data area, and does not need to be a Part of the
   483                          ;		system	memory image (the space must be available,
   484                          ;		however, between"begdat" and"enddat").
   485                          ;
   486   000194 00              diskno:		ds	1		;disk number 0-15
   487   000195 00              track:		ds	1		;two bytes for expansion
   488   000196 00              sector:		ds	1		;two bytes for expansion
   489   000197 0000            dmaad:		ds	2		;direct memory address
   490   000199 00              debug:		ds	1		;1 = enable debug
   491                          ;
   492                          ;		scratch ram area for bdos use
   493                          begdat		equ	$	 	;beginning of data area
   494   00019a 0000000000000000dirbf:		ds	128	 	;scratch directory area
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
                0000000000000000
   495   00021a 0000000000000000all00:		ds	31	 	;allocation vector 0
                0000000000000000
                0000000000000000
                00000000000000  
   496   000239 0000000000000000all01:		ds	31	 	;allocation vector 1
                0000000000000000
                0000000000000000
                00000000000000  
   497   000258 0000000000000000all02:		ds	31	 	;allocation vector 2
                0000000000000000
                0000000000000000
                00000000000000  
   498   000277 0000000000000000all03:		ds	31	 	;allocation vector 3
                0000000000000000
                0000000000000000
                00000000000000  
   499   000296 0000000000000000chk00:		ds	16		;check vector 0
                0000000000000000
   500   0002a6 0000000000000000chk01:		ds	16		;check vector 1
                0000000000000000
   501   0002b6 0000000000000000chk02:		ds	16	 	;check vector 2
                0000000000000000
   502   0002c6 0000000000000000chk03:		ds	16	 	;check vector 3
                0000000000000000
   503                          ;
   504                          enddat		equ	$	 	;end of data area
   505                          datsiz		equ	$-begdat;	;size of data area
   506                          
   507                          
   508                          		include	"fat16.asm"
fat16.asm:
     1                          FATDEBUG	equ	0
     2                          
     3                          OP0		equ	1
     4                          OP1		equ	2
     5                          OP2		equ	4
     6                          
     7                          IP0		equ	1
     8                          IP1		equ	2
     9                          IP2		equ	4
    10                          
    11                          ;--------------------------------------------------------------
    12                          ; SD CARD constants
    13                          ;--------------------------------------------------------------
    14                          CMD0		equ	$40 +  0	;GO_IDLE_STATE	0x40, 64
    15                          CMD1		equ	$40 +  1	;reset
    16                          CMD8		equ	$40 +  8	;SEND_IF_COND	0x48, 72
    17                          CMD9		equ	$40 +  9	;SEND_CSD	0x49, 73
    18                          CMD13		equ	$40 + 13	;get_status	0x4D, 77
    19                          CMD17		equ	$40 + 17	;read  sector 	0x51, 81
    20                          CMD24		equ	$40 + 24	;write sector 	0x58, 88
    21                          CMD41		equ	$40 + 41	;SEND_OP_COND	0x69, 105 (leave idle state)
    22                          CMD55		equ	$40 + 55	;ACMD 		0x77, 119
    23                          CMD58		equ	$40 + 58	;READ_OCR	0x7A, 122
    24                          
    25                          DATEND		equ	DATBUF + $200
    26                          
    27                          DATA_START_BLOCK	equ $FE
    28                          DATA_RES_MASK		equ $1F
    29                          DATA_RES_ACCEPTED	equ $05
    30                          
    31                          CMD0CHK		equ $95
    32                          CMD1CHK		equ $F9
    33                          CMD8CHK		equ $87
    34                          
    35                          R1_IDLE_STATE	equ 1
    36                          R1_ILLEGAL_COMMAND equ 4
    37                          
    38                          SDCS		equ	OP0
    39                          SDMOSI		equ	OP1
    40                          SDCLK		equ	OP2
    41                          SDMISO		equ	IP0
    42                          
    43                          FEOF		equ	$FF
    44                          FNOTFOUND	equ	$FE
    45                          
    46                          
    47                          ;--------------------------------------------------------------
    48                          ; Input
    49                          ; HL 	pointer to 4-byte seek-length
    50                          ;--------------------------------------------------------------
    51                          fseek:
    52   0002d6 cdb508          		call	isZero32			;first request?
    53   0002d9 2807            		jr	Z, fseek8
    54                          
    55   0002db 11a407          		ld	de, currpos			;no, currpos equal?
    56   0002de cd7508          		call	equal32
    57   0002e1 c8              		ret	z				;yes nothing to do
    58                          
    59   0002e2 e5              fseek8:		push	hl
    60   0002e3 cd5c04          		call	fopen1				;reset file-Ptr
    61                          
    62   0002e6 e1              		pop	hl
    63   0002e7 11bd07          		ld	de, bytesavail
    64   0002ea cd8608          		call	cmp32				;bytesavail - seeksize
    65   0002ed 3006            		jr	NC, fseek1			;seeksize <= bytesavail
    66   0002ef 3eff            		ld	a, FEOF				;no
    67   0002f1 32cb07          		ld	(fstatus), a
    68   0002f4 c9              		ret
    69                          
    70   0002f5 cd6408          fseek1:		call	sbc32				;byteavail -= seeklen
    71   0002f8 11a407          		ld	de, currpos			;currpos = seeklen
    72   0002fb cda908          		call	copy32
    73                          
    74   0002fe 11c907          		ld	de, datptr
    75   000301 7e              		ld	a, (hl)				;copy 9 bits to datptr
    76   000302 12              		ld	(de), a
    77   000303 4f              		ld	c, a				;save a in bc
    78   000304 23              		inc	hl
    79   000305 13              		inc	de
    80   000306 7e              		ld	a, (hl)
    81   000307 e601            		and	1
    82   000309 47              		ld	b, a				;save a in bc
    83   00030a c6fe            		add	DATBUF >> 8			;carry clear
    84   00030c 12              		ld	(de), a
    85   00030d c5              		push	bc
    86                          
    87   00030e 23              		inc	hl
    88   00030f 23              		inc	hl
    89   000310 11b707          		ld	de, datsec + 3
    90   000313 af              		xor	a				;clear 4th byte
    91   000314 12              		ld	(de), a
    92                          
    93   000315 0603            		ld	b, 3				;copy 3 bytes and shift right once
    94   000317 1b              fseek2:		dec	de				;giving datsec
    95   000318 7e              		ld	a, (hl)
    96   000319 1f              		rra
    97   00031a 12              		ld	(de), a
    98   00031b 2b              		dec	hl
    99   00031c 10f9            		djnz	fseek2
   100                          
   101   00031e af              		xor	a
   102   00031f c1              		pop	bc
   103   000320 210002          		ld	hl, $200
   104   000323 ed42            		sbc	hl, bc
   105   000325 22ba07          		ld	(bytes2read), hl
   106                          
   107   000328 21b407          		ld	hl, datsec			;copy datsec to var32
   108   00032b 118707          		ld	de, var32
   109   00032e cda908          		call	copy32
   110                          
   111   000331 3a6607          		ld	a, (secclus)			;rotate secclus bitposition to right
   112   000334 4f              		ld	c, a
   113   000335 cb19            fseek4:		rr	c
   114   000337 380c            		jr	C, fseek3			;done
   115   000339 0603            		ld	b, 3
   116   00033b 218907          		ld	hl, var32 + 2
   117   00033e cb1e            fseek5:		rr	(hl)
   118   000340 2b              		dec	hl
   119   000341 10fb            		djnz	fseek5
   120   000343 18f0            		jr	fseek4
   121                          
   122   000345 21b407          fseek3:		ld	hl, datsec			;datsec
   123   000348 3a6607          		ld	a, (secclus)
   124   00034b 3d              		dec	a
   125   00034c a6              		and	(hl)
   126   00034d 32d007          		ld	(fsecmask), a
   127   000350 47              		ld	b, a
   128   000351 3a6607          		ld	a, (secclus)
   129   000354 90              		sub	b
   130   000355 32bc07          		ld	(secs2read), a
   131                          
   132                          
   133   000358 2a8707          		ld	hl, (var32)
   134   00035b e5              fseek6:		push	hl				;traverse var32 + 1(firstclust) clusters
   135   00035c cd7604          		call	fatNextCluster
   136   00035f e1              		pop	hl
   137   000360 7d              		ld	a, l
   138   000361 b4              		or	a, h
   139   000362 2803            		jr	Z, fseek7
   140   000364 2b              		dec	hl
   141   000365 18f4            		jr	fseek6
   142                          
   143   000367 cd4d05          fseek7:		call	clust2sec
   144   00036a 3ad007          		ld	a, (fsecmask)
   145   00036d 328f07          		ld	(var8), a
   146   000370 11b407          		ld	de, datsec
   147   000373 218f07          		ld	hl, var8
   148   000376 cd9608          		call	add32
   149   000379 cd4706          		call	sdReadDat
   150                          
   151                          ;		ld	hl, (datptr)
   152                          ;		call	printadr
   153                          ;		ld	hl, (datsec)
   154                          ;		call	printadr
   155                          ;		ld	hl, (var32)
   156                          ;		call	printadr
   157                          ;		ld	hl, (bytesavail)
   158                          ;		call	printadr
   159                          ;		ld	hl, (bytes2read)
   160                          ;		call	printadr
   161                          ;		ld	a, (secs2read)
   162                          ;		call	printhexdebug
   163   00037c c9              		ret
   164                          
   165                          ;--------------------------------------------------------------
   166                          ; Input
   167                          ; BC	number of bytes to write
   168                          ; HL	pointer to buffer to read from
   169                          ;
   170                          ; Output
   171                          ; A	status, 0 = OK, negativ = Error
   172                          ;--------------------------------------------------------------
   173                          fwrite:
   174                          
   175                          ;--------------------------------------------------------------
   176                          ; Input
   177                          ; BC	number of bytes to read
   178                          ; HL	pointer to buffer
   179                          ;
   180                          ; Output
   181                          ; A	status, 0 = OK, negativ = Error
   182                          ;--------------------------------------------------------------
   183   00037d e5              fread:		push	hl
   184   00037e ed43c307        		ld	(freadbytes), bc		;bytes still to be read during fread
   185   000382 22c707          		ld	(fbuffer), hl			;save hl in fbuffer
   186   000385 af              		xor	a
   187   000386 32cb07          		ld	(fstatus), a			;clear status
   188   000389 67              		ld	h, a
   189   00038a 6f              		ld	l, a
   190   00038b 22c107          		ld	(fbytesread), hl		;clear fbytesread
   191                          
   192                          freadloop:
   193                          	IF FATDEBUG = 1
   194                          		call	fdump
   195                          	ENDIF
   196   00038e 21c307          		ld	hl, freadbytes			;bytes to be read?
   197   000391 cdb508          		call	isZero32
   198   000394 280d            		jr	Z, freadex			;no -> finished
   199                          
   200   000396 21bd07          		ld	hl, bytesavail			;are still bytes available?
   201   000399 cdb508          		call	isZero32
   202   00039c 200b            		jr	NZ, fread1
   203   00039e 3eff            		ld	a, FEOF
   204   0003a0 32cb07          		ld	(fstatus),a
   205   0003a3 e1              freadex:	pop	hl				;reload hl with adr of buffer
   206   0003a4 ed4bc107        		ld	bc, (fbytesread)		;load bc with bytes read
   207   0003a8 c9              		ret
   208                          
   209   0003a9 11bd07          fread1:		ld	de, bytesavail			;if bytesavail < freadbytes
   210   0003ac 21c307          		ld	hl, freadbytes
   211   0003af cd8608          		call	cmp32
   212   0003b2 3009            		jr	NC, fread2
   213   0003b4 3eff            		ld	a, FEOF
   214   0003b6 32cb07          		ld	(fstatus), a
   215   0003b9 eb              		ex	de, hl				;freadbytes = bytesavail
   216   0003ba cda908          		call	copy32
   217                          
   218   0003bd ed4bc307        fread2:		ld	bc, (freadbytes)
   219   0003c1 af              		xor	a				;clear carry
   220   0003c2 2aba07          		ld	hl, (bytes2read)		;if bytes2read < freadbytes?
   221   0003c5 ed42            		sbc	hl, bc
   222   0003c7 3004            		jr	NC, fread3
   223   0003c9 ed4bba07        		ld	bc, (bytes2read)
   224                          
   225   0003cd 78              fread3:		ld	a, b				;is bytes2read zero?
   226   0003ce b1              		or	a, c
   227   0003cf 201d            		jr	NZ, fread4			;no, continue coying data
   228                          
   229   0003d1 11b407          		ld	de, datsec			;increase data sector number
   230   0003d4 218307          		ld	hl, const1
   231   0003d7 cd9608          		call	add32
   232                          
   233   0003da 21bc07          		ld	hl, secs2read	 		;read new cluster?
   234   0003dd 35              		dec	(hl)
   235   0003de 2006            		jr	NZ, fread6			;not zero, just go with incremented sector-number
   236                          
   237   0003e0 cd7604          		call	fatNextCluster			;get next cluster in curclus
   238   0003e3 cd4d05          		call	clust2sec			;compute sector-number
   239                          
   240                          fread6:
   241   0003e6 cd2e04          		call	fatInitSector
   242                          
   243                          ;		ld	hl, (bytes2read)		;$200 to read?
   244                          ;		ld	(var16), hl
   245                          ;		ld	a, h
   246                          ;		cp	2
   247                          ;		jr	NZ, fread5
   248                          ;
   249                          ;		ld	hl, (fbuffer)			;write sector directly into receiving buffer
   250                          ;		call	sdReadSec
   251                          ;		ld	(fbuffer), hl
   252                          ;		jr	fread7
   253                          
   254                          fread5:
   255   0003e9 cd4706          		call	sdReadDat
   256   0003ec 18cf            		jr	fread2				;bytes2read is <> 0 so we always end up at fread4
   257                          
   258   0003ee ed438b07        fread4:		ld	(var16), bc			;copy available sector data to buffer
   259   0003f2 ed5bc707        		ld	de, (fbuffer)
   260   0003f6 2ac907          		ld	hl, (datptr)
   261   0003f9 edb0            		ldir
   262   0003fb ed53c707        		ld	(fbuffer), de
   263   0003ff 22c907          		ld	(datptr), hl
   264                          
   265   000402 af              fread7:		xor	a				;bytes2read -= var16
   266   000403 2aba07          		ld	hl, (bytes2read)
   267   000406 ed4b8b07        		ld	bc, (var16)
   268   00040a ed42            		sbc	hl, bc
   269   00040c 22ba07          		ld	(bytes2read), hl
   270                          
   271   00040f 2ac107          		ld	hl, (fbytesread)		;fbytesread += var16
   272   000412 09              		add	hl, bc
   273   000413 22c107          		ld	(fbytesread), hl
   274                          
   275   000416 11bd07          		ld	de, bytesavail			;bytesavail -= bytes2read
   276   000419 218b07          		ld	hl, var16
   277   00041c cd6408          		call	sbc32
   278                          
   279   00041f 11c307          		ld	de, freadbytes			;freadbytes -= bytes2read
   280   000422 cd6408          		call	sbc32
   281                          
   282   000425 11a407          		ld	de, currpos			;currpos += bytes2read
   283   000428 cd9608          		call	add32
   284   00042b c38e03          		jp	freadloop
   285                          
   286                          ;--------------------------------------------------------------
   287                          ;
   288                          ;--------------------------------------------------------------
   289                          fatInitSector:
   290   00042e 2100fe          		ld	hl, DATBUF			;datptr = DATBUF
   291   000431 22c907          		ld	(datptr), hl
   292                          
   293   000434 3a6607          		ld	a, (secclus)			;secs2read = secclus
   294   000437 32bc07          		ld	(secs2read), a
   295                          
   296   00043a 210002          		ld	hl, 512				;bytes to read = 512
   297   00043d 22ba07          		ld	(bytes2read), hl
   298                          
   299   000440 21c007          		ld	hl, bytesavail + 3
   300   000443 7e              		ld	a, (hl)				;if filesize < 512 then
   301   000444 2b              		dec	hl
   302   000445 b6              		or	a, (hl)
   303   000446 c0              		ret	NZ				;> $FFFF!
   304   000447 2b              		dec	hl
   305   000448 7e              		ld	a, (hl)
   306   000449 fe02            		cp	2				;>= $200?
   307   00044b d0              		ret	NC				;yes
   308                          
   309   00044c 2abd07          		ld	hl, (bytesavail)		;bytes2read = filesize
   310   00044f 22ba07          		ld	(bytes2read), hl
   311                          
   312   000452 c9              		ret
   313                          ;
   314                          ;
   315                          ;
   316   000453 cdad04          fopen:		call	dirSearch
   317   000456 2004            		jr	NZ, fopen1
   318   000458 3efe            		ld	a, FNOTFOUND
   319   00045a b7              		or	a
   320   00045b c9              		ret
   321                          
   322                          fopen1:
   323   00045c 11a407          		ld	de, currpos			;currpos = 0
   324   00045f cdc308          		call	clear32
   325                          
   326   000462 21a007          		ld	hl, filesize			;bytesavail = filesize
   327   000465 11bd07          		ld	de, bytesavail
   328   000468 cda908          		call	copy32
   329                          
   330   00046b 210000          		ld	hl, 0
   331   00046e 22ba07          		ld	(bytes2read), hl
   332   000471 22b807          		ld	(curclus), hl
   333                          
   334                          ;		dec	hl
   335                          ;		ld	(lastfatsec), hl
   336                          ;		ld	(lastfatsec + 2), hl
   337                          
   338   000474 af              		xor	a
   339   000475 c9              		ret
   340                          
   341                          ;--------------------------------------------------------------
   342                          ;
   343                          ;--------------------------------------------------------------
   344                          	IF FATDEBUG = 1
   345                          fdump:		ld	hl, (fbuffer)
   346                          		call	printadr
   347                          		ld	hl, (datptr)
   348                          		call	printadr
   349                          		ld	hl, (bytesavail)
   350                          		call	printadr
   351                          		ld	hl, (bytes2read)
   352                          		call	printadr
   353                          		ld	hl, (currpos)
   354                          		call	printadr
   355                          		ld	hl, (freadbytes)
   356                          		call	printadr
   357                          		ld	hl, (curclus)
   358                          		call	printadr
   359                          
   360                          		jp	newline
   361                          	ENDIF
   362                          
   363                          ;--------------------------------------------------------------
   364                          ; gets next cluster after curclus and stores in curclus
   365                          ;--------------------------------------------------------------
   366                          fatNextCluster:
   367   000476 2ab807          		ld	hl, (curclus)			;is curclus = 0, go with curclus = firstclust
   368   000479 7d              		ld	a, l
   369   00047a b4              		or	a, h
   370   00047b 2006            		jr	NZ, fatNextCluster1		;no
   371   00047d ed4b9e07        		ld	bc, (firstclust)
   372   000481 1825            		jr	fatNextCluster2
   373                          
   374                          fatNextCluster1:
   375   000483 217107          		ld	hl, fatbase			;computer FAT sector containing cluster
   376   000486 11a807          		ld	de, fatsector
   377   000489 cda908          		call	copy32
   378   00048c 3ab907          		ld	a, (curclus + 1)
   379   00048f 328f07          		ld	(var8), a
   380   000492 218f07          		ld	hl, var8
   381   000495 cd9608          		call	add32				;fatsector = fatbase + hi(firstclust)
   382   000498 cd3606          		call	sdReadFat
   383                          
   384   00049b 2ab807          		ld	hl, (curclus)			;lo(curclus) * 2
   385   00049e 2600            		ld	h, 0
   386   0004a0 29              		add	hl, hl
   387   0004a1 0100fc          		ld	bc, FATBUF
   388   0004a4 09              		add	hl, bc				;+ FATBUF
   389   0004a5 4e              		ld	c, (hl)
   390   0004a6 23              		inc	hl
   391   0004a7 46              		ld	b, (hl)
   392                          fatNextCluster2:
   393   0004a8 ed43b807        		ld	(curclus), bc
   394   0004ac c9              		ret
   395                          
   396                          ;--------------------------------------------------------------
   397                          ; search root-dir for file like "dirpattern"
   398                          ;--------------------------------------------------------------
   399   0004ad cdca04          dirSearch:	call	dirReadFirst			;read first root-entry
   400   0004b0 c8              dirSearch1:	ret	Z				;exit if zero
   401   0004b1 060b            		ld	b, 11				;compare 11-bytes of dir name
   402   0004b3 119307          		ld	de, dirpattern
   403   0004b6 1a              dirSearch2:	ld	a, (de)
   404   0004b7 fe3f            		cp	'?'
   405   0004b9 2803            		jr	Z, dirSearch3
   406   0004bb be              		cp	(hl)
   407   0004bc 2007            		jr	NZ, dirSearch4
   408   0004be 13              dirSearch3:	inc	de
   409   0004bf 23              		inc	hl
   410   0004c0 10f4            		djnz	dirSearch2
   411   0004c2 f601            		or	1
   412   0004c4 c9              		ret
   413   0004c5 cdfa04          dirSearch4:	call	dirReadNext			;get next dir
   414   0004c8 18e6            		jr	dirSearch1
   415                          ;
   416                          ;
   417                          ;
   418                          dirReadFirst:
   419   0004ca 217507          		ld	hl, dirbase			;from dirbase
   420   0004cd 117d07          		ld	de, dirsec			;to dirsec
   421   0004d0 cda908          		call	copy32
   422                          
   423                          dirReadSector:
   424   0004d3 cd4706          		call	sdReadDat			;load directory sectorgiven in DE
   425   0004d6 2100fe          		ld	hl, DATBUF 			;start at begin of dir-data
   426   0004d9 228107          		ld	(dirptr), hl
   427                          
   428   0004dc 7e              dirRead2:	ld	a, (hl)				;first byte of name zero?
   429   0004dd b7              		or	a
   430   0004de c8              		ret	Z				;yes, dir-ed reached, quit ZERO flag set
   431                          
   432   0004df e5              		push	hl
   433   0004e0 dde1            		pop	ix				;ix = hl
   434   0004e2 dd7e0b          		ld	a, (ix + 11)			;load attribute byte
   435   0004e5 e61f            		and	%00011111			;mask out archive ($20) and 2 highest bits
   436   0004e7 2014            		jr	NZ, dirRead1			;if no file -> next dir
   437                          
   438   0004e9 0606            		ld	b, 6
   439   0004eb 119e07          		ld	de, firstclust			;to firstclust, filesize
   440   0004ee dd7e1a          dirRead5:	ld	a, (ix + $1a)
   441   0004f1 12              		ld	(de), a
   442   0004f2 13              		inc	de
   443   0004f3 dd23            		inc	ix
   444   0004f5 10f7            		djnz	dirRead5
   445   0004f7 f601            		or	1				;reset ZERO flag
   446   0004f9 c9              		ret
   447                          
   448   0004fa 2a8107          dirReadNext:	ld	hl, (dirptr)
   449   0004fd 112000          dirRead1:	ld	de, 32				;hl = hl + 32
   450   000500 19              		add	hl, de
   451   000501 228107          		ld	(dirptr), hl
   452                          
   453   000504 7c              		ld	a, h
   454   000505 fe00            		cp	DATEND >> 8
   455   000507 20d3            		jr	NZ, dirRead2
   456                          
   457   000509 117d07          		ld	de, dirsec			;increment dirsector 32-bit
   458   00050c 218307          		ld	hl, const1
   459   00050f cd9608          		call	add32
   460   000512 18bf            		jr	dirReadSector
   461                          
   462                          ;--------------------------------------------------------------
   463                          ; prints entire directory
   464                          ;--------------------------------------------------------------
   465                          dirPrint:;	ld	hl, allpattern			;copy allpattern to dirpattern
   466                          	;	ld	de, dirpattern
   467                          	;	ld	bc, 11
   468                          	;	ldir
   469                          
   470   000514 cdca04          		call	dirReadFirst
   471   000517 c8              dirPrint1:	ret	Z				;return if zero
   472   000518 cd2005          		call	dirPrintEntry
   473   00051b cdfa04          		call	dirReadNext
   474   00051e 18f7            		jr	dirPrint1
   475                          
   476                          ;--------------------------------------------------------------
   477                          ; prints dir @ hl
   478                          ;--------------------------------------------------------------
   479   000520 e5              dirPrintEntry:	push	hl
   480   000521 2a8107          		ld	hl, (dirptr)			;print dir name 8 space 3
   481   000524 0608            		ld	b, 8
   482   000526 cd4505          		call	dirPrintEntry1
   483   000529 cde207          		call	space
   484   00052c 0603            		ld	b, 3
   485   00052e cd4505          		call	dirPrintEntry1
   486                          
   487   000531 cde207          		call	space
   488   000534 2aa207          		ld	hl, (filesize + 2)
   489   000537 cd5908          		call	printadr
   490   00053a 2aa007          		ld	hl, (filesize)
   491   00053d cd5908          		call	printadr
   492                          
   493   000540 cdea07          		call	newline
   494   000543 e1              		pop	hl
   495   000544 c9              		ret
   496                          
   497   000545 4e              dirPrintEntry1:	ld	c, (hl)
   498   000546 cdfc07          		call	chrout
   499   000549 23              		inc	hl
   500   00054a 10f9            		djnz	dirPrintEntry1
   501   00054c c9              		ret
   502                          
   503                          
   504                          ;--------------------------------------------------------------
   505                          ; computes the first data-sector from cluster-number
   506                          ;
   507                          ; datsec = (curclus - 2) * secclus + datbase
   508                          ; de : points to datsec
   509                          ;--------------------------------------------------------------
   510   00054d 2ab807          clust2sec:	ld	hl, (curclus)
   511   000550 2b              		dec	hl
   512   000551 2b              		dec	hl				;minus 2
   513   000552 110000          		ld	de, 0
   514   000555 3a6607          		ld	a, (secclus)
   515                          
   516   000558 1f              clust2sec2:	rra
   517   000559 380a            		jr	C, clust2sec1			;carry set, finished
   518   00055b cb15            		rl	l
   519   00055d cb14            		rl	h
   520   00055f cb13            		rl	e
   521   000561 cb12            		rl	d
   522   000563 18f3            		jr	clust2sec2
   523                          
   524   000565 22b407          clust2sec1:	ld	(datsec), hl
   525   000568 ed53b607        		ld	(datsec + 2), de
   526   00056c 11b407          		ld	de, datsec
   527   00056f 217907          		ld	hl, datbase
   528   000572 c39608          		jp	add32
   529                          
   530                          ;--------------------------------------------------------------
   531                          ;
   532                          ;--------------------------------------------------------------
   533   000575 cd0f07          sdInit:		call	sdDeselect
   534   000578 3e04            		ld	a, SDCLK			;bring SDCLK low
   535   00057a d30e            		out	(OPSET), a
   536   00057c 160c            		ld	d, 12				;clock 96 times
   537   00057e cd1607          		call	sdReadbyteX
   538                          
   539                          ;
   540                          ; send CMD0
   541                          ;
   542   000581 cd5507          		call	sdClrAdr
   543   000584 3e95            		ld	a, CMD0CHK			;load checksum
   544   000586 326407          		ld	(sdchk), a
   545   000589 3e40            sdInit1:	ld	a, CMD0				;command in A
   546   00058b cd3b07          		call	sdCardCmd
   547   00058e fe01            		cp	R1_IDLE_STATE
   548   000590 20e3            		jr	NZ, sdInit
   549                          
   550                          ;
   551                          ; send CMD8
   552                          ;
   553                          
   554   000592 cd5507          sdInit2:	call	sdClrAdr
   555   000595 2101aa          		ld	hl, $aa01
   556   000598 226207          		ld	(sdadr+2), hl
   557   00059b 3e87            		ld	a, CMD8CHK
   558   00059d 326407          		ld	(sdchk), a
   559   0005a0 3e48            		ld	a, CMD8
   560   0005a2 cd3b07          		call	sdCardCmd
   561                          ;		and	#R1_ILLEGAL_COMMAND
   562                          ;		cmp	#R1_ILLEGAL_COMMAND
   563                          ;		bne	sdInit3
   564                          
   565                          ;		ldx #3
   566                          ;		jsr readByteX
   567                          
   568                          
   569                          
   570                          ;
   571                          ; ACMD41 = CMD55 + CMD41
   572                          ;
   573   0005a5 cd0f07          sdInit6:	call	sdDeselect
   574   0005a8 cd5507          		call	sdClrAdr
   575   0005ab 3e77            		ld	a, CMD55
   576   0005ad cd3b07          		call	sdCardCmd
   577                          
   578   0005b0 3e40            		ld	a, $40
   579   0005b2 326007          		ld	(sdadr), a
   580   0005b5 3e69            		ld	a, CMD41
   581   0005b7 cd3b07          		call	sdCardCmd
   582   0005ba 20e9            		jr	NZ, sdInit6			;result not 0, start over
   583                          
   584                          ;sdInit4:	call	sdDeselect
   585                          ;		ld	a, CMD58			;read OCR, ($3A)
   586                          ;		ld	(sdcmd), a
   587                          ;		call	sdCardCmd
   588                          ;		jr	NZ, sdInit4
   589                          ;
   590                          ;		ld	d, 3
   591                          ;		call	sdReadbyteX
   592                          
   593   0005bc 11a807          		ld	de, fatsector			;read sector 0
   594   0005bf cdc308          		call	clear32
   595   0005c2 cd3606          		call	sdReadFat
   596                          
   597   0005c5 2100fc          		ld	hl, FATBUF			;from
   598   0005c8 01c601          		ld	bc, $1c6			;sdbuffer + $1c6
   599   0005cb 09              		add	hl, bc
   600   0005cc 11a807          		ld	de, fatsector			;to fatsector
   601   0005cf cda908          		call	copy32
   602                          
   603   0005d2 cd3606          		call	sdReadFat
   604                          
   605   0005d5 2100fc          		ld	hl, FATBUF			;from
   606   0005d8 010d00          		ld	bc, 13				;sdbuffer + 13
   607   0005db 09              		add	hl, bc
   608   0005dc 116607          		ld	de, secclus			;to secclus
   609   0005df 010b00          		ld	bc, 11				;copy 11-bytes
   610   0005e2 edb0            		ldir
   611                          
   612                          
   613   0005e4 2a6707          		ld	hl, (ressec)			;fatbase = dirbase = fatsector + ressec
   614   0005e7 228b07          		ld	(var16), hl			;copy resec to var16
   615   0005ea 21a807          		ld	hl, fatsector			;copy sdsector to fatbase
   616   0005ed 117107          		ld	de, fatbase
   617   0005f0 cda908          		call	copy32
   618   0005f3 218b07          		ld	hl, var16			;add resec to fatbase
   619   0005f6 cd9608          		call	add32
   620   0005f9 eb              		ex	de, hl				;copy fatbase to dirbase
   621   0005fa 117507          		ld	de, dirbase
   622   0005fd cda908          		call	copy32
   623                          
   624   000600 2a6f07          		ld	hl, (secsfat)
   625   000603 228b07          		ld	(var16), hl
   626   000606 218b07          		ld	hl, var16
   627   000609 3a6907          		ld	a, (numfats)			;dirbase += secsfat * numfats
   628   00060c 47              		ld	b, a
   629   00060d cd9608          fatCompDirbase:	call	add32
   630   000610 10fb            		djnz	fatCompDirbase
   631                          
   632                          							;datbase = (numdir / 16) + dirbase
   633   000612 2a6a07          		ld	hl, (numdir)			;datbase = numdir
   634   000615 0604            		ld	b, 4
   635   000617 cb3c            fatcompDatbase:	srl	h
   636   000619 cb1d            		rr	l
   637   00061b 10fa            		djnz	fatcompDatbase
   638                          
   639   00061d ed5b7507        		ld	de, (dirbase)
   640   000621 19              		add	hl, de				;datbase += dirbase
   641   000622 227907          		ld	(datbase), hl
   642   000625 c9              		ret
   643                          
   644                          ;--------------------------------------------------------------
   645                          ; DE: address of 4-byte sector number
   646                          ;--------------------------------------------------------------
   647   000626 216307          sdSetSector:	ld	hl, sdadr + 3
   648   000629 af              		xor	a
   649   00062a 77              		ld	(hl), a
   650   00062b 2b              		dec	hl
   651   00062c 0603            		ld	b, 3
   652   00062e 1a              sdSetSector1:	ld	a, (de)
   653                          	if DEBUG = 1
   654                          		call	printhexdebug
   655                          	endif
   656   00062f 17              		rla
   657   000630 77              		ld	(hl), a
   658   000631 13              		inc	de
   659   000632 2b              		dec	hl
   660   000633 10f9            		djnz	sdSetSector1
   661   000635 c9              		ret
   662                          
   663                          ;--------------------------------------------------------------
   664                          ;
   665                          ;--------------------------------------------------------------
   666                          sdReadFat:
   667   000636 21ac07          		ld	hl, lastfatsec			;FAT sector in DE already read?
   668   000639 cd7508          		call	equal32
   669   00063c c8              		ret	Z				;yes
   670                          
   671   00063d eb              		ex	de, hl				;copy sector to lastfatsec
   672   00063e cda908          		call	copy32
   673   000641 eb              		ex	de, hl
   674                          
   675   000642 2100fc          		ld	hl, FATBUF
   676   000645 180f            		jr	sdReadSec
   677                          
   678                          ;--------------------------------------------------------------
   679                          ; reads one sector in (DE) into DATBUF
   680                          ;--------------------------------------------------------------
   681                          sdReadDat:
   682   000647 21b007          		ld	hl, lastdatsec			;FAT sector in DE already read?
   683   00064a cd7508          		call	equal32
   684   00064d c8              		ret	Z				;yes
   685                          
   686   00064e eb              		ex	de, hl				;copy sector to lastdatsec
   687   00064f cda908          		call	copy32
   688   000652 eb              		ex	de, hl
   689   000653 2100fe          		ld	hl, DATBUF
   690                          
   691                          ;--------------------------------------------------------------
   692                          ; hl		buffer to load data into
   693                          ; de		pointer to 4-byte sector number
   694                          ;--------------------------------------------------------------
   695   000656 e5              sdReadSec:	push	hl
   696   000657 cd2606          		call	sdSetSector
   697   00065a 3e51            		ld	a, CMD17			;read block
   698   00065c cd3b07          		call	sdCardCmd
   699                          
   700   00065f cd1d07          sdReadSec2:	call	sdReadByte			;data token until $FE, i.e. bit 0 = 0;
   701   000662 cb19            		rr	c
   702   000664 38f9            		jr	C, sdReadSec2
   703                          
   704   000666 3e02            		ld	a, SDMOSI
   705   000668 d30f            		out	(OPRES), a			;SDMOSI = 1
   706                          
   707   00066a e1              		pop	hl
   708   00066b 110002          		ld	de, 512				;read 512 bytes
   709   00066e 0604            		ld	b, SDCLK
   710                          sdReadSec1:
   711   000670 db0d            		in	a, (INPORT)
   712   000672 1f              		rra
   713   000673 cb11            		rl	c
   714   000675 78              		ld	a, b
   715   000676 d30f            		out	(OPRES), a			;sdClock high
   716   000678 d30e            		out	(OPSET), a			;sdClock low
   717   00067a db0d            		in	a, (INPORT)
   718   00067c 1f              		rra
   719   00067d cb11            		rl	c
   720   00067f 78              		ld	a, b
   721   000680 d30f            		out	(OPRES), a			;sdClock high
   722   000682 d30e            		out	(OPSET), a			;sdClock low
   723   000684 db0d            		in	a, (INPORT)
   724   000686 1f              		rra
   725   000687 cb11            		rl	c
   726   000689 78              		ld	a, b
   727   00068a d30f            		out	(OPRES), a			;sdClock high
   728   00068c d30e            		out	(OPSET), a			;sdClock low
   729   00068e db0d            		in	a, (INPORT)
   730   000690 1f              		rra
   731   000691 cb11            		rl	c
   732   000693 78              		ld	a, b
   733   000694 d30f            		out	(OPRES), a			;sdClock high
   734   000696 d30e            		out	(OPSET), a			;sdClock low
   735   000698 db0d            		in	a, (INPORT)
   736   00069a 1f              		rra
   737   00069b cb11            		rl	c
   738   00069d 78              		ld	a, b
   739   00069e d30f            		out	(OPRES), a			;sdClock high
   740   0006a0 d30e            		out	(OPSET), a			;sdClock low
   741   0006a2 db0d            		in	a, (INPORT)
   742   0006a4 1f              		rra
   743   0006a5 cb11            		rl	c
   744   0006a7 78              		ld	a, b
   745   0006a8 d30f            		out	(OPRES), a			;sdClock high
   746   0006aa d30e            		out	(OPSET), a			;sdClock low
   747   0006ac db0d            		in	a, (INPORT)
   748   0006ae 1f              		rra
   749   0006af cb11            		rl	c
   750   0006b1 78              		ld	a, b
   751   0006b2 d30f            		out	(OPRES), a			;sdClock high
   752   0006b4 d30e            		out	(OPSET), a			;sdClock low
   753   0006b6 db0d            		in	a, (INPORT)
   754   0006b8 1f              		rra
   755   0006b9 cb11            		rl	c
   756   0006bb 78              		ld	a, b
   757   0006bc d30f            		out	(OPRES), a			;sdClock high
   758   0006be d30e            		out	(OPSET), a			;sdClock low
   759                          
   760   0006c0 71              		ld	(hl), c
   761   0006c1 23              		inc	hl
   762   0006c2 1d              		dec	e
   763   0006c3 c27006          		jp	NZ, sdReadSec1
   764   0006c6 15              		dec	d
   765   0006c7 20a7            		jr	NZ, sdReadSec1
   766                          
   767   0006c9 1602            		ld	d, 2				;2-byte checksum
   768   0006cb cd1607          		call	sdReadbyteX
   769   0006ce cd0f07          		call	sdDeselect
   770   0006d1 c9              		ret
   771                          
   772                          
   773                          ;--------------------------------------------------------------
   774                          ; writes one sector in (DE) into DATBUF
   775                          ;--------------------------------------------------------------
   776   0006d2 2100fe          sdWriteDat:	ld	hl, DATBUF
   777                          ;--------------------------------------------------------------
   778                          ; hl		buffer to copy data from
   779                          ; de		pointer to 4-byte sector number
   780                          ;--------------------------------------------------------------
   781   0006d5 e5              sdWriteSec:	push	hl
   782   0006d6 cd2606          		call	sdSetSector
   783   0006d9 3e58            		ld	a, CMD24			;write sector
   784   0006db cd3b07          		call	sdCardCmd
   785                          
   786   0006de 0efe            		ld	c, DATA_START_BLOCK
   787   0006e0 cd1f07          		call	sdSendByte
   788                          
   789   0006e3 e1              		pop	hl
   790   0006e4 110002          		ld	de, 512				;read 512 bytes
   791   0006e7 4e              sdWriteSec1:	ld	c, (hl)
   792   0006e8 cd1f07          		call	sdSendByte
   793   0006eb 23              		inc	hl
   794   0006ec 1d              		dec	e
   795   0006ed c2e706          		jp	NZ, sdWriteSec1
   796   0006f0 15              		dec	d
   797   0006f1 20f4            		jr	NZ, sdWriteSec1
   798                          
   799   0006f3 cd1d07          sdWriteSec2:	call	sdReadByte
   800   0006f6 79              		ld	a, c
   801   0006f7 feff            		cp	$FF
   802   0006f9 28f8            		jr	Z, sdWriteSec2			;loop if $ff
   803                          
   804                          ;		and	DATA_RES_MASK			;assume data accepted
   805                          ;		cp	DATA_RES_ACCEPTED		; "00000101" = 5 ?
   806                          
   807   0006fb cd0607          		call	sdWait
   808   0006fe cd0f07          		call	sdDeselect
   809   000701 c9              		ret
   810                          
   811                          ;--------------------------------------------------------------
   812                          ;
   813                          ;--------------------------------------------------------------
   814   000702 3e01            sdSelect:	ld	a, SDCS
   815   000704 d30e            		out	(OPSET), a			;SDCS low (active)
   816   000706 cd1d07          sdWait:		call	sdReadByte
   817   000709 3eff            		ld	a, 255
   818   00070b b9              		cp	c
   819   00070c 20f8            		jr	NZ, sdWait
   820   00070e c9              		ret
   821                          
   822                          ;--------------------------------------------------------------
   823                          ;
   824                          ;--------------------------------------------------------------
   825   00070f 3e01            sdDeselect:	ld	a, SDCS
   826   000711 d30f            		out	(OPRES), a
   827   000713 c31d07          		jp	sdReadByte
   828                          
   829                          ;--------------------------------------------------------------
   830                          ;
   831                          ;--------------------------------------------------------------
   832   000716 cd1d07          sdReadbyteX:	call	sdReadByte
   833   000719 15              		dec	d
   834   00071a 20fa            		jr	NZ, sdReadbyteX
   835   00071c c9              		ret
   836                          
   837                          ;--------------------------------------------------------------
   838                          ; Input
   839                          ; c		byte to send to sd-card
   840                          ;--------------------------------------------------------------
   841   00071d 0eff            sdReadByte:	ld	c, $ff
   842   00071f 0608            sdSendByte:	ld	b, 8
   843   000721 db0d            sdSendByte2:	in	a, (INPORT)
   844   000723 1f              		rra
   845   000724 cb11            		rl	c
   846   000726 3e02            		ld	a, SDMOSI
   847   000728 da3007          		jp	C, sdSendByte4
   848   00072b d30e            		out	(OPSET), a			;carry 0, SDMOSI = 0
   849   00072d c33207          		jp	sdSendByte3
   850   000730 d30f            sdSendByte4:	out	(OPRES), a			;carry 1, SDMOSI = 1
   851   000732 3e04            sdSendByte3:	ld	a, SDCLK
   852   000734 d30f            		out	(OPRES), a			;sdClock high
   853   000736 d30e            		out	(OPSET), a			;sdClock low
   854   000738 10e7            		djnz	sdSendByte2
   855   00073a c9              		ret
   856                          
   857                          ;--------------------------------------------------------------
   858                          ; sends command in A to SD card
   859                          ;--------------------------------------------------------------
   860   00073b 215f07          sdCardCmd:	ld	hl, sdcmd
   861   00073e 77              		ld	(hl), a
   862                          
   863                          	if DEBUG = 1
   864                          		ld	c, 'C'
   865                          		call	chroutdebug
   866                          		call	printhexdebug
   867                          		call	spacedebug
   868                          	endif
   869                          
   870   00073f 1606            sdCardCmd3:	ld	d, 6
   871   000741 cd0207          		call	sdSelect
   872   000744 4e              sdCardCmd1:	ld	c, (hl)
   873   000745 cd1f07          		call	sdSendByte
   874   000748 23              		inc	hl
   875   000749 15              		dec	d
   876   00074a 20f8            		jr	NZ, sdCardCmd1
   877   00074c cd1d07          sdCardCmd2:	call	sdReadByte
   878   00074f 79              		ld	a, c
   879                          	if DEBUG = 1
   880                          		call	printhexdebug
   881                          	endif
   882   000750 b7              		or	a, a
   883   000751 fa4c07          		jp	M, sdCardCmd2
   884                          	if DEBUG = 1
   885                          		call	spacedebug
   886                          	endif
   887                          
   888   000754 c9              		ret
   889                          
   890                          ;--------------------------------------------------------------
   891                          ;
   892                          ;--------------------------------------------------------------
   893   000755 210000          sdClrAdr:	ld	hl, 0
   894   000758 226007          		ld	(sdadr), hl
   895   00075b 226207          		ld	(sdadr + 2), hl
   896   00075e c9              		ret
   897                          
   898                          	if DEBUG = 1
   899                          printadrdebug:
   900                          		push	af
   901                          		ld	a, (debug)
   902                          		or	a
   903                          		jr	Z, printadrdebex
   904                          		pop	af
   905                          		jp	printadr
   906                          printadrdebex:	pop	af
   907                          		ret
   908                          
   909                          
   910                          printhexdebug:
   911                          		push	af
   912                          		ld	a, (debug)
   913                          		or	a
   914                          		jr	Z, printhexdex
   915                          		pop	af
   916                          		jp	printhex
   917                          printhexdex:	pop	af
   918                          		ret
   919                          
   920                          
   921                          
   922                          chroutdebug:
   923                          		push	af
   924                          		ld	a, (debug)
   925                          		or	a
   926                          		jr	Z, chroutdebugex
   927                          		pop	af
   928                          		jp	chrout
   929                          chroutdebugex:	pop	af
   930                          		ret
   931                          
   932                          spacedebug:
   933                          		push	af
   934                          		ld	a, (debug)
   935                          		or	a
   936                          		jr	Z, spacedebugex
   937                          		pop	af
   938                          		jp	space
   939                          spacedebugex:	pop	af
   940                          		ret
   941                          
   942                          newlinedebug:
   943                          		push	af
   944                          		ld	a, (debug)
   945                          		or	a
   946                          		jr	Z, newlinedebugex
   947                          		pop	af
   948                          		jp	newline
   949                          newlinedebugex:	pop	af
   950                          		ret
   951                          	endif
   952                          
   953                          ;--------------------------------------------------------------
   954                          ; variables and constants
   955                          ;--------------------------------------------------------------
   956   00075f 00              sdcmd:		db	0			;1-byte SD card command
   957   000760 00000000        sdadr:		db	0, 0, 0, 0		;4-byte SD card address
   958   000764 00              sdchk:		db	0			;1-byte SD card checksum
   959   000765 00              sdres:		db	0			;1-byte SD card R1 result
   960                          
   961                          ;
   962                          ; FATBUF + 13, 11-bytes holding basic FAT info
   963   000766 00              secclus:	db	0			;1-byte FAT sectors per cluster
   964   000767 0000            ressec:		db	0, 0			;2-byte	DAT reserved sectors
   965   000769 00              numfats:	db	0			;1-byte number of FATS
   966   00076a 0000            numdir:		db	0, 0			;2-byte max number of 32-bytes root directoy entries
   967   00076c 0000            numsecs:	db	0, 0			;2-byte number of sectors in this volume
   968   00076e 00              media:		db	0			;1-byte 0xF8 is the standard value for fixed (nonremovable) media. For removable media, 0xF0 is frequently used.
   969   00076f 0000            secsfat:	db	0, 0			;2-byte FAT12/FAT16 16-bit count of sectors occupied by one FAT
   970                          
   971   000771 00000000        fatbase:	db	0, 0, 0, 0		;4-byte	first sector of FAT
   972   000775 00000000        dirbase:	db	0, 0, 0, 0		;4-byte	first sector of root directory
   973   000779 00000000        datbase:	db	0, 0, 0, 0		;4-byte	first sector of data section
   974                          
   975   00077d 00000000        dirsec:		db	0, 0, 0, 0		;4-byte	current sector of root directory
   976   000781 0000            dirptr:		dw	0			;2-byte pointer in directory data
   977                          						;32-byte directory structure
   978                          ;dirname:	dw	0, 0, 0, 0		;8-byte
   979                          ;dirext:		db 0, 0, 0		;3-byte
   980                          ;dirattr:	db	0			;1-byte
   981                          ;dirreserved:	db	0			;1-byte
   982                          ;dirdatetime:	db	0, 0, 0, 0, 0, 0, 0	;7-byte
   983                          ;dirclusthi:	dw	0			;2-byte (always 0 for FAT16)
   984                          ;dirwritetd:	dw	0, 0			;4-byte write time/date
   985                          ;dircluster:	dw	0			;2-byte first cluster of data
   986                          ;dirfilesize:	dw	0, 0			;4-byte size of file in bytes
   987                          
   988   000783 01000000        const1:		db	1, 0, 0, 0		;4-byte const1
   989   000787 00000000        var32:		dw	0, 0
   990   00078b 00000000        var16:		dw	0, 0
   991   00078f 00000000        var8:		dw	0, 0
   992                          
   993   000793 4449534b30303f3fdirpattern:	db	"DISK00??DSK"	;
                44534b          
   994                          ;allpattern:	db	"???????????"	;
   995                          ;kilopattern:	db	"KILO????C??"	;
   996                          
   997                          ;
   998                          ; file related data
   999                          ;
  1000   00079e 0000            firstclust:	dw 0				;2-byte first cluster of file
  1001   0007a0 00000000        filesize:	dw 0, 0				;4-byte length of file
  1002   0007a4 00000000        currpos:	dw 0, 0
  1003                          
  1004   0007a8 00000000        fatsector:	dw 0, 0				;4-byte actual FAT sector read
  1005   0007ac ffffffff        lastfatsec:	dw $ffff, $ffff			;4-byte last read FAT sector
  1006   0007b0 ffffffff        lastdatsec:	dw $ffff, $ffff			;4-byte last read data sector
  1007   0007b4 00000000        datsec:		dw 0, 0				;4-byte current data sector read
  1008   0007b8 0000            curclus:	dw 0				;2-byte current cluster
  1009   0007ba 0000            bytes2read:	dw 0				;2-byte remaining bytes in sector to read
  1010   0007bc 00              secs2read:	db 0				;1-byte sectors to read in cluster
  1011   0007bd 00000000        bytesavail:	dw 0, 0				;4-byte bytes still available in file
  1012   0007c1 0000            fbytesread:	dw 0				;2-byte bytes read during fread
  1013   0007c3 00000000        freadbytes:	dw 0, 0				;4-byte
  1014   0007c7 0000            fbuffer:	dw 0				;2-byte buffer data to be copied to
  1015   0007c9 0000            datptr:		dw 0				;2-byte pointer into data sector
  1016   0007cb 00              fstatus:	db 0				;1-byte status of operation
  1017   0007cc 00000000        fseeklen:	dw 0, 0				;4-byte length of fseek
  1018   0007d0 00              fsecmask:	db 0				;1-byte mask for sector in fseek
  1019                          
cpm22bios.asm:
   509                          		include "common.asm"
common.asm:
     1                          ;--------------------------------------------------------------
     2                          ;
     3                          ;--------------------------------------------------------------
     4                          copystr:
     5   0007d1 7e              		ld	a, (HL)
     6   0007d2 b7              		or	a
     7   0007d3 c8              		ret	Z
     8   0007d4 12              		ld	(DE), a
     9   0007d5 23              		inc	HL
    10   0007d6 13              		inc	DE
    11   0007d7 18f8            		jr	copystr
    12                          
    13                          ;--------------------------------------------------------------
    14                          ;
    15                          ;--------------------------------------------------------------
    16                          printstr:
    17   0007d9 af              		xor	a
    18   0007da 86              		add	a, (HL)
    19   0007db c8              		ret	Z
    20   0007dc cdfb07          		call	chrouta
    21   0007df 23              		inc	HL
    22   0007e0 18f7            		jr	printstr
    23                          
    24                          ;--------------------------------------------------------------
    25                          ;
    26                          ;--------------------------------------------------------------
    27                          space:
    28   0007e2 c5              		push	bc
    29   0007e3 0e20            		ld	c, 32
    30   0007e5 cdfc07          		call	chrout
    31   0007e8 c1              		pop	bc
    32   0007e9 c9              		ret
    33                          
    34                          ;--------------------------------------------------------------
    35                          ;
    36                          ;--------------------------------------------------------------
    37                          newline:
    38   0007ea c5              		push	bc
    39   0007eb 0e0d            		ld	c, 13
    40   0007ed cdfc07          		call	chrout
    41   0007f0 c1              		pop	bc
    42   0007f1 c9              		ret
    43                          ;		ld	c, 10
    44                          ;		jp	chrout
    45                          
    46                          ;--------------------------------------------------------------
    47                          ; get a character in A from rs232 (1)
    48                          ;
    49                          ;--------------------------------------------------------------
    50                          chrin:
    51   0007f2 db01            		in	a, (STATA)
    52   0007f4 e601            		and	a, 1
    53   0007f6 28fa            		jr	Z, chrin
    54   0007f8 db03            		in	a, (RECA)
    55   0007fa c9              		ret
    56                          
    57                          ;--------------------------------------------------------------
    58                          ; output a character in A over rs232 (1)
    59                          ;--------------------------------------------------------------
    60                          chrouta:
    61   0007fb 4f              		ld	c, a
    62                          chrout:
    63   0007fc f5              		push	AF
    64   0007fd db01            chrout1:	in	a, (STATA)
    65   0007ff e604            		and	a, 4
    66   000801 28fa            		jr	Z, chrout1
    67   000803 79              		ld	a, c
    68   000804 d303            		out	(TRANSA), a
    69   000806 f1              		pop	AF
    70   000807 c9              		ret
    71                          
    72                          ;--------------------------------------------------------------
    73                          ; get a character in A from rs232 (2)
    74                          ;
    75                          ;--------------------------------------------------------------
    76   000808 010000          serin:		ld	bc, 0
    77   00080b db09            serin1:		in	a, (STATB)
    78   00080d e601            		and	a, 1
    79   00080f 2007            		jr	NZ, serin2
    80   000811 10f8            		djnz	b, serin1
    81   000813 0d              		dec	c
    82   000814 20f5            		jr	NZ, serin1
    83   000816 37              		scf
    84   000817 c9              		ret
    85   000818 db0b            serin2:		in	a, (RECB)
    86   00081a c9              		ret
    87                          
    88                          ;--------------------------------------------------------------
    89                          ; output a character in A over rs232 (1)
    90                          ;
    91                          ;--------------------------------------------------------------
    92                          serout:
    93   00081b f5              		push	AF
    94   00081c db09            serout1:	in	a, (STATB)
    95   00081e e604            		and	a, 4
    96   000820 28fa            		jr	Z, serout1
    97   000822 f1              		pop	AF
    98   000823 d30b            		out	(TRANSB), a
    99   000825 c9              		ret
   100                          
   101                          ;--------------------------------------------------------------
   102                          ; prints byte in A in hexadecimal format
   103                          ;--------------------------------------------------------------
   104                          printhex:
   105   000826 f5              		push    AF
   106   000827 f5              		push    AF
   107   000828 1f              		rra
   108   000829 1f              		rra
   109   00082a 1f              		rra
   110   00082b 1f              		rra
   111   00082c cd3508          		call    printnib
   112   00082f f1              		pop     AF
   113   000830 cd3508          		call    printnib
   114   000833 f1              		pop     AF
   115   000834 c9              		ret
   116                          printnib:
   117   000835 e60f            		and     0fh
   118   000837 fe0a            		cp      0ah
   119   000839 3802            		jr      C, printnib1
   120   00083b c607            		add     a, 07h
   121                          printnib1:
   122   00083d c630            		add     a, '0'
   123                          ;print:
   124   00083f c5              		push    BC
   125   000840 4f              		ld      c, a
   126   000841 cdfc07          		call    chrout
   127   000844 c1              		pop     BC
   128   000845 c9              		ret
   129                          
   130                          ;--------------------------------------------------------------
   131                          ;
   132                          ;--------------------------------------------------------------
   133   000846 e5              printstack:	push	hl
   134   000847 210000          		ld	hl, 0
   135   00084a 39              		add	hl, sp
   136   00084b cd5908          		call	printadr
   137   00084e e1              		pop	hl
   138   00084f c9              		ret
   139                          
   140                          ;--------------------------------------------------------------
   141                          ;
   142                          ;--------------------------------------------------------------
   143                          getupper:
   144   000850 cdf207          		call	chrin
   145   000853 fe61            		cp	'a'
   146   000855 d8              		ret	C
   147   000856 d620            		sub	32
   148   000858 c9              		ret
   149                          
   150                          ;--------------------------------------------------------------
   151                          ;
   152                          ;--------------------------------------------------------------
   153   000859 7c              printadr:	ld	a, h
   154   00085a cd2608          		call	printhex
   155   00085d 7d              		ld	a, l
   156   00085e cd2608          		call	printhex
   157   000861 c3e207          		jp	space
   158                          ;--------------------------------------------------------------
   159                          ;	(de, Carry) = (de) - (hl)
   160                          ;--------------------------------------------------------------
   161   000864 c5              sbc32:		push	bc
   162   000865 d5              		push	de
   163   000866 e5              		push	hl
   164                          
   165   000867 b7              		or	a				;clear carry
   166   000868 0604            		ld	b, 4				;sbc 4 bytes
   167   00086a 1a              sbc32a:		ld	a, (de)
   168   00086b 9e              		sbc	(hl)
   169   00086c 12              		ld	(de), a
   170   00086d 13              		inc	de
   171   00086e 23              		inc	hl
   172   00086f 10f9            		djnz	sbc32a
   173                          
   174   000871 e1              		pop	hl
   175   000872 d1              		pop	de
   176   000873 c1              		pop	bc
   177   000874 c9              		ret
   178                          
   179                          ;--------------------------------------------------------------
   180                          ;	Z = (DE == HL)
   181                          ;--------------------------------------------------------------
   182   000875 c5              equal32:	push	bc
   183   000876 d5              		push	de
   184   000877 e5              		push	hl
   185                          
   186   000878 0604            		ld	b, 4				;cmp 4 bytes
   187   00087a 1a              equal32a:	ld	a, (de)
   188   00087b be              		cp	a, (hl)
   189   00087c 2004            		jr	NZ, equal32b
   190   00087e 13              		inc	de
   191   00087f 23              		inc	hl
   192   000880 10f8            		djnz	equal32a
   193                          
   194   000882 e1              equal32b:	pop	hl
   195   000883 d1              		pop	de
   196   000884 c1              		pop	bc
   197   000885 c9              		ret
   198                          
   199                          ;--------------------------------------------------------------
   200                          ;	Carry = (de) - (hl)
   201                          ;--------------------------------------------------------------
   202   000886 c5              cmp32:		push	bc
   203   000887 d5              		push	de
   204   000888 e5              		push	hl
   205                          
   206   000889 b7              		or	a				;clear carry
   207   00088a 0604            		ld	b, 4				;cmp 4 bytes
   208   00088c 1a              cmp32a:		ld	a, (de)
   209   00088d 9e              		sbc	a, (hl)
   210   00088e 13              		inc	de
   211   00088f 23              		inc	hl
   212   000890 10fa            		djnz	cmp32a
   213                          
   214   000892 e1              		pop	hl
   215   000893 d1              		pop	de
   216   000894 c1              		pop	bc
   217   000895 c9              		ret
   218                          
   219                          ;--------------------------------------------------------------
   220                          ;	(de) = (hl) + (de)
   221                          ;--------------------------------------------------------------
   222   000896 f5              add32:		push	af
   223   000897 c5              		push	bc
   224   000898 d5              		push	de
   225   000899 e5              		push	hl
   226                          
   227   00089a b7              		or	a				;clear carry
   228   00089b 0604            		ld	b, 4				;add 4 bytes
   229   00089d 1a              add32a:		ld	a, (de)
   230   00089e 8e              		adc	(hl)
   231   00089f 12              		ld	(de), a
   232   0008a0 23              		inc	hl
   233   0008a1 13              		inc	de
   234   0008a2 10f9            		djnz	add32a
   235                          
   236   0008a4 e1              		pop	hl
   237   0008a5 d1              		pop	de
   238   0008a6 c1              		pop	bc
   239   0008a7 f1              		pop	af
   240   0008a8 c9              		ret
   241                          
   242                          ;--------------------------------------------------------------
   243                          ;	(de) = (hl)
   244                          ;--------------------------------------------------------------
   245   0008a9 c5              copy32:		push	bc
   246   0008aa d5              		push	de
   247   0008ab e5              		push	hl
   248                          
   249   0008ac 010400          		ld	bc, 4
   250   0008af edb0            		ldir
   251                          
   252   0008b1 e1              		pop	hl
   253   0008b2 d1              		pop	de
   254   0008b3 c1              		pop	bc
   255   0008b4 c9              		ret
   256                          
   257                          ;--------------------------------------------------------------
   258                          ; are all 4 bytes hl is pointing to zero?
   259                          ;--------------------------------------------------------------
   260   0008b5 c5              isZero32:	push	bc
   261   0008b6 e5              		push	hl
   262   0008b7 af              		xor	a
   263   0008b8 0604            		ld	b, 4
   264   0008ba b6              isZero32a:	or	(hl)
   265   0008bb 2003            		jr	NZ, isZero32b
   266   0008bd 23              		inc	hl
   267   0008be 10fa            		djnz	isZero32a
   268   0008c0 e1              isZero32b:	pop	hl
   269   0008c1 c1              		pop	bc
   270   0008c2 c9              		ret
   271                          
   272                          ;--------------------------------------------------------------
   273                          ;
   274                          ;	(DE) = 4 x zeros
   275                          ;--------------------------------------------------------------
   276   0008c3 f5              clear32:	push	af
   277   0008c4 c5              		push	bc
   278   0008c5 d5              		push	de
   279   0008c6 af              		xor	a
   280   0008c7 0604            		ld	b, 4
   281   0008c9 12              clear32a:	ld	(de), a
   282   0008ca 13              		inc	de
   283   0008cb 10fc            		djnz	clear32a
   284   0008cd d1              		pop	de
   285   0008ce c1              		pop	bc
   286   0008cf f1              		pop	af
   287   0008d0 c9              		ret
   288                          
   289                          ;--------------------------------------------------------------
   290                          ;; multiply DE and BC
   291                          ;; DE is equivalent to the number in the top row in our algorithm
   292                          ;; and BC is equivalent to the number in the bottom row in our algorithm
   293                          ;--------------------------------------------------------------
   294                          mul16:
   295   0008d1 3e10            		ld 	a, 16				; this is the number of bits of the number to process
   296   0008d3 210000          		ld 	hl, 0				; HL is updated with the partial result, and at the end it will hold
   297                          							; the final result.
   298                          mul16loop:
   299   0008d6 cb38            		srl	b
   300   0008d8 cb19            		rr	c       			;; divide BC by 2 and shifting the state of bit 0 into the carry
   301                          							;; if carry = 0, then state of bit 0 was 0, (the rightmost digit was 0)
   302                          							;; if carry = 1, then state of bit 1 was 1. (the rightmost digit was 1)
   303                          							;; if rightmost digit was 0, then the result would be 0, and we do the add.
   304                          							;; if rightmost digit was 1, then the result is DE and we do the add.
   305   0008da 3001            		jr	nc, mul16noadd
   306                          
   307                          							;; will get to here if carry = 1
   308   0008dc 19              		add	hl, de
   309                          
   310                          mul16noadd:
   311                              ;; at this point BC has already been divided by 2
   312                          
   313   0008dd eb              		ex	de,	hl 			;; swap DE and HL
   314   0008de 29              		add	hl, hl				;; multiply DE by 2
   315   0008df eb              		ex	de,	hl 			;; swap DE and HL
   316                          
   317                              ;; at this point DE has been multiplied by 2
   318                          
   319   0008e0 3d              		dec	a
   320   0008e1 20f3            		jr	nz, mul16loop			;; process more bits
   321   0008e3 c9              		ret
   322                          
cpm22bios.asm:
   510                          
   511                          
   512                          ;--------------------------------------------------------------
   513                          ;--------------------------------------------------------------
   514                          ;		E N D
   515                          ;--------------------------------------------------------------
   516                          ;--------------------------------------------------------------
   517                          
   518                          
   519                          		IFDEF NOEXCLUDE
   520                          cmdOpenDisk:
   521                          		ld	a, (diskno)
   522                          		call	bin2deca
   523                          		ld	HL, opendiskno
   524                          		call	dec2disp
   525                          		ld	HL, (opendiskno)
   526                          		ld	(opendiskno1), HL
   527                          
   528                          		ld	HL, opendisk
   529                          		jp	sendCommand
   530                          
   531                          
   532                          cmdPutSector:
   533                          		ld	a, (diskno)		; write diskno
   534                          		call	bin2deca		; in paintext
   535                          		ld	HL, putsdisk		; to getsdisk
   536                          		call	dec2disp
   537                          		ld	a, (track)		; write track
   538                          		call	bin2deca
   539                          		ld	HL, putstrack
   540                          		call	dec2disp
   541                          		ld	a, (sector)		; write sector
   542                          		call	bin2deca
   543                          		ld	HL, putssector
   544                          		call	dec2disp
   545                          
   546                          		ld	HL, (dmaad)		;128 from (dmadat)
   547                          		ld	DE, secdata		;to secdata
   548                          		ld	BC, 128			;set length length
   549                          		ld	(seclen), BC
   550                          		ldir
   551                          
   552                          		ld	DE, seclen
   553                          		ld	HL, putsdata-2
   554                          		call	codeBase64
   555                          		ld	HL, 00a0dh
   556                          		ld	(putsdata-2), HL
   557                          
   558                          		ld	HL, putsector
   559                          		jp	sendCommand
   560                          
   561                          
   562                          cmdGetSector:
   563                          		ld	a, (diskno)		; write diskno
   564                          		call	bin2deca		; in paintext
   565                          		ld	HL, getsdisk		; to getsdisk
   566                          		call	dec2disp
   567                          		ld	a, (track)		; write track
   568                          		call	bin2deca
   569                          		ld	HL, getstrack
   570                          		call	dec2disp
   571                          		ld	a, (sector)		; write sector
   572                          		call	bin2deca
   573                          		ld	HL, getssector
   574                          		call	dec2disp
   575                          
   576                          		ld	HL, getsector		; send the sector-command
   577                          		call	sendCommand
   578                          
   579                          ;		ld	a, h
   580                          ;		call	printhex
   581                          ;		ld	a, l
   582                          ;		call	printhex
   583                          ;		ld	a, d
   584                          ;		call	printhex
   585                          ;		ld	a, e
   586                          ;		call	printhex
   587                          ;		ld	c, 32
   588                          ;		call	chrout
   589                          
   590                          		ex	DE, HL			;DE = OK + 5
   591                          		dec	HL			;HL - 4
   592                          		dec	HL
   593                          		dec	HL
   594                          		dec	HL
   595                          		xor	a
   596                          		ld	(HL), a
   597                          		ld	a, 172			;decode from
   598                          		dec	HL
   599                          		ld	(HL), a
   600                          		ld	DE, seclen		;into seclen
   601                          		jp	decodeBase64
   602                          
   603                          
   604                          
   605                          sendCommand:
   606                          		push	HL
   607                          		push	HL
   608                          
   609                          		ld	HL, atstatus		;status of connection
   610                          		call	writeesp
   611                          		ld	a, (line + 21)
   612                          		cp	'3'
   613                          		jp	Z, sendCommand1		;if 3 send command
   614                          
   615                          sendCommand3:
   616                          		ld	HL, connect
   617                          		call	writeesp
   618                          		jr	NC, sendCommand1
   619                          
   620                          enterIP:
   621                          		ld	HL, iptext
   622                          		call	printstr
   623                          		call	getline
   624                          		ld	HL, line
   625                          		ld	DE, connectip
   626                          		call	copystr
   627                          
   628                          		dec	DE
   629                          		ld	HL, porttext
   630                          		call	copystr
   631                          		ld	(DE), a
   632                          ;		jp	error
   633                          		jr	sendCommand3
   634                          
   635                          sendCommand1:
   636                          		pop	HL
   637                          		call	strlen			;length in DE
   638                          ;		ld	a, d
   639                          ;		call	printhex
   640                          ;		ld	a, e
   641                          ;		call	printhex
   642                          		call	bin2dec			;e in hex to a in dec
   643                          		ld	HL, cipsendlenl		;prite dec to display
   644                          		call	dec2disp
   645                          		ld	HL, 03030h		;"00" into
   646                          		ld	(cipsendlenh), HL
   647                          		ld	a, d
   648                          		or	a
   649                          		jr	Z, sendCommand2
   650                          		ld	HL, 03230h		;02
   651                          		ld	(cipsend+11), HL
   652                          		ld	HL, 03638h		;86
   653                          		ld	(cipsend+13), HL
   654                          
   655                          sendCommand2:
   656                          		ld	HL, cipsend
   657                          		call	writeesp
   658                          		jr	NC, sendCommand4
   659                          		pop	HL
   660                          		xor	a
   661                          		call	printhex
   662                          		jr	sendCommand
   663                          
   664                          
   665                          ;		call	prtline
   666                          sendCommand4:
   667                          		call	espin
   668                          		call	espin
   669                          
   670                          
   671                          		pop	HL
   672                          		push	HL
   673                          		call	writeesp
   674                          		pop	HL
   675                          		ret
   676                          
   677                          ;		ret	NC
   678                          ;		ld	a, 1
   679                          ;		call	printhex
   680                          ;		jr	sendCommand
   681                          
   682                          
   683                          error:
   684                          		ld	b, 0
   685                          e1:		djnz	e1
   686                          		ld	a, 080h			;OP7 = HIGH
   687                          		out	(OPRES), a
   688                          		jp	0
   689                          
   690                          connect:	DB	"AT+CIPSTART=\"TCP\",\""
   691                          connectip:	DB	"192.168.178.22"
   692                          		DB	"\","
   693                          connectport:	DB	"4434",13,10,0,0,0
   694                          
   695                          cipsend:	DB	"AT+CIPSEND="
   696                          cipsendlenh:	DB	"00"
   697                          cipsendlenl:	DB	"xx",13,10,0
   698                          
   699                          opendisk:	DB	"GET /disk?func=open&disk="
   700                          opendiskno:	DB	"00"
   701                          		DB	"&filename=disk"
   702                          opendiskno1:	DB	"00.dsk HTTP/1.0",13,10,13,10,0
   703                          
   704                          getsector:	DB	"GET /sectordata?disk="
   705                          getsdisk:	DB	"00"
   706                          		DB	"&track="
   707                          getstrack:	DB	"00"
   708                          		DB	"&sector="
   709                          getssector:	DB	"00"
   710                          		DB	" HTTP/1.1",13,10
   711                          		DB	"Host: roland.z80",13,10,13,10,0
   712                          
   713                          putsector:	DB	"PUT /sectordata?disk="
   714                          putsdisk:	DB	"00"
   715                          		DB	"&track="
   716                          putstrack:	DB	"00"
   717                          		DB	"&sector="
   718                          putssector:	DB	"00"
   719                          		DB	" HTTP/1.0",13,10
   720                          		DB	"Host: roland.z80",13,10
   721                          		DB	"Accept: text/plain",13,10
   722                          		DB	"Content-Length: 172",13,10,13,10
   723                          putsdata:	DS	172
   724                          		DB	0
   725                          atstatus:	DB	"AT+CIPSTATUS",13,10,0
   726                          iptext:		DB	13,10,"IP:",0
   727                          porttext:	DB	"\",4434",13,10,0
   728                          
   729                          
   730                          ;--------------------------------------------------------------
   731                          ; DE: Pointer to input-area
   732                          ; HL: Base64 coded output input
   733                          ;
   734                          ; area: 2-byte          len
   735                          ;       xxx-byte        data
   736                          ;--------------------------------------------------------------
   737                          codeBase64:
   738                          		push    HL              ; IY = ptr to out-length
   739                          		pop     IY
   740                          		inc     HL
   741                          		inc     HL
   742                          		push    HL              ; save ptr to out-data
   743                          
   744                          		ld      a, (DE)
   745                          		neg
   746                          		ld      c, a
   747                          		inc     DE
   748                          		ld      a, (DE)
   749                          		neg
   750                          		ld      b, a
   751                          		inc     DE              ; BC = in-len
   752                          		push    BC
   753                          		pop     IX
   754                          		add     IX, DE
   755                          
   756                          		ld      c, 0
   757                          
   758                          code_loop1:
   759                          		ex      DE, HL          ;switch to input-pointer
   760                          		ld      a, c
   761                          		inc     c
   762                          		and     3
   763                          
   764                          		jr      NZ, code1
   765                          
   766                          		ld      a, (HL)
   767                          		rra
   768                          		rra
   769                          		and     00111111b
   770                          		call    codeB64
   771                          		jr      code_loop
   772                          
   773                          code1:
   774                          		dec     a
   775                          		jr      NZ, code2
   776                          		ld      a, (HL)
   777                          		rla
   778                          		rla
   779                          		rla
   780                          		rla
   781                          		and     00110000b
   782                          		ld      b, a
   783                          		inc     HL
   784                          		ld      a, (HL)
   785                          		rra
   786                          		rra
   787                          		rra
   788                          		rra
   789                          		and     %00001111
   790                          		or      b
   791                          		call    codeB64
   792                          		jr      code_loop
   793                          
   794                          code2:
   795                          		dec     a
   796                          		jr      NZ, code3
   797                          		ld      a, (HL)
   798                          		rla
   799                          		rla
   800                          		and     00111100b
   801                          		ld      b, a
   802                          		inc     HL
   803                          		ld      a, (HL)
   804                          		rlca
   805                          		rlca
   806                          		and     00000011b
   807                          		or      b
   808                          		call    codeB64
   809                          
   810                          code_loop:
   811                          		ex      DE, HL                  ;switch to output-pointer
   812                          		ld      (HL), a                 ;store base64 symbol
   813                          		inc     HL
   814                          		jr      code_loop1
   815                          
   816                          code3:
   817                          		ld      a, (HL)
   818                          		inc     HL
   819                          		and     00111111b
   820                          		call    codeB64
   821                          
   822                          		ex      DE, HL                  ;switch HL to output-pointer
   823                          		ld      (HL), a                 ;store base64 symbol
   824                          		inc     HL
   825                          
   826                          		push    DE
   827                          		push    HL
   828                          		ex      DE, HL
   829                          		push    IX
   830                          		pop     DE
   831                          		sbc     HL, DE
   832                          		ld      b, l
   833                          		pop     HL
   834                          		pop     DE
   835                          
   836                          		jp      M, code_loop1
   837                          		push    HL
   838                          code3a:
   839                          		jr      Z, code3b
   840                          		dec     HL
   841                          		ld      (HL), '='
   842                          		djnz    code3a
   843                          code3b:
   844                          		pop     HL
   845                          		pop     DE
   846                          		sbc     HL, DE
   847                          		ld      (IY), l
   848                          		ld      (IY + 1), h
   849                          		ret
   850                          
   851                          
   852                          
   853                          ;--------------------------------------------------------------
   854                          ; DE: Pointer to output-area
   855                          ; HL: Base64 coded input
   856                          ;
   857                          ; area: 2-byte          len
   858                          ;       xxx-byte        data
   859                          ;--------------------------------------------------------------
   860                          decodeBase64:
   861                          		ld      c, (HL)                 ; load lo, hi length
   862                          		inc     HL
   863                          		ld      b, (HL)
   864                          		inc     HL
   865                          		push    BC
   866                          		exx
   867                          		pop     BC                      ; put length in BC'
   868                          		exx
   869                          
   870                          		ld      c, 0
   871                          
   872                          		push    DE                      ; save out-ptr on stack
   873                          		inc     DE                      ; skip-out-length
   874                          		inc     DE
   875                          		push    DE                      ; save it, too
   876                          
   877                          decode_loop1:
   878                          		call    decodeB64               ; load in-byte in (HL) and decode into a
   879                          		ld      b, a
   880                          		ld      a, c
   881                          		inc     c
   882                          		jr      C, decode_loop2         ; if decodeB64 has set Carry, input was '='
   883                          
   884                          		inc     HL                      ; increment input-pointer
   885                          		ex      DE, HL                  ; switch to output-pointer
   886                          		and     3
   887                          
   888                          		jr      NZ, decode1
   889                          
   890                          		ld      a, b
   891                          		rla
   892                          		rla
   893                          		and     11111100b
   894                          		ld      (HL), a
   895                          		jr      decode_loop
   896                          
   897                          decode1:
   898                          		dec     a
   899                          		jr      NZ, decode2
   900                          		ld      a, b
   901                          		rra
   902                          		rra
   903                          		rra
   904                          		rra
   905                          		and     00000011b
   906                          		or      (HL)
   907                          		ld      (HL), a
   908                          		inc     HL
   909                          		ld      a, b
   910                          		rla
   911                          		rla
   912                          		rla
   913                          		rla
   914                          		and     11110000b
   915                          		ld      (HL), a
   916                          		jr      decode_loop
   917                          
   918                          decode2:
   919                          		dec     a
   920                          		jr      NZ, decode3
   921                          		ld      a, b
   922                          		rra
   923                          		rra
   924                          		and     00001111b
   925                          		or      (HL)
   926                          		ld      (HL), a
   927                          		inc     HL
   928                          		ld      a, b
   929                          		rrca
   930                          		rrca
   931                          		and     11000000b
   932                          		ld      (HL), a
   933                          		jr      decode_loop
   934                          
   935                          decode3:
   936                          		ld      a, b
   937                          		or      (HL)
   938                          		ld      (HL), a
   939                          		inc     HL
   940                          
   941                          decode_loop:
   942                          		ex      DE, HL                  ; switch to input-pointer
   943                          
   944                          		exx
   945                          		dec     BC
   946                          		ld      a, b
   947                          		or      c
   948                          		exx
   949                          		jr      NZ, decode_loop1
   950                          
   951                          decode_loop2:
   952                          		ex      DE, HL                  ; switch to output-pointer
   953                          		pop     DE                      ; get start of output
   954                          
   955                          		or      a                       ; reset carry!
   956                          		sbc     HL, DE                  ; len = end - start
   957                          		pop     DE                      ; load address of output-len
   958                          		ex      DE, HL                  ; switch to output-len
   959                          		ld      (HL), E                 ; save len
   960                          		inc     HL
   961                          		ld      (HL), D
   962                          		ret
   963                          
   964                          
   965                          
   966                          decodeB64:
   967                          		ld      a, (HL)
   968                          
   969                          		cp      '='
   970                          		jr      NZ, decodeB64e
   971                          		xor     a
   972                          		scf
   973                          		ret
   974                          decodeB64e:
   975                          		cp      '+'
   976                          		jr      NZ, decodeB64a
   977                          		ld      a, 62
   978                          		ret
   979                          decodeB64a:
   980                          		cp      '/'
   981                          		jr      NZ, decodeB64b
   982                          		ld      a, 63
   983                          		ret
   984                          decodeB64b:
   985                          		cp      ':'
   986                          		jr      NC, decodeB64c          ; not 0-9?
   987                          		add     a, 4                    ; '0' = 48 -> 52
   988                          		ret
   989                          decodeB64c:
   990                          		cp      'Z'+1
   991                          		jr      NC, decodeB64d          ; not A-Z?
   992                          		sub     'A'                     ; 'A' = 65 -> 0
   993                          		ret
   994                          decodeB64d:                             	; then a-z
   995                          		sub     71
   996                          		ret
   997                          
   998                          
   999                          
  1000                          codeB64:
  1001                          		cp      26
  1002                          		jr      NC, codeB64a
  1003                          		add     a, 'A'                     ; < 0-25
  1004                          		ret
  1005                          codeB64a:
  1006                          		cp      52
  1007                          		jr      NC, codeB64b
  1008                          		add     a, 71
  1009                          		ret
  1010                          codeB64b:
  1011                          		cp      62
  1012                          		jr      NC, codeB64c
  1013                          		sub     4
  1014                          		ret
  1015                          codeB64c:
  1016                          		cp      62
  1017                          		jr      NZ, codeB64d
  1018                          		ld      a, '+'
  1019                          		ret
  1020                          codeB64d:
  1021                          		ld      a, '/'
  1022                          		ret
  1023                          ;
  1024                          ;
  1025                          ;
  1026                          dec2disp:	push    af
  1027                          		rrca
  1028                          		rrca
  1029                          		rrca
  1030                          		rrca
  1031                          		call    dec2nibble
  1032                          		inc	HL
  1033                          		pop     af
  1034                          
  1035                          dec2nibble:   	or      0xf0
  1036                          		daa
  1037                          		add     a,0xa0
  1038                          		adc     a,0x40
  1039                          		ld	(HL), a
  1040                          		ret
  1041                          
  1042                          
  1043                          bin2deca:	ld	e, a
  1044                          bin2dec:	ld	b, 8
  1045                          		xor	a
  1046                          bin2dec1:	rlc	e
  1047                          		adc	a, a
  1048                          		daa
  1049                          		djnz	bin2dec1
  1050                          		ret
  1051                          
  1052                          
  1053                          
  1054                          strlen:		ld	DE, 0
  1055                          strlen1:
  1056                          		ld	a, (HL)
  1057                          		or	a
  1058                          		ret	z
  1059                          		inc	DE
  1060                          		inc	HL
  1061                          		jr	strlen1
  1062                          
  1063                          
  1064                          
  1065                          getesp:
  1066                          		ld	HL, line
  1067                          getesp2:
  1068                          		push	HL
  1069                          		pop	DE		; DE = HL
  1070                          getesp1:
  1071                          		call	espin
  1072                          		ld	(HL), a
  1073                          		inc	HL
  1074                          		cp	10
  1075                          		jr	NZ, getesp1	; read until EOL
  1076                          
  1077                          		ex	DE, HL
  1078                          		ld	a, (HL)
  1079                          		inc	HL
  1080                          		ld	b, (HL)
  1081                          		inc	HL
  1082                          		inc	HL
  1083                          		inc	HL
  1084                          		inc	HL
  1085                          		ld	c, (HL)
  1086                          		ex	DE, HL
  1087                          		cp	'O'		; "OK"?
  1088                          		jr	Z, getespK
  1089                          		cp	'E'		; "ERR"?
  1090                          		jr	Z, getespR
  1091                          		ld	a, c
  1092                          		cp	'F'		; "FAIL"?
  1093                          		jr	NZ, getesp2
  1094                          		ex	DE, HL
  1095                          		inc	HL
  1096                          		ld	a, (HL)
  1097                          		ex	DE, HL
  1098                          		cp	'A'
  1099                          		jr	Z, getesperr
  1100                          		jr	getesp2
  1101                          
  1102                          getespK:	ld	a, b
  1103                          		cp	'K'
  1104                          		jr	NZ, getesp2
  1105                          		xor	a
  1106                          		ld	(HL), a
  1107                          		ret
  1108                          
  1109                          getespR:	ld	a, b
  1110                          		cp	'R'
  1111                          		jr	NZ, getesp2
  1112                          getesperr:	xor	a
  1113                          		ld	(HL), a
  1114                          		scf
  1115                          		ret
  1116                          
  1117                          getespE:	ld	a, b
  1118                          		cp	'E'
  1119                          		jr	NZ, getesp2
  1120                          		jr	getesperr
  1121                          writeesp:
  1122                          		ld	a, (HL)
  1123                          		or	a
  1124                          		jr	Z, getesp
  1125                          		call	espout
  1126                          ;		call	chrout
  1127                          		inc	HL
  1128                          		jr	writeesp
  1129                          
  1130                          putesp:
  1131                          		ld	HL, line
  1132                          putesp1:
  1133                          		ld	a, (HL)
  1134                          		cp	10
  1135                          		jr	NZ, putesp2
  1136                          		ld	a, 13
  1137                          		call	espout
  1138                          		ld	a, 10
  1139                          		jp	espout
  1140                          putesp2:	call	espout
  1141                          		inc	HL
  1142                          		jr	putesp1
  1143                          
  1144                          
  1145                          
  1146                          getline:	ld	HL, line-1
  1147                          getline1:
  1148                          		inc	HL
  1149                          		call	chrin
  1150                          		ld	(HL), a
  1151                          		call	chrouta
  1152                          ;		ld	a, c
  1153                          		cp	a, 10
  1154                          		jr	NZ, getline1
  1155                          		xor	a
  1156                          		ld	(HL), a
  1157                          		ret
  1158                          
  1159                          prtline:
  1160                          		ld	HL, line
  1161                          prtline1:
  1162                          		ld	a, (HL)
  1163                          		inc	HL
  1164                          		or	a
  1165                          		ret	Z
  1166                          		call	chrouta
  1167                          		jr	prtline1
  1168                          
  1169                          ;--------------------------------------------------------------
  1170                          ; get a character in A from rs232 (2)
  1171                          ;
  1172                          ;--------------------------------------------------------------
  1173                          espin:
  1174                          		in	a, (STATB)
  1175                          		and	a, 1
  1176                          		jr	Z, espin
  1177                          		in	a, (RECB)
  1178                          		ret
  1179                          
  1180                          espstat:	in	a, (STATB)
  1181                          		and	a, 1
  1182                          		ret
  1183                          
  1184                          ;--------------------------------------------------------------
  1185                          ; output a character in A over rs232 (2)
  1186                          ;
  1187                          ;--------------------------------------------------------------
  1188                          espout:
  1189                          		push	AF
  1190                          espout1:	in	a, (STATB)
  1191                          		and	a, 4
  1192                          		jr	Z, espout1
  1193                          		pop	AF
  1194                          		out	(TRANSB), a
  1195                          		ret
  1196                          
  1197                          line:		DS	300
  1198                          
  1199                          seclen:		DS	2
  1200                          secdata:	DS	128
  1201                          		ENDIF
  1202                          
  1203   0008e4 1b5b6d0d        copyright:	DB	27, "[m", 13
  1204   0008e8 5a383020        		DB	"Z80 "
  1205   0008ec 1b5b33356d46611b		DB	27, "[35mFa", 27, "[m"
                5b6d            
  1206   0008f6 62756c6f757320  		DB	"bulous "
  1207   0008fd 1b5b33326d42691b		DB	27, "[32mBi", 27, "[m"
                5b6d            
  1208   000907 6e61727920      		DB	"nary "
  1209   00090c 1b5b33366d416e1b		DB	27, "[36mAn", 27, "[m"
                5b6d            
  1210   000916 6968696c61746f72		DB	"ihilator",13
                0d              
  1211   00091f 43502f4d20322e32		DB	"CP/M 2.2 Copyright 1979 (c) by Digital Research"
                20436f7079726967
                6874203139373920
                2863292062792044
                69676974616c2052
                65736561726368  
  1212   00094e 00              		DB	0
  1213                          
  1214                          
  1215                          
  1216                          
  1217                          ;	end
  1218                          
